/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./js/app.js":
/*!*******************!*\
  !*** ./js/app.js ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _components_assessment_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/assessment.js */ \"./js/components/assessment.js\");\n/* harmony import */ var _components_assessment_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_components_assessment_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_visualization_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/visualization.js */ \"./js/components/visualization.js\");\n/* harmony import */ var _components_visualization_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_components_visualization_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_recommendations_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/recommendations.js */ \"./js/components/recommendations.js\");\n/* harmony import */ var _components_recommendations_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_components_recommendations_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _components_export_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/export.js */ \"./js/components/export.js\");\n/* harmony import */ var _components_export_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_components_export_js__WEBPACK_IMPORTED_MODULE_3__);\n/**\n * Main Application Controller for SE Process Tailoring Framework\n * Handles navigation, data loading, and view management\n */\n\n// Import component modules\n\n\n\n\n\nclass SEFrameworkApp {\n  constructor() {\n    this.currentView = \"welcome\";\n    this.assessmentData = {};\n    this.processData = {};\n    this.questionData = {};\n    this.dependencyData = {};\n    this.recommendations = {};\n    this.assessmentEngine = null;\n    this.visualizer = null;\n    this.recommendationEngine = null;\n    this.exportManager = null;\n\n    // Assessment state\n    this.assessmentResponses = {};\n    this.assessmentScores = {\n      complexity: 0,\n      safety: 0,\n      scale: 0,\n      maturity: 0,\n      overall: 0,\n    };\n\n    this.init();\n  }\n\n  async init() {\n    try {\n      console.log(\"=== SE Framework App Initialization Started ===\");\n      this.showLoading();\n\n      // Check if required components are loaded\n      console.log(\"Step 1: Checking component availability:\", {\n        AssessmentEngine: typeof AssessmentEngine,\n        ProcessNetworkVisualizer: typeof ProcessNetworkVisualizer,\n        RecommendationEngine: typeof RecommendationEngine,\n        ExportManager: typeof ExportManager,\n      });\n\n      console.log(\"Step 2: Loading data...\");\n      await this.loadData();\n      console.log(\"Step 3: Data loaded successfully\");\n\n      console.log(\"Step 4: Setting up event listeners...\");\n      this.setupEventListeners();\n      console.log(\"Step 5: Event listeners setup complete\");\n\n      console.log(\"Step 6: Rendering welcome view...\");\n      this.renderWelcomeView();\n      console.log(\"Step 7: Welcome view rendered\");\n\n      console.log(\"Step 8: About to hide loading overlay...\");\n      this.hideLoading();\n      console.log(\"Step 9: Loading overlay hidden\");\n\n      console.log(\"=== App Initialized Successfully ===\");\n    } catch (error) {\n      console.error(\"=== App Initialization Failed ===\", error);\n      console.error(\"Error details:\", error.stack);\n      this.showError(\n        `Failed to load application data: ${error.message}. Please refresh the page.`,\n      );\n      this.hideLoading();\n    }\n  }\n\n  async loadData() {\n    try {\n      console.log(\"Starting data loading...\");\n\n      // Load data files sequentially for better error handling\n      const processesResponse = await fetch(\"data/processes.json\");\n      console.log(\"Processes response status:\", processesResponse.status);\n      if (!processesResponse.ok) {\n        throw new Error(\"Failed to load processes data\");\n      }\n      const processes = await processesResponse.json();\n\n      const questionsResponse = await fetch(\"data/questions.json\");\n      console.log(\"Questions response status:\", questionsResponse.status);\n      if (!questionsResponse.ok) {\n        throw new Error(\"Failed to load questions data\");\n      }\n      const questions = await questionsResponse.json();\n\n      const dependenciesResponse = await fetch(\"data/dependencies.json\");\n      console.log(\"Dependencies response status:\", dependenciesResponse.status);\n      if (!dependenciesResponse.ok) {\n        throw new Error(\"Failed to load dependencies data\");\n      }\n      const dependencies = await dependenciesResponse.json();\n\n      console.log(\"Data loaded successfully:\", {\n        processes: processes.processes ? processes.processes.length : 0,\n        questions: questions.assessmentCategories\n          ? questions.assessmentCategories.length\n          : 0,\n        dependencies: dependencies.dependencies\n          ? dependencies.dependencies.length\n          : 0,\n      });\n\n      this.processData = processes;\n      this.questionData = questions;\n      this.dependencyData = dependencies;\n\n      console.log(\"Step 2.5: Checking component classes...\");\n      // Check if component classes are available\n      const componentCheck = {\n        AssessmentEngine: typeof AssessmentEngine,\n        ProcessNetworkVisualizer: typeof ProcessNetworkVisualizer,\n        RecommendationEngine: typeof RecommendationEngine,\n        ExportManager: typeof ExportManager,\n      };\n      console.log(\"Component availability:\", componentCheck);\n\n      if (typeof AssessmentEngine === \"undefined\") {\n        throw new Error(\"AssessmentEngine class not loaded\");\n      }\n      if (typeof ProcessNetworkVisualizer === \"undefined\") {\n        throw new Error(\"ProcessNetworkVisualizer class not loaded\");\n      }\n      if (typeof RecommendationEngine === \"undefined\") {\n        throw new Error(\"RecommendationEngine class not loaded\");\n      }\n      if (typeof ExportManager === \"undefined\") {\n        throw new Error(\"ExportManager class not loaded\");\n      }\n\n      console.log(\"Step 2.6: Initializing components...\");\n      // Initialize components\n      this.assessmentEngine = new AssessmentEngine(this.questionData, this);\n      console.log(\"AssessmentEngine created\");\n\n      this.visualizer = new ProcessNetworkVisualizer(\n        this.processData,\n        this.dependencyData,\n        this,\n      );\n      console.log(\"ProcessNetworkVisualizer created\");\n\n      this.recommendationEngine = new RecommendationEngine(\n        this.processData,\n        this.dependencyData,\n        this,\n      );\n      console.log(\"RecommendationEngine created\");\n\n      this.exportManager = new ExportManager(this);\n      console.log(\"ExportManager created\");\n\n      console.log(\"Step 2.7: All components initialized successfully\");\n    } catch (error) {\n      console.error(\"Error loading data:\", error);\n      throw error;\n    }\n  }\n\n  setupEventListeners() {\n    try {\n      // Navigation\n      const brandLink = document.getElementById(\"brand-link\");\n      if (brandLink) {\n        brandLink.addEventListener(\"click\", (e) => {\n          e.preventDefault();\n          this.showView(\"welcome\");\n        });\n      }\n\n      const navWelcome = document.getElementById(\"nav-welcome\");\n      if (navWelcome) {\n        navWelcome.addEventListener(\"click\", (e) => {\n          e.preventDefault();\n          this.showView(\"welcome\");\n        });\n      }\n\n      const navAssessment = document.getElementById(\"nav-assessment\");\n      if (navAssessment) {\n        navAssessment.addEventListener(\"click\", (e) => {\n          e.preventDefault();\n          this.showView(\"assessment\");\n        });\n      }\n\n      const navVisualization = document.getElementById(\"nav-visualization\");\n      if (navVisualization) {\n        navVisualization.addEventListener(\"click\", (e) => {\n          e.preventDefault();\n          this.showView(\"visualization\");\n        });\n      }\n\n      const navRecommendations = document.getElementById(\"nav-recommendations\");\n      if (navRecommendations) {\n        navRecommendations.addEventListener(\"click\", (e) => {\n          e.preventDefault();\n          this.showView(\"recommendations\");\n        });\n      }\n\n      const navExport = document.getElementById(\"nav-export\");\n      if (navExport) {\n        navExport.addEventListener(\"click\", (e) => {\n          e.preventDefault();\n          this.showView(\"export\");\n        });\n      }\n\n      // Start assessment button\n      const startAssessmentBtn = document.getElementById(\n        \"start-assessment-btn\",\n      );\n      if (startAssessmentBtn) {\n        startAssessmentBtn.addEventListener(\"click\", () => {\n          this.showView(\"assessment\");\n        });\n      }\n    } catch (error) {\n      console.error(\"Error setting up event listeners:\", error);\n    }\n\n    // Keyboard navigation\n    document.addEventListener(\"keydown\", (e) => {\n      if (e.ctrlKey || e.metaKey) {\n        switch (e.key) {\n          case \"1\":\n            e.preventDefault();\n            this.showView(\"welcome\");\n            break;\n          case \"2\":\n            e.preventDefault();\n            this.showView(\"assessment\");\n            break;\n          case \"3\":\n            e.preventDefault();\n            this.showView(\"visualization\");\n            break;\n          case \"4\":\n            e.preventDefault();\n            this.showView(\"recommendations\");\n            break;\n          case \"5\":\n            e.preventDefault();\n            this.showView(\"export\");\n            break;\n        }\n      }\n    });\n  }\n\n  showView(viewName) {\n    console.log(`=== showView called with: ${viewName} ===`);\n    try {\n      console.log(`Step 1: Hiding all views...`);\n      // Hide all views\n      const allViews = document.querySelectorAll(\".view-container\");\n      console.log(`Found ${allViews.length} view containers`);\n      allViews.forEach((view) => {\n        view.style.display = \"none\";\n      });\n\n      console.log(`Step 2: Updating navigation...`);\n      // Update navigation\n      const allNavLinks = document.querySelectorAll(\".nav-link\");\n      console.log(`Found ${allNavLinks.length} nav links`);\n      allNavLinks.forEach((link) => {\n        link.classList.remove(\"active\");\n      });\n\n      console.log(`Step 3: Showing target view: ${viewName}-view`);\n      // Show selected view\n      const targetView = document.getElementById(`${viewName}-view`);\n      console.log(`Target view element:`, targetView);\n\n      if (targetView) {\n        targetView.style.display = \"block\";\n        console.log(`Step 3a: Target view displayed`);\n\n        // Activate corresponding nav link\n        const navLink = document.getElementById(`nav-${viewName}`);\n        console.log(`Nav link element:`, navLink);\n        if (navLink) {\n          navLink.classList.add(\"active\");\n          console.log(`Step 3b: Nav link activated`);\n        }\n\n        this.currentView = viewName;\n        console.log(`Step 3c: Current view set to ${viewName}`);\n\n        console.log(`Step 4: Initializing view-specific content...`);\n        // Initialize view-specific content\n        switch (viewName) {\n          case \"assessment\":\n            this.renderAssessmentView();\n            break;\n          case \"visualization\":\n            this.renderVisualizationView();\n            break;\n          case \"recommendations\":\n            this.renderRecommendationsView();\n            break;\n          case \"export\":\n            this.renderExportView();\n            break;\n        }\n        console.log(`Step 4a: View-specific content initialized`);\n\n        console.log(`Step 5: Updating progress indicator...`);\n        // Update progress indicator\n        this.updateProgressIndicator();\n        console.log(`Step 5a: Progress indicator updated`);\n\n        // Scroll to top\n        window.scrollTo(0, 0);\n        console.log(`Step 6: Scrolled to top`);\n\n        console.log(`=== View ${viewName} shown successfully ===`);\n      } else {\n        console.error(`View ${viewName} not found`);\n        console.error(\n          `Available views:`,\n          Array.from(document.querySelectorAll('[id$=\"-view\"]')).map(\n            (el) => el.id,\n          ),\n        );\n      }\n    } catch (error) {\n      console.error(`Error showing view ${viewName}:`, error);\n      console.error(`Error stack:`, error.stack);\n    }\n  }\n\n  renderWelcomeView() {\n    console.log(\"Rendering welcome view...\");\n    try {\n      // Welcome view is static HTML, just ensure it's visible\n      this.showView(\"welcome\");\n      console.log(\"Welcome view rendered successfully\");\n    } catch (error) {\n      console.error(\"Error rendering welcome view:\", error);\n      // Fallback: manually show welcome view\n      const welcomeView = document.getElementById(\"welcome-view\");\n      if (welcomeView) {\n        welcomeView.style.display = \"block\";\n      }\n    }\n  }\n\n  renderAssessmentView() {\n    if (this.assessmentEngine) {\n      this.assessmentEngine.render();\n      this.showProgressIndicator();\n    }\n  }\n\n  renderVisualizationView() {\n    if (this.visualizer) {\n      // Small delay to ensure container is visible before rendering\n      setTimeout(() => {\n        this.visualizer.render();\n      }, 100);\n    }\n  }\n\n  renderRecommendationsView() {\n    if (this.recommendationEngine) {\n      this.recommendationEngine.render();\n    }\n  }\n\n  renderExportView() {\n    if (this.exportManager) {\n      this.exportManager.render();\n    }\n  }\n\n  updateProgressIndicator() {\n    const progressContainer = document.getElementById(\"progress-container\");\n    const progressBar = document.getElementById(\"overall-progress\");\n    const progressText = document.getElementById(\"progress-text\");\n\n    if (this.currentView === \"welcome\") {\n      progressContainer.style.display = \"none\";\n      return;\n    }\n\n    // Calculate overall progress\n    let progress = 0;\n    switch (this.currentView) {\n      case \"assessment\":\n        progress = this.getAssessmentProgress();\n        break;\n      case \"visualization\":\n        progress = this.hasCompletedAssessment() ? 75 : 25;\n        break;\n      case \"recommendations\":\n        progress = this.hasCompletedAssessment() ? 90 : 50;\n        break;\n      case \"export\":\n        progress = 100;\n        break;\n    }\n\n    progressContainer.style.display = \"block\";\n    progressBar.style.width = `${progress}%`;\n    progressText.textContent = `${Math.round(progress)}%`;\n  }\n\n  showProgressIndicator() {\n    document.getElementById(\"progress-container\").style.display = \"block\";\n  }\n\n  hideProgressIndicator() {\n    document.getElementById(\"progress-container\").style.display = \"none\";\n  }\n\n  getAssessmentProgress() {\n    if (!this.assessmentEngine) return 0;\n\n    const totalQuestions = this.getTotalQuestions();\n    const answeredQuestions = Object.keys(this.assessmentResponses).length;\n\n    return totalQuestions > 0\n      ? Math.min((answeredQuestions / totalQuestions) * 60, 60)\n      : 0;\n  }\n\n  getTotalQuestions() {\n    if (!this.questionData.assessmentCategories) return 0;\n\n    return this.questionData.assessmentCategories.reduce((total, category) => {\n      return total + (category.questions ? category.questions.length : 0);\n    }, 0);\n  }\n\n  hasCompletedAssessment() {\n    const totalQuestions = this.getTotalQuestions();\n    const answeredQuestions = Object.keys(this.assessmentResponses).length;\n    return answeredQuestions >= totalQuestions && totalQuestions > 0;\n  }\n\n  updateAssessmentResponse(questionId, response) {\n    this.assessmentResponses[questionId] = response;\n    this.calculateScores();\n    this.updateProgressIndicator();\n\n    // Auto-save to localStorage\n    this.saveAssessmentState();\n  }\n\n  calculateScores() {\n    if (!this.questionData.assessmentCategories) return;\n\n    const dimensionScores = {\n      complexity: [],\n      safety: [],\n      scale: [],\n      maturity: [],\n    };\n\n    // Calculate dimension scores based on responses\n    this.questionData.assessmentCategories.forEach((category) => {\n      category.questions.forEach((question) => {\n        const response = this.assessmentResponses[question.id];\n        if (response && response.score !== undefined) {\n          const dimension = question.dimension;\n          if (dimensionScores[dimension]) {\n            dimensionScores[dimension].push({\n              score: response.score,\n              weight: question.weight || 1,\n            });\n          }\n        }\n      });\n    });\n\n    // Calculate weighted averages for each dimension\n    Object.keys(dimensionScores).forEach((dimension) => {\n      const scores = dimensionScores[dimension];\n      if (scores.length > 0) {\n        const weightedSum = scores.reduce(\n          (sum, item) => sum + item.score * item.weight,\n          0,\n        );\n        const totalWeight = scores.reduce((sum, item) => sum + item.weight, 0);\n        this.assessmentScores[dimension] =\n          totalWeight > 0 ? weightedSum / totalWeight : 0;\n      }\n    });\n\n    // Calculate overall score (weighted average of dimensions)\n    const dimensionWeights = {\n      complexity: 0.3,\n      safety: 0.25,\n      scale: 0.25,\n      maturity: 0.2,\n    };\n\n    let overallScore = 0;\n    let totalWeight = 0;\n\n    Object.keys(dimensionWeights).forEach((dimension) => {\n      if (this.assessmentScores[dimension] > 0) {\n        overallScore +=\n          this.assessmentScores[dimension] * dimensionWeights[dimension];\n        totalWeight += dimensionWeights[dimension];\n      }\n    });\n\n    this.assessmentScores.overall =\n      totalWeight > 0 ? overallScore / totalWeight : 0;\n\n    // Generate recommendations if assessment is complete\n    if (this.hasCompletedAssessment() && this.recommendationEngine) {\n      this.recommendations = this.recommendationEngine.generateRecommendations(\n        this.assessmentScores,\n      );\n    }\n  }\n\n  saveAssessmentState() {\n    const state = {\n      responses: this.assessmentResponses,\n      scores: this.assessmentScores,\n      recommendations: this.recommendations,\n      timestamp: Date.now(),\n    };\n    localStorage.setItem(\"se-tailoring-assessment\", JSON.stringify(state));\n  }\n\n  loadAssessmentState() {\n    try {\n      const saved = localStorage.getItem(\"se-tailoring-assessment\");\n      if (saved) {\n        const state = JSON.parse(saved);\n\n        // Only load if saved within last 24 hours\n        const dayOld = 24 * 60 * 60 * 1000;\n        if (Date.now() - state.timestamp < dayOld) {\n          this.assessmentResponses = state.responses || {};\n          this.assessmentScores = state.scores || {};\n          this.recommendations = state.recommendations || {};\n          return true;\n        }\n      }\n    } catch (error) {\n      // Failed to load saved assessment state\n    }\n    return false;\n  }\n\n  clearAssessmentState() {\n    this.assessmentResponses = {};\n    this.assessmentScores = {\n      complexity: 0,\n      safety: 0,\n      scale: 0,\n      maturity: 0,\n      overall: 0,\n    };\n    this.recommendations = {};\n    localStorage.removeItem(\"se-tailoring-assessment\");\n    this.updateProgressIndicator();\n  }\n\n  showLoading() {\n    document.getElementById(\"loading-overlay\").style.display = \"flex\";\n  }\n\n  hideLoading() {\n    console.log(\"=== Hiding loading overlay ===\");\n    const loadingOverlay = document.getElementById(\"loading-overlay\");\n    console.log(\"Loading overlay element:\", loadingOverlay);\n\n    if (loadingOverlay) {\n      console.log(\"Current display style:\", loadingOverlay.style.display);\n      console.log(\n        \"Current computed style:\",\n        window.getComputedStyle(loadingOverlay).display,\n      );\n\n      // Try multiple approaches to hide it\n      loadingOverlay.style.display = \"none\";\n      loadingOverlay.style.visibility = \"hidden\";\n      loadingOverlay.style.opacity = \"0\";\n      loadingOverlay.style.pointerEvents = \"none\";\n\n      // Also add a class to ensure it stays hidden\n      loadingOverlay.classList.add(\"hidden\");\n\n      console.log(\"Loading overlay hidden with multiple methods\");\n      console.log(\"New display style:\", loadingOverlay.style.display);\n      console.log(\n        \"New computed style:\",\n        window.getComputedStyle(loadingOverlay).display,\n      );\n    } else {\n      console.warn(\"Loading overlay element not found\");\n      console.log(\n        \"Available elements with loading in ID:\",\n        Array.from(document.querySelectorAll('[id*=\"loading\"]')).map(\n          (el) => el.id,\n        ),\n      );\n    }\n    console.log(\"=== Loading overlay hide attempt complete ===\");\n  }\n\n  showError(message) {\n    console.error(\"Showing error:\", message);\n\n    // Create and show error alert\n    const alertHtml = `\n            <div class=\"alert alert-danger alert-dismissible fade show\" role=\"alert\">\n                <i class=\"bi bi-exclamation-triangle-fill me-2\"></i>\n                <strong>Error:</strong> ${message}\n                <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"alert\"></button>\n            </div>\n        `;\n\n    // Insert at top of main content\n    const mainContent = document.getElementById(\"main-content\");\n    if (mainContent) {\n      mainContent.insertAdjacentHTML(\"afterbegin\", alertHtml);\n\n      // Auto-remove after 10 seconds\n      setTimeout(() => {\n        const alert = mainContent.querySelector(\".alert-danger\");\n        if (alert) {\n          try {\n            const bsAlert = new bootstrap.Alert(alert);\n            bsAlert.close();\n          } catch (e) {\n            // Fallback: just remove the element\n            alert.remove();\n          }\n        }\n      }, 10000);\n    } else {\n      console.error(\"Main content element not found for error display\");\n    }\n  }\n\n  showSuccess(message) {\n    // Create and show success alert\n    const alertHtml = `\n            <div class=\"alert alert-success alert-dismissible fade show\" role=\"alert\">\n                <i class=\"bi bi-check-circle-fill me-2\"></i>\n                ${message}\n                <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"alert\"></button>\n            </div>\n        `;\n\n    // Insert at top of main content\n    const mainContent = document.getElementById(\"main-content\");\n    mainContent.insertAdjacentHTML(\"afterbegin\", alertHtml);\n\n    // Auto-remove after 5 seconds\n    setTimeout(() => {\n      const alert = mainContent.querySelector(\".alert-success\");\n      if (alert) {\n        const bsAlert = new bootstrap.Alert(alert);\n        bsAlert.close();\n      }\n    }, 5000);\n  }\n\n  // Utility methods\n  getProcessById(processId) {\n    return this.processData.processes?.find((p) => p.id === processId);\n  }\n\n  getDependenciesForProcess(processId) {\n    return (\n      this.dependencyData.dependencies?.filter((d) => d.source === processId) ||\n      []\n    );\n  }\n\n  getProcessesDependingOn(processId) {\n    return (\n      this.dependencyData.dependencies?.filter((d) => d.target === processId) ||\n      []\n    );\n  }\n\n  showProcessDetails(processId) {\n    const modal = document.getElementById('process-detail-modal');\n    const title = document.getElementById('process-modal-title');\n    const body = document.getElementById('process-modal-body');\n\n    if (!modal || !title || !body) {\n      console.error('Modal elements not found - check HTML structure');\n      return;\n    }\n\n    // Ensure modal is properly initialized in the DOM\n    if (!modal.classList.contains('modal')) {\n      console.error('Modal element is not properly initialized');\n      return;\n    }\n\n    const process = this.getProcessById(processId);\n    const recommendation = this.recommendations[processId];\n\n    if (!process) {\n      return;\n    }\n\n    const recommendedLevel = recommendation?.recommendedLevel || 'basic';\n    \n    title.textContent = process.name;\n\n    body.innerHTML = `\n            <div class=\"row\">\n                <div class=\"col-md-6\">\n                    <h6>Current Recommendation</h6>\n                    <span class=\"level-badge level-${recommendedLevel}\">${recommendedLevel}</span>\n                    <p class=\"mt-2 text-muted\">${process.description || 'No description available'}</p>\n                </div>\n                <div class=\"col-md-6\">\n                    <h6>Process Metrics</h6>\n                    <ul class=\"list-unstyled\">\n                        <li><strong>Effort:</strong> ${recommendation?.effort || 1}/5</li>\n                        <li><strong>Complexity:</strong> ${recommendation?.complexity || 1}/5</li>\n                        <li><strong>Confidence:</strong> ${Math.round((recommendation?.confidence || 0.8) * 100)}%</li>\n                        <li><strong>Category:</strong> ${this.processData.processCategories?.[process.category] || process.category}</li>\n                    </ul>\n                </div>\n            </div>\n\n            ${recommendation?.rationale ? `\n                <div class=\"mt-3\">\n                    <h6>Rationale</h6>\n                    <ul class=\"list-unstyled\">\n                        ${recommendation.rationale.map(reason => `<li class=\"text-muted\">â€¢ ${reason}</li>`).join('')}\n                    </ul>\n                </div>\n            ` : ''}\n\n            ${process?.tailoringLevels ? `\n                <div class=\"mt-3\">\n                    <h6>Available Tailoring Levels</h6>\n                    <div class=\"accordion\" id=\"levels-accordion\">\n                        ${Object.keys(process.tailoringLevels).map((level, index) => `\n                            <div class=\"accordion-item\">\n                                <h2 class=\"accordion-header\">\n                                    <button class=\"accordion-button ${level !== recommendedLevel ? 'collapsed' : ''}\" \n                                            type=\"button\" data-bs-toggle=\"collapse\" \n                                            data-bs-target=\"#level-${level}\">\n                                        <span class=\"level-badge level-${level} me-2\">${level}</span>\n                                        ${process.tailoringLevels[level].description}\n                                    </button>\n                                </h2>\n                                <div id=\"level-${level}\" \n                                     class=\"accordion-collapse collapse ${level === recommendedLevel ? 'show' : ''}\"\n                                     data-bs-parent=\"#levels-accordion\">\n                                    <div class=\"accordion-body\">\n                                        <p><strong>Activities:</strong></p>\n                                        <ul>\n                                            ${process.tailoringLevels[level].activities?.map(activity => `<li>${activity}</li>`).join('') || '<li>No activities specified</li>'}\n                                        </ul>\n                                        <p><strong>Key Outputs:</strong></p>\n                                        <ul>\n                                            ${process.tailoringLevels[level].outputs?.map(output => `<li>${output}</li>`).join('') || '<li>No outputs specified</li>'}\n                                        </ul>\n                                    </div>\n                                </div>\n                            </div>\n                        `).join('')}\n                    </div>\n                </div>\n            ` : ''}\n        `;\n\n    // Ensure Bootstrap is available\n    if (typeof bootstrap === 'undefined') {\n      console.error('Bootstrap not available');\n      return;\n    }\n\n    try {\n      const bsModal = new bootstrap.Modal(modal);\n      bsModal.show();\n      console.log('Modal shown successfully for process:', processId);\n      \n      // Debug: Check modal state after showing\n      setTimeout(() => {\n        console.log('=== MODAL DEBUG INFO ===');\n        console.log('Modal display:', modal.style.display);\n        console.log('Modal classes:', modal.className);\n        console.log('Modal visibility:', modal.offsetParent !== null);\n        \n        // Check if backdrop exists\n        const backdrops = document.querySelectorAll('.modal-backdrop');\n        console.log('Backdrops found:', backdrops.length);\n        \n        // Check z-index issues\n        console.log('Modal z-index:', modal.style.zIndex);\n        console.log('Modal computed z-index:', window.getComputedStyle(modal).zIndex);\n        \n        // Check if modal is actually visible\n        const rect = modal.getBoundingClientRect();\n        console.log('Modal position:', rect.top, rect.left, rect.width, rect.height);\n        console.log('Modal in viewport:', rect.top >= 0 && rect.left >= 0 && \n          rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && \n          rect.right <= (window.innerWidth || document.documentElement.clientWidth));\n        \n        // Check if any parent elements are hidden\n        let current = modal;\n        const hiddenParents = [];\n        while (current.parentElement) {\n          current = current.parentElement;\n          const style = window.getComputedStyle(current);\n          if (style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0') {\n            hiddenParents.push(current);\n          }\n        }\n        console.log('Hidden parents:', hiddenParents.length, hiddenParents);\n        \n        // Force modal to be visible if hidden - check all possible hiding conditions\n        const computedStyle = window.getComputedStyle(modal);\n        if (modal.offsetParent === null || \n            rect.width === 0 || \n            rect.height === 0 ||\n            computedStyle.display === 'none' ||\n            computedStyle.visibility === 'hidden' ||\n            computedStyle.opacity === '0') {\n          \n          console.log('Modal appears hidden - forcing visibility');\n          \n          // Remove from DOM and re-append to ensure proper positioning\n          const parent = modal.parentElement;\n          parent.removeChild(modal);\n          document.body.appendChild(modal);\n          \n          // Force visible styles\n          modal.style.display = 'block';\n          modal.style.visibility = 'visible';\n          modal.style.opacity = '1';\n          modal.style.zIndex = '1050';\n          modal.style.position = 'fixed';\n          modal.style.top = '50%';\n          modal.style.left = '50%';\n          modal.style.transform = 'translate(-50%, -50%)';\n          \n          // Ensure backdrop is properly positioned\n          const backdrops = document.querySelectorAll('.modal-backdrop');\n          backdrops.forEach(backdrop => {\n            backdrop.style.zIndex = '1040';\n          });\n        }\n        \n        console.log('=== END DEBUG ===');\n      }, 100);\n      \n    } catch (error) {\n      console.error('Failed to show modal:', error);\n      // Fallback: manually show the modal if Bootstrap fails\n      modal.style.display = 'block';\n      modal.classList.add('show');\n      document.body.classList.add('modal-open');\n      \n      // Create backdrop manually\n      const backdrop = document.createElement('div');\n      backdrop.className = 'modal-backdrop fade show';\n      backdrop.style.zIndex = '1040';\n      document.body.appendChild(backdrop);\n      \n      // Ensure modal has proper z-index\n      modal.style.zIndex = '1050';\n    }\n  }\n\n  // Public API for components\n  getAssessmentData() {\n    return {\n      responses: this.assessmentResponses,\n      scores: this.assessmentScores,\n      recommendations: this.recommendations,\n    };\n  }\n\n  getProcessData() {\n    return this.processData;\n  }\n\n  getDependencyData() {\n    return this.dependencyData;\n  }\n}\n\n// Initialize application when DOM is loaded\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  console.log(\"DOM loaded, initializing app...\");\n\n  // Failsafe: Hide loading screen after 10 seconds regardless of what happens\n  const failsafeTimeout = setTimeout(() => {\n    console.warn(\"Failsafe timeout reached - hiding loading screen\");\n    forceHideLoadingOverlay();\n  }, 10000);\n\n  // Wait a bit to ensure all scripts are loaded\n  setTimeout(() => {\n    try {\n      // Check if all required components are available\n      const requiredComponents = [\n        \"AssessmentEngine\",\n        \"ProcessNetworkVisualizer\",\n        \"RecommendationEngine\",\n        \"ExportManager\",\n      ];\n\n      const missingComponents = requiredComponents.filter(\n        (comp) => typeof window[comp] === \"undefined\",\n      );\n\n      if (missingComponents.length > 0) {\n        console.error(\"Missing components:\", missingComponents);\n        throw new Error(\n          `Required components not loaded: ${missingComponents.join(\", \")}`,\n        );\n      }\n\n      console.log(\"All components available, initializing app...\");\n      window.seApp = new SEFrameworkApp();\n\n      // Clear failsafe timeout if app initializes successfully\n      clearTimeout(failsafeTimeout);\n\n      // Additional failsafe: Force hide loading overlay after successful initialization\n      setTimeout(() => {\n        console.log(\"Additional failsafe: Forcing loading overlay to hide\");\n        forceHideLoadingOverlay();\n      }, 1000);\n    } catch (error) {\n      console.error(\"Failed to initialize app:\", error);\n\n      // Clear failsafe timeout since we're handling the error\n      clearTimeout(failsafeTimeout);\n\n      // Show error to user\n      const loadingOverlay = document.getElementById(\"loading-overlay\");\n      if (loadingOverlay) {\n        loadingOverlay.innerHTML = `\n                    <div class=\"text-center text-white\">\n                        <div class=\"spinner-border mb-3\" role=\"status\">\n                            <span class=\"visually-hidden\">Loading...</span>\n                        </div>\n                        <p class=\"text-danger\">Failed to initialize application</p>\n                        <p class=\"small\">${error.message}</p>\n                        <button class=\"btn btn-outline-light\" onclick=\"window.location.reload()\">Retry</button>\n                    </div>\n                `;\n      }\n    }\n  }, 100); // Small delay to ensure scripts are loaded\n});\n\n// Aggressive function to hide loading overlay\nfunction forceHideLoadingOverlay() {\n  console.log(\"=== Force hiding loading overlay ===\");\n\n  // Try multiple selectors\n  const selectors = [\n    \"#loading-overlay\",\n    \".loading-overlay\",\n    '[id*=\"loading\"]',\n    \".position-fixed.top-0.start-0.w-100.h-100\",\n  ];\n\n  selectors.forEach((selector) => {\n    try {\n      const elements = document.querySelectorAll(selector);\n      elements.forEach((element) => {\n        console.log(`Hiding element with selector: ${selector}`);\n        element.style.display = \"none\";\n        element.style.visibility = \"hidden\";\n        element.style.opacity = \"0\";\n        element.style.pointerEvents = \"none\";\n        element.classList.add(\"hidden\");\n        element.setAttribute(\"hidden\", \"\");\n      });\n    } catch (error) {\n      console.warn(`Error hiding elements with selector ${selector}:`, error);\n    }\n  });\n\n  // Also try to remove the loading overlay completely\n  try {\n    const loadingOverlay = document.getElementById(\"loading-overlay\");\n    if (loadingOverlay && loadingOverlay.parentNode) {\n      console.log(\"Removing loading overlay from DOM\");\n      loadingOverlay.parentNode.removeChild(loadingOverlay);\n    }\n  } catch (error) {\n    console.warn(\"Error removing loading overlay from DOM:\", error);\n  }\n\n  console.log(\"=== Force hide complete ===\");\n}\n\n// Handle browser back/forward buttons\nwindow.addEventListener(\"popstate\", (event) => {\n  if (window.seApp && event.state) {\n    window.seApp.showView(event.state.view);\n  }\n});\n\n// Export for global access\nwindow.SEFrameworkApp = SEFrameworkApp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2UtdGFpbG9yaW5nLWZyYW1ld29yay8uL2pzL2FwcC5qcz83NDczIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTWFpbiBBcHBsaWNhdGlvbiBDb250cm9sbGVyIGZvciBTRSBQcm9jZXNzIFRhaWxvcmluZyBGcmFtZXdvcmtcbiAqIEhhbmRsZXMgbmF2aWdhdGlvbiwgZGF0YSBsb2FkaW5nLCBhbmQgdmlldyBtYW5hZ2VtZW50XG4gKi9cblxuLy8gSW1wb3J0IGNvbXBvbmVudCBtb2R1bGVzXG5pbXBvcnQgJy4vY29tcG9uZW50cy9hc3Nlc3NtZW50LmpzJztcbmltcG9ydCAnLi9jb21wb25lbnRzL3Zpc3VhbGl6YXRpb24uanMnO1xuaW1wb3J0ICcuL2NvbXBvbmVudHMvcmVjb21tZW5kYXRpb25zLmpzJztcbmltcG9ydCAnLi9jb21wb25lbnRzL2V4cG9ydC5qcyc7XG5cbmNsYXNzIFNFRnJhbWV3b3JrQXBwIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jdXJyZW50VmlldyA9IFwid2VsY29tZVwiO1xuICAgIHRoaXMuYXNzZXNzbWVudERhdGEgPSB7fTtcbiAgICB0aGlzLnByb2Nlc3NEYXRhID0ge307XG4gICAgdGhpcy5xdWVzdGlvbkRhdGEgPSB7fTtcbiAgICB0aGlzLmRlcGVuZGVuY3lEYXRhID0ge307XG4gICAgdGhpcy5yZWNvbW1lbmRhdGlvbnMgPSB7fTtcbiAgICB0aGlzLmFzc2Vzc21lbnRFbmdpbmUgPSBudWxsO1xuICAgIHRoaXMudmlzdWFsaXplciA9IG51bGw7XG4gICAgdGhpcy5yZWNvbW1lbmRhdGlvbkVuZ2luZSA9IG51bGw7XG4gICAgdGhpcy5leHBvcnRNYW5hZ2VyID0gbnVsbDtcblxuICAgIC8vIEFzc2Vzc21lbnQgc3RhdGVcbiAgICB0aGlzLmFzc2Vzc21lbnRSZXNwb25zZXMgPSB7fTtcbiAgICB0aGlzLmFzc2Vzc21lbnRTY29yZXMgPSB7XG4gICAgICBjb21wbGV4aXR5OiAwLFxuICAgICAgc2FmZXR5OiAwLFxuICAgICAgc2NhbGU6IDAsXG4gICAgICBtYXR1cml0eTogMCxcbiAgICAgIG92ZXJhbGw6IDAsXG4gICAgfTtcblxuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgYXN5bmMgaW5pdCgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coXCI9PT0gU0UgRnJhbWV3b3JrIEFwcCBJbml0aWFsaXphdGlvbiBTdGFydGVkID09PVwiKTtcbiAgICAgIHRoaXMuc2hvd0xvYWRpbmcoKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgcmVxdWlyZWQgY29tcG9uZW50cyBhcmUgbG9hZGVkXG4gICAgICBjb25zb2xlLmxvZyhcIlN0ZXAgMTogQ2hlY2tpbmcgY29tcG9uZW50IGF2YWlsYWJpbGl0eTpcIiwge1xuICAgICAgICBBc3Nlc3NtZW50RW5naW5lOiB0eXBlb2YgQXNzZXNzbWVudEVuZ2luZSxcbiAgICAgICAgUHJvY2Vzc05ldHdvcmtWaXN1YWxpemVyOiB0eXBlb2YgUHJvY2Vzc05ldHdvcmtWaXN1YWxpemVyLFxuICAgICAgICBSZWNvbW1lbmRhdGlvbkVuZ2luZTogdHlwZW9mIFJlY29tbWVuZGF0aW9uRW5naW5lLFxuICAgICAgICBFeHBvcnRNYW5hZ2VyOiB0eXBlb2YgRXhwb3J0TWFuYWdlcixcbiAgICAgIH0pO1xuXG4gICAgICBjb25zb2xlLmxvZyhcIlN0ZXAgMjogTG9hZGluZyBkYXRhLi4uXCIpO1xuICAgICAgYXdhaXQgdGhpcy5sb2FkRGF0YSgpO1xuICAgICAgY29uc29sZS5sb2coXCJTdGVwIDM6IERhdGEgbG9hZGVkIHN1Y2Nlc3NmdWxseVwiKTtcblxuICAgICAgY29uc29sZS5sb2coXCJTdGVwIDQ6IFNldHRpbmcgdXAgZXZlbnQgbGlzdGVuZXJzLi4uXCIpO1xuICAgICAgdGhpcy5zZXR1cEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICBjb25zb2xlLmxvZyhcIlN0ZXAgNTogRXZlbnQgbGlzdGVuZXJzIHNldHVwIGNvbXBsZXRlXCIpO1xuXG4gICAgICBjb25zb2xlLmxvZyhcIlN0ZXAgNjogUmVuZGVyaW5nIHdlbGNvbWUgdmlldy4uLlwiKTtcbiAgICAgIHRoaXMucmVuZGVyV2VsY29tZVZpZXcoKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiU3RlcCA3OiBXZWxjb21lIHZpZXcgcmVuZGVyZWRcIik7XG5cbiAgICAgIGNvbnNvbGUubG9nKFwiU3RlcCA4OiBBYm91dCB0byBoaWRlIGxvYWRpbmcgb3ZlcmxheS4uLlwiKTtcbiAgICAgIHRoaXMuaGlkZUxvYWRpbmcoKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiU3RlcCA5OiBMb2FkaW5nIG92ZXJsYXkgaGlkZGVuXCIpO1xuXG4gICAgICBjb25zb2xlLmxvZyhcIj09PSBBcHAgSW5pdGlhbGl6ZWQgU3VjY2Vzc2Z1bGx5ID09PVwiKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIj09PSBBcHAgSW5pdGlhbGl6YXRpb24gRmFpbGVkID09PVwiLCBlcnJvcik7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZGV0YWlsczpcIiwgZXJyb3Iuc3RhY2spO1xuICAgICAgdGhpcy5zaG93RXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gbG9hZCBhcHBsaWNhdGlvbiBkYXRhOiAke2Vycm9yLm1lc3NhZ2V9LiBQbGVhc2UgcmVmcmVzaCB0aGUgcGFnZS5gLFxuICAgICAgKTtcbiAgICAgIHRoaXMuaGlkZUxvYWRpbmcoKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBsb2FkRGF0YSgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coXCJTdGFydGluZyBkYXRhIGxvYWRpbmcuLi5cIik7XG5cbiAgICAgIC8vIExvYWQgZGF0YSBmaWxlcyBzZXF1ZW50aWFsbHkgZm9yIGJldHRlciBlcnJvciBoYW5kbGluZ1xuICAgICAgY29uc3QgcHJvY2Vzc2VzUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcImRhdGEvcHJvY2Vzc2VzLmpzb25cIik7XG4gICAgICBjb25zb2xlLmxvZyhcIlByb2Nlc3NlcyByZXNwb25zZSBzdGF0dXM6XCIsIHByb2Nlc3Nlc1Jlc3BvbnNlLnN0YXR1cyk7XG4gICAgICBpZiAoIXByb2Nlc3Nlc1Jlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBsb2FkIHByb2Nlc3NlcyBkYXRhXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJvY2Vzc2VzID0gYXdhaXQgcHJvY2Vzc2VzUmVzcG9uc2UuanNvbigpO1xuXG4gICAgICBjb25zdCBxdWVzdGlvbnNSZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiZGF0YS9xdWVzdGlvbnMuanNvblwiKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiUXVlc3Rpb25zIHJlc3BvbnNlIHN0YXR1czpcIiwgcXVlc3Rpb25zUmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIGlmICghcXVlc3Rpb25zUmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGxvYWQgcXVlc3Rpb25zIGRhdGFcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBxdWVzdGlvbnMgPSBhd2FpdCBxdWVzdGlvbnNSZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIGNvbnN0IGRlcGVuZGVuY2llc1Jlc3BvbnNlID0gYXdhaXQgZmV0Y2goXCJkYXRhL2RlcGVuZGVuY2llcy5qc29uXCIpO1xuICAgICAgY29uc29sZS5sb2coXCJEZXBlbmRlbmNpZXMgcmVzcG9uc2Ugc3RhdHVzOlwiLCBkZXBlbmRlbmNpZXNSZXNwb25zZS5zdGF0dXMpO1xuICAgICAgaWYgKCFkZXBlbmRlbmNpZXNSZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gbG9hZCBkZXBlbmRlbmNpZXMgZGF0YVwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IGF3YWl0IGRlcGVuZGVuY2llc1Jlc3BvbnNlLmpzb24oKTtcblxuICAgICAgY29uc29sZS5sb2coXCJEYXRhIGxvYWRlZCBzdWNjZXNzZnVsbHk6XCIsIHtcbiAgICAgICAgcHJvY2Vzc2VzOiBwcm9jZXNzZXMucHJvY2Vzc2VzID8gcHJvY2Vzc2VzLnByb2Nlc3Nlcy5sZW5ndGggOiAwLFxuICAgICAgICBxdWVzdGlvbnM6IHF1ZXN0aW9ucy5hc3Nlc3NtZW50Q2F0ZWdvcmllc1xuICAgICAgICAgID8gcXVlc3Rpb25zLmFzc2Vzc21lbnRDYXRlZ29yaWVzLmxlbmd0aFxuICAgICAgICAgIDogMCxcbiAgICAgICAgZGVwZW5kZW5jaWVzOiBkZXBlbmRlbmNpZXMuZGVwZW5kZW5jaWVzXG4gICAgICAgICAgPyBkZXBlbmRlbmNpZXMuZGVwZW5kZW5jaWVzLmxlbmd0aFxuICAgICAgICAgIDogMCxcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnByb2Nlc3NEYXRhID0gcHJvY2Vzc2VzO1xuICAgICAgdGhpcy5xdWVzdGlvbkRhdGEgPSBxdWVzdGlvbnM7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lEYXRhID0gZGVwZW5kZW5jaWVzO1xuXG4gICAgICBjb25zb2xlLmxvZyhcIlN0ZXAgMi41OiBDaGVja2luZyBjb21wb25lbnQgY2xhc3Nlcy4uLlwiKTtcbiAgICAgIC8vIENoZWNrIGlmIGNvbXBvbmVudCBjbGFzc2VzIGFyZSBhdmFpbGFibGVcbiAgICAgIGNvbnN0IGNvbXBvbmVudENoZWNrID0ge1xuICAgICAgICBBc3Nlc3NtZW50RW5naW5lOiB0eXBlb2YgQXNzZXNzbWVudEVuZ2luZSxcbiAgICAgICAgUHJvY2Vzc05ldHdvcmtWaXN1YWxpemVyOiB0eXBlb2YgUHJvY2Vzc05ldHdvcmtWaXN1YWxpemVyLFxuICAgICAgICBSZWNvbW1lbmRhdGlvbkVuZ2luZTogdHlwZW9mIFJlY29tbWVuZGF0aW9uRW5naW5lLFxuICAgICAgICBFeHBvcnRNYW5hZ2VyOiB0eXBlb2YgRXhwb3J0TWFuYWdlcixcbiAgICAgIH07XG4gICAgICBjb25zb2xlLmxvZyhcIkNvbXBvbmVudCBhdmFpbGFiaWxpdHk6XCIsIGNvbXBvbmVudENoZWNrKTtcblxuICAgICAgaWYgKHR5cGVvZiBBc3Nlc3NtZW50RW5naW5lID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFzc2Vzc21lbnRFbmdpbmUgY2xhc3Mgbm90IGxvYWRlZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgUHJvY2Vzc05ldHdvcmtWaXN1YWxpemVyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb2Nlc3NOZXR3b3JrVmlzdWFsaXplciBjbGFzcyBub3QgbG9hZGVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBSZWNvbW1lbmRhdGlvbkVuZ2luZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWNvbW1lbmRhdGlvbkVuZ2luZSBjbGFzcyBub3QgbG9hZGVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBFeHBvcnRNYW5hZ2VyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cG9ydE1hbmFnZXIgY2xhc3Mgbm90IGxvYWRlZFwiKTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coXCJTdGVwIDIuNjogSW5pdGlhbGl6aW5nIGNvbXBvbmVudHMuLi5cIik7XG4gICAgICAvLyBJbml0aWFsaXplIGNvbXBvbmVudHNcbiAgICAgIHRoaXMuYXNzZXNzbWVudEVuZ2luZSA9IG5ldyBBc3Nlc3NtZW50RW5naW5lKHRoaXMucXVlc3Rpb25EYXRhLCB0aGlzKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiQXNzZXNzbWVudEVuZ2luZSBjcmVhdGVkXCIpO1xuXG4gICAgICB0aGlzLnZpc3VhbGl6ZXIgPSBuZXcgUHJvY2Vzc05ldHdvcmtWaXN1YWxpemVyKFxuICAgICAgICB0aGlzLnByb2Nlc3NEYXRhLFxuICAgICAgICB0aGlzLmRlcGVuZGVuY3lEYXRhLFxuICAgICAgICB0aGlzLFxuICAgICAgKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiUHJvY2Vzc05ldHdvcmtWaXN1YWxpemVyIGNyZWF0ZWRcIik7XG5cbiAgICAgIHRoaXMucmVjb21tZW5kYXRpb25FbmdpbmUgPSBuZXcgUmVjb21tZW5kYXRpb25FbmdpbmUoXG4gICAgICAgIHRoaXMucHJvY2Vzc0RhdGEsXG4gICAgICAgIHRoaXMuZGVwZW5kZW5jeURhdGEsXG4gICAgICAgIHRoaXMsXG4gICAgICApO1xuICAgICAgY29uc29sZS5sb2coXCJSZWNvbW1lbmRhdGlvbkVuZ2luZSBjcmVhdGVkXCIpO1xuXG4gICAgICB0aGlzLmV4cG9ydE1hbmFnZXIgPSBuZXcgRXhwb3J0TWFuYWdlcih0aGlzKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiRXhwb3J0TWFuYWdlciBjcmVhdGVkXCIpO1xuXG4gICAgICBjb25zb2xlLmxvZyhcIlN0ZXAgMi43OiBBbGwgY29tcG9uZW50cyBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHlcIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIGRhdGE6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIHNldHVwRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIE5hdmlnYXRpb25cbiAgICAgIGNvbnN0IGJyYW5kTGluayA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYnJhbmQtbGlua1wiKTtcbiAgICAgIGlmIChicmFuZExpbmspIHtcbiAgICAgICAgYnJhbmRMaW5rLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4ge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLnNob3dWaWV3KFwid2VsY29tZVwiKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5hdldlbGNvbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm5hdi13ZWxjb21lXCIpO1xuICAgICAgaWYgKG5hdldlbGNvbWUpIHtcbiAgICAgICAgbmF2V2VsY29tZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGUpID0+IHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5zaG93VmlldyhcIndlbGNvbWVcIik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuYXZBc3Nlc3NtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJuYXYtYXNzZXNzbWVudFwiKTtcbiAgICAgIGlmIChuYXZBc3Nlc3NtZW50KSB7XG4gICAgICAgIG5hdkFzc2Vzc21lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PiB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuc2hvd1ZpZXcoXCJhc3Nlc3NtZW50XCIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmF2VmlzdWFsaXphdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibmF2LXZpc3VhbGl6YXRpb25cIik7XG4gICAgICBpZiAobmF2VmlzdWFsaXphdGlvbikge1xuICAgICAgICBuYXZWaXN1YWxpemF0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4ge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLnNob3dWaWV3KFwidmlzdWFsaXphdGlvblwiKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5hdlJlY29tbWVuZGF0aW9ucyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibmF2LXJlY29tbWVuZGF0aW9uc1wiKTtcbiAgICAgIGlmIChuYXZSZWNvbW1lbmRhdGlvbnMpIHtcbiAgICAgICAgbmF2UmVjb21tZW5kYXRpb25zLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4ge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLnNob3dWaWV3KFwicmVjb21tZW5kYXRpb25zXCIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmF2RXhwb3J0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJuYXYtZXhwb3J0XCIpO1xuICAgICAgaWYgKG5hdkV4cG9ydCkge1xuICAgICAgICBuYXZFeHBvcnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PiB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuc2hvd1ZpZXcoXCJleHBvcnRcIik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBTdGFydCBhc3Nlc3NtZW50IGJ1dHRvblxuICAgICAgY29uc3Qgc3RhcnRBc3Nlc3NtZW50QnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXG4gICAgICAgIFwic3RhcnQtYXNzZXNzbWVudC1idG5cIixcbiAgICAgICk7XG4gICAgICBpZiAoc3RhcnRBc3Nlc3NtZW50QnRuKSB7XG4gICAgICAgIHN0YXJ0QXNzZXNzbWVudEJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc2hvd1ZpZXcoXCJhc3Nlc3NtZW50XCIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHNldHRpbmcgdXAgZXZlbnQgbGlzdGVuZXJzOlwiLCBlcnJvcik7XG4gICAgfVxuXG4gICAgLy8gS2V5Ym9hcmQgbmF2aWdhdGlvblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIChlKSA9PiB7XG4gICAgICBpZiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSkge1xuICAgICAgICBzd2l0Y2ggKGUua2V5KSB7XG4gICAgICAgICAgY2FzZSBcIjFcIjpcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd1ZpZXcoXCJ3ZWxjb21lXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIjJcIjpcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd1ZpZXcoXCJhc3Nlc3NtZW50XCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIjNcIjpcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd1ZpZXcoXCJ2aXN1YWxpemF0aW9uXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIjRcIjpcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd1ZpZXcoXCJyZWNvbW1lbmRhdGlvbnNcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiNVwiOlxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5zaG93VmlldyhcImV4cG9ydFwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzaG93Vmlldyh2aWV3TmFtZSkge1xuICAgIGNvbnNvbGUubG9nKGA9PT0gc2hvd1ZpZXcgY2FsbGVkIHdpdGg6ICR7dmlld05hbWV9ID09PWApO1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhgU3RlcCAxOiBIaWRpbmcgYWxsIHZpZXdzLi4uYCk7XG4gICAgICAvLyBIaWRlIGFsbCB2aWV3c1xuICAgICAgY29uc3QgYWxsVmlld3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnZpZXctY29udGFpbmVyXCIpO1xuICAgICAgY29uc29sZS5sb2coYEZvdW5kICR7YWxsVmlld3MubGVuZ3RofSB2aWV3IGNvbnRhaW5lcnNgKTtcbiAgICAgIGFsbFZpZXdzLmZvckVhY2goKHZpZXcpID0+IHtcbiAgICAgICAgdmlldy5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICB9KTtcblxuICAgICAgY29uc29sZS5sb2coYFN0ZXAgMjogVXBkYXRpbmcgbmF2aWdhdGlvbi4uLmApO1xuICAgICAgLy8gVXBkYXRlIG5hdmlnYXRpb25cbiAgICAgIGNvbnN0IGFsbE5hdkxpbmtzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5uYXYtbGlua1wiKTtcbiAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke2FsbE5hdkxpbmtzLmxlbmd0aH0gbmF2IGxpbmtzYCk7XG4gICAgICBhbGxOYXZMaW5rcy5mb3JFYWNoKChsaW5rKSA9PiB7XG4gICAgICAgIGxpbmsuY2xhc3NMaXN0LnJlbW92ZShcImFjdGl2ZVwiKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zb2xlLmxvZyhgU3RlcCAzOiBTaG93aW5nIHRhcmdldCB2aWV3OiAke3ZpZXdOYW1lfS12aWV3YCk7XG4gICAgICAvLyBTaG93IHNlbGVjdGVkIHZpZXdcbiAgICAgIGNvbnN0IHRhcmdldFZpZXcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChgJHt2aWV3TmFtZX0tdmlld2ApO1xuICAgICAgY29uc29sZS5sb2coYFRhcmdldCB2aWV3IGVsZW1lbnQ6YCwgdGFyZ2V0Vmlldyk7XG5cbiAgICAgIGlmICh0YXJnZXRWaWV3KSB7XG4gICAgICAgIHRhcmdldFZpZXcuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgY29uc29sZS5sb2coYFN0ZXAgM2E6IFRhcmdldCB2aWV3IGRpc3BsYXllZGApO1xuXG4gICAgICAgIC8vIEFjdGl2YXRlIGNvcnJlc3BvbmRpbmcgbmF2IGxpbmtcbiAgICAgICAgY29uc3QgbmF2TGluayA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBuYXYtJHt2aWV3TmFtZX1gKTtcbiAgICAgICAgY29uc29sZS5sb2coYE5hdiBsaW5rIGVsZW1lbnQ6YCwgbmF2TGluayk7XG4gICAgICAgIGlmIChuYXZMaW5rKSB7XG4gICAgICAgICAgbmF2TGluay5jbGFzc0xpc3QuYWRkKFwiYWN0aXZlXCIpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBTdGVwIDNiOiBOYXYgbGluayBhY3RpdmF0ZWRgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3VycmVudFZpZXcgPSB2aWV3TmFtZTtcbiAgICAgICAgY29uc29sZS5sb2coYFN0ZXAgM2M6IEN1cnJlbnQgdmlldyBzZXQgdG8gJHt2aWV3TmFtZX1gKTtcblxuICAgICAgICBjb25zb2xlLmxvZyhgU3RlcCA0OiBJbml0aWFsaXppbmcgdmlldy1zcGVjaWZpYyBjb250ZW50Li4uYCk7XG4gICAgICAgIC8vIEluaXRpYWxpemUgdmlldy1zcGVjaWZpYyBjb250ZW50XG4gICAgICAgIHN3aXRjaCAodmlld05hbWUpIHtcbiAgICAgICAgICBjYXNlIFwiYXNzZXNzbWVudFwiOlxuICAgICAgICAgICAgdGhpcy5yZW5kZXJBc3Nlc3NtZW50VmlldygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInZpc3VhbGl6YXRpb25cIjpcbiAgICAgICAgICAgIHRoaXMucmVuZGVyVmlzdWFsaXphdGlvblZpZXcoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJyZWNvbW1lbmRhdGlvbnNcIjpcbiAgICAgICAgICAgIHRoaXMucmVuZGVyUmVjb21tZW5kYXRpb25zVmlldygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImV4cG9ydFwiOlxuICAgICAgICAgICAgdGhpcy5yZW5kZXJFeHBvcnRWaWV3KCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhgU3RlcCA0YTogVmlldy1zcGVjaWZpYyBjb250ZW50IGluaXRpYWxpemVkYCk7XG5cbiAgICAgICAgY29uc29sZS5sb2coYFN0ZXAgNTogVXBkYXRpbmcgcHJvZ3Jlc3MgaW5kaWNhdG9yLi4uYCk7XG4gICAgICAgIC8vIFVwZGF0ZSBwcm9ncmVzcyBpbmRpY2F0b3JcbiAgICAgICAgdGhpcy51cGRhdGVQcm9ncmVzc0luZGljYXRvcigpO1xuICAgICAgICBjb25zb2xlLmxvZyhgU3RlcCA1YTogUHJvZ3Jlc3MgaW5kaWNhdG9yIHVwZGF0ZWRgKTtcblxuICAgICAgICAvLyBTY3JvbGwgdG8gdG9wXG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICAgICAgY29uc29sZS5sb2coYFN0ZXAgNjogU2Nyb2xsZWQgdG8gdG9wYCk7XG5cbiAgICAgICAgY29uc29sZS5sb2coYD09PSBWaWV3ICR7dmlld05hbWV9IHNob3duIHN1Y2Nlc3NmdWxseSA9PT1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFZpZXcgJHt2aWV3TmFtZX0gbm90IGZvdW5kYCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgYEF2YWlsYWJsZSB2aWV3czpgLFxuICAgICAgICAgIEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2lkJD1cIi12aWV3XCJdJykpLm1hcChcbiAgICAgICAgICAgIChlbCkgPT4gZWwuaWQsXG4gICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igc2hvd2luZyB2aWV3ICR7dmlld05hbWV9OmAsIGVycm9yKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHN0YWNrOmAsIGVycm9yLnN0YWNrKTtcbiAgICB9XG4gIH1cblxuICByZW5kZXJXZWxjb21lVmlldygpIHtcbiAgICBjb25zb2xlLmxvZyhcIlJlbmRlcmluZyB3ZWxjb21lIHZpZXcuLi5cIik7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFdlbGNvbWUgdmlldyBpcyBzdGF0aWMgSFRNTCwganVzdCBlbnN1cmUgaXQncyB2aXNpYmxlXG4gICAgICB0aGlzLnNob3dWaWV3KFwid2VsY29tZVwiKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiV2VsY29tZSB2aWV3IHJlbmRlcmVkIHN1Y2Nlc3NmdWxseVwiKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHJlbmRlcmluZyB3ZWxjb21lIHZpZXc6XCIsIGVycm9yKTtcbiAgICAgIC8vIEZhbGxiYWNrOiBtYW51YWxseSBzaG93IHdlbGNvbWUgdmlld1xuICAgICAgY29uc3Qgd2VsY29tZVZpZXcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIndlbGNvbWUtdmlld1wiKTtcbiAgICAgIGlmICh3ZWxjb21lVmlldykge1xuICAgICAgICB3ZWxjb21lVmlldy5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJlbmRlckFzc2Vzc21lbnRWaWV3KCkge1xuICAgIGlmICh0aGlzLmFzc2Vzc21lbnRFbmdpbmUpIHtcbiAgICAgIHRoaXMuYXNzZXNzbWVudEVuZ2luZS5yZW5kZXIoKTtcbiAgICAgIHRoaXMuc2hvd1Byb2dyZXNzSW5kaWNhdG9yKCk7XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyVmlzdWFsaXphdGlvblZpZXcoKSB7XG4gICAgaWYgKHRoaXMudmlzdWFsaXplcikge1xuICAgICAgLy8gU21hbGwgZGVsYXkgdG8gZW5zdXJlIGNvbnRhaW5lciBpcyB2aXNpYmxlIGJlZm9yZSByZW5kZXJpbmdcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnZpc3VhbGl6ZXIucmVuZGVyKCk7XG4gICAgICB9LCAxMDApO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlclJlY29tbWVuZGF0aW9uc1ZpZXcoKSB7XG4gICAgaWYgKHRoaXMucmVjb21tZW5kYXRpb25FbmdpbmUpIHtcbiAgICAgIHRoaXMucmVjb21tZW5kYXRpb25FbmdpbmUucmVuZGVyKCk7XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyRXhwb3J0VmlldygpIHtcbiAgICBpZiAodGhpcy5leHBvcnRNYW5hZ2VyKSB7XG4gICAgICB0aGlzLmV4cG9ydE1hbmFnZXIucmVuZGVyKCk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlUHJvZ3Jlc3NJbmRpY2F0b3IoKSB7XG4gICAgY29uc3QgcHJvZ3Jlc3NDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInByb2dyZXNzLWNvbnRhaW5lclwiKTtcbiAgICBjb25zdCBwcm9ncmVzc0JhciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwib3ZlcmFsbC1wcm9ncmVzc1wiKTtcbiAgICBjb25zdCBwcm9ncmVzc1RleHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInByb2dyZXNzLXRleHRcIik7XG5cbiAgICBpZiAodGhpcy5jdXJyZW50VmlldyA9PT0gXCJ3ZWxjb21lXCIpIHtcbiAgICAgIHByb2dyZXNzQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgb3ZlcmFsbCBwcm9ncmVzc1xuICAgIGxldCBwcm9ncmVzcyA9IDA7XG4gICAgc3dpdGNoICh0aGlzLmN1cnJlbnRWaWV3KSB7XG4gICAgICBjYXNlIFwiYXNzZXNzbWVudFwiOlxuICAgICAgICBwcm9ncmVzcyA9IHRoaXMuZ2V0QXNzZXNzbWVudFByb2dyZXNzKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInZpc3VhbGl6YXRpb25cIjpcbiAgICAgICAgcHJvZ3Jlc3MgPSB0aGlzLmhhc0NvbXBsZXRlZEFzc2Vzc21lbnQoKSA/IDc1IDogMjU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJlY29tbWVuZGF0aW9uc1wiOlxuICAgICAgICBwcm9ncmVzcyA9IHRoaXMuaGFzQ29tcGxldGVkQXNzZXNzbWVudCgpID8gOTAgOiA1MDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZXhwb3J0XCI6XG4gICAgICAgIHByb2dyZXNzID0gMTAwO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBwcm9ncmVzc0NvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIHByb2dyZXNzQmFyLnN0eWxlLndpZHRoID0gYCR7cHJvZ3Jlc3N9JWA7XG4gICAgcHJvZ3Jlc3NUZXh0LnRleHRDb250ZW50ID0gYCR7TWF0aC5yb3VuZChwcm9ncmVzcyl9JWA7XG4gIH1cblxuICBzaG93UHJvZ3Jlc3NJbmRpY2F0b3IoKSB7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwcm9ncmVzcy1jb250YWluZXJcIikuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgfVxuXG4gIGhpZGVQcm9ncmVzc0luZGljYXRvcigpIHtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInByb2dyZXNzLWNvbnRhaW5lclwiKS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gIH1cblxuICBnZXRBc3Nlc3NtZW50UHJvZ3Jlc3MoKSB7XG4gICAgaWYgKCF0aGlzLmFzc2Vzc21lbnRFbmdpbmUpIHJldHVybiAwO1xuXG4gICAgY29uc3QgdG90YWxRdWVzdGlvbnMgPSB0aGlzLmdldFRvdGFsUXVlc3Rpb25zKCk7XG4gICAgY29uc3QgYW5zd2VyZWRRdWVzdGlvbnMgPSBPYmplY3Qua2V5cyh0aGlzLmFzc2Vzc21lbnRSZXNwb25zZXMpLmxlbmd0aDtcblxuICAgIHJldHVybiB0b3RhbFF1ZXN0aW9ucyA+IDBcbiAgICAgID8gTWF0aC5taW4oKGFuc3dlcmVkUXVlc3Rpb25zIC8gdG90YWxRdWVzdGlvbnMpICogNjAsIDYwKVxuICAgICAgOiAwO1xuICB9XG5cbiAgZ2V0VG90YWxRdWVzdGlvbnMoKSB7XG4gICAgaWYgKCF0aGlzLnF1ZXN0aW9uRGF0YS5hc3Nlc3NtZW50Q2F0ZWdvcmllcykgcmV0dXJuIDA7XG5cbiAgICByZXR1cm4gdGhpcy5xdWVzdGlvbkRhdGEuYXNzZXNzbWVudENhdGVnb3JpZXMucmVkdWNlKCh0b3RhbCwgY2F0ZWdvcnkpID0+IHtcbiAgICAgIHJldHVybiB0b3RhbCArIChjYXRlZ29yeS5xdWVzdGlvbnMgPyBjYXRlZ29yeS5xdWVzdGlvbnMubGVuZ3RoIDogMCk7XG4gICAgfSwgMCk7XG4gIH1cblxuICBoYXNDb21wbGV0ZWRBc3Nlc3NtZW50KCkge1xuICAgIGNvbnN0IHRvdGFsUXVlc3Rpb25zID0gdGhpcy5nZXRUb3RhbFF1ZXN0aW9ucygpO1xuICAgIGNvbnN0IGFuc3dlcmVkUXVlc3Rpb25zID0gT2JqZWN0LmtleXModGhpcy5hc3Nlc3NtZW50UmVzcG9uc2VzKS5sZW5ndGg7XG4gICAgcmV0dXJuIGFuc3dlcmVkUXVlc3Rpb25zID49IHRvdGFsUXVlc3Rpb25zICYmIHRvdGFsUXVlc3Rpb25zID4gMDtcbiAgfVxuXG4gIHVwZGF0ZUFzc2Vzc21lbnRSZXNwb25zZShxdWVzdGlvbklkLCByZXNwb25zZSkge1xuICAgIHRoaXMuYXNzZXNzbWVudFJlc3BvbnNlc1txdWVzdGlvbklkXSA9IHJlc3BvbnNlO1xuICAgIHRoaXMuY2FsY3VsYXRlU2NvcmVzKCk7XG4gICAgdGhpcy51cGRhdGVQcm9ncmVzc0luZGljYXRvcigpO1xuXG4gICAgLy8gQXV0by1zYXZlIHRvIGxvY2FsU3RvcmFnZVxuICAgIHRoaXMuc2F2ZUFzc2Vzc21lbnRTdGF0ZSgpO1xuICB9XG5cbiAgY2FsY3VsYXRlU2NvcmVzKCkge1xuICAgIGlmICghdGhpcy5xdWVzdGlvbkRhdGEuYXNzZXNzbWVudENhdGVnb3JpZXMpIHJldHVybjtcblxuICAgIGNvbnN0IGRpbWVuc2lvblNjb3JlcyA9IHtcbiAgICAgIGNvbXBsZXhpdHk6IFtdLFxuICAgICAgc2FmZXR5OiBbXSxcbiAgICAgIHNjYWxlOiBbXSxcbiAgICAgIG1hdHVyaXR5OiBbXSxcbiAgICB9O1xuXG4gICAgLy8gQ2FsY3VsYXRlIGRpbWVuc2lvbiBzY29yZXMgYmFzZWQgb24gcmVzcG9uc2VzXG4gICAgdGhpcy5xdWVzdGlvbkRhdGEuYXNzZXNzbWVudENhdGVnb3JpZXMuZm9yRWFjaCgoY2F0ZWdvcnkpID0+IHtcbiAgICAgIGNhdGVnb3J5LnF1ZXN0aW9ucy5mb3JFYWNoKChxdWVzdGlvbikgPT4ge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IHRoaXMuYXNzZXNzbWVudFJlc3BvbnNlc1txdWVzdGlvbi5pZF07XG4gICAgICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS5zY29yZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29uc3QgZGltZW5zaW9uID0gcXVlc3Rpb24uZGltZW5zaW9uO1xuICAgICAgICAgIGlmIChkaW1lbnNpb25TY29yZXNbZGltZW5zaW9uXSkge1xuICAgICAgICAgICAgZGltZW5zaW9uU2NvcmVzW2RpbWVuc2lvbl0ucHVzaCh7XG4gICAgICAgICAgICAgIHNjb3JlOiByZXNwb25zZS5zY29yZSxcbiAgICAgICAgICAgICAgd2VpZ2h0OiBxdWVzdGlvbi53ZWlnaHQgfHwgMSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBDYWxjdWxhdGUgd2VpZ2h0ZWQgYXZlcmFnZXMgZm9yIGVhY2ggZGltZW5zaW9uXG4gICAgT2JqZWN0LmtleXMoZGltZW5zaW9uU2NvcmVzKS5mb3JFYWNoKChkaW1lbnNpb24pID0+IHtcbiAgICAgIGNvbnN0IHNjb3JlcyA9IGRpbWVuc2lvblNjb3Jlc1tkaW1lbnNpb25dO1xuICAgICAgaWYgKHNjb3Jlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHdlaWdodGVkU3VtID0gc2NvcmVzLnJlZHVjZShcbiAgICAgICAgICAoc3VtLCBpdGVtKSA9PiBzdW0gKyBpdGVtLnNjb3JlICogaXRlbS53ZWlnaHQsXG4gICAgICAgICAgMCxcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgdG90YWxXZWlnaHQgPSBzY29yZXMucmVkdWNlKChzdW0sIGl0ZW0pID0+IHN1bSArIGl0ZW0ud2VpZ2h0LCAwKTtcbiAgICAgICAgdGhpcy5hc3Nlc3NtZW50U2NvcmVzW2RpbWVuc2lvbl0gPVxuICAgICAgICAgIHRvdGFsV2VpZ2h0ID4gMCA/IHdlaWdodGVkU3VtIC8gdG90YWxXZWlnaHQgOiAwO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ2FsY3VsYXRlIG92ZXJhbGwgc2NvcmUgKHdlaWdodGVkIGF2ZXJhZ2Ugb2YgZGltZW5zaW9ucylcbiAgICBjb25zdCBkaW1lbnNpb25XZWlnaHRzID0ge1xuICAgICAgY29tcGxleGl0eTogMC4zLFxuICAgICAgc2FmZXR5OiAwLjI1LFxuICAgICAgc2NhbGU6IDAuMjUsXG4gICAgICBtYXR1cml0eTogMC4yLFxuICAgIH07XG5cbiAgICBsZXQgb3ZlcmFsbFNjb3JlID0gMDtcbiAgICBsZXQgdG90YWxXZWlnaHQgPSAwO1xuXG4gICAgT2JqZWN0LmtleXMoZGltZW5zaW9uV2VpZ2h0cykuZm9yRWFjaCgoZGltZW5zaW9uKSA9PiB7XG4gICAgICBpZiAodGhpcy5hc3Nlc3NtZW50U2NvcmVzW2RpbWVuc2lvbl0gPiAwKSB7XG4gICAgICAgIG92ZXJhbGxTY29yZSArPVxuICAgICAgICAgIHRoaXMuYXNzZXNzbWVudFNjb3Jlc1tkaW1lbnNpb25dICogZGltZW5zaW9uV2VpZ2h0c1tkaW1lbnNpb25dO1xuICAgICAgICB0b3RhbFdlaWdodCArPSBkaW1lbnNpb25XZWlnaHRzW2RpbWVuc2lvbl07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmFzc2Vzc21lbnRTY29yZXMub3ZlcmFsbCA9XG4gICAgICB0b3RhbFdlaWdodCA+IDAgPyBvdmVyYWxsU2NvcmUgLyB0b3RhbFdlaWdodCA6IDA7XG5cbiAgICAvLyBHZW5lcmF0ZSByZWNvbW1lbmRhdGlvbnMgaWYgYXNzZXNzbWVudCBpcyBjb21wbGV0ZVxuICAgIGlmICh0aGlzLmhhc0NvbXBsZXRlZEFzc2Vzc21lbnQoKSAmJiB0aGlzLnJlY29tbWVuZGF0aW9uRW5naW5lKSB7XG4gICAgICB0aGlzLnJlY29tbWVuZGF0aW9ucyA9IHRoaXMucmVjb21tZW5kYXRpb25FbmdpbmUuZ2VuZXJhdGVSZWNvbW1lbmRhdGlvbnMoXG4gICAgICAgIHRoaXMuYXNzZXNzbWVudFNjb3JlcyxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgc2F2ZUFzc2Vzc21lbnRTdGF0ZSgpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgIHJlc3BvbnNlczogdGhpcy5hc3Nlc3NtZW50UmVzcG9uc2VzLFxuICAgICAgc2NvcmVzOiB0aGlzLmFzc2Vzc21lbnRTY29yZXMsXG4gICAgICByZWNvbW1lbmRhdGlvbnM6IHRoaXMucmVjb21tZW5kYXRpb25zLFxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgIH07XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJzZS10YWlsb3JpbmctYXNzZXNzbWVudFwiLCBKU09OLnN0cmluZ2lmeShzdGF0ZSkpO1xuICB9XG5cbiAgbG9hZEFzc2Vzc21lbnRTdGF0ZSgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2F2ZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInNlLXRhaWxvcmluZy1hc3Nlc3NtZW50XCIpO1xuICAgICAgaWYgKHNhdmVkKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gSlNPTi5wYXJzZShzYXZlZCk7XG5cbiAgICAgICAgLy8gT25seSBsb2FkIGlmIHNhdmVkIHdpdGhpbiBsYXN0IDI0IGhvdXJzXG4gICAgICAgIGNvbnN0IGRheU9sZCA9IDI0ICogNjAgKiA2MCAqIDEwMDA7XG4gICAgICAgIGlmIChEYXRlLm5vdygpIC0gc3RhdGUudGltZXN0YW1wIDwgZGF5T2xkKSB7XG4gICAgICAgICAgdGhpcy5hc3Nlc3NtZW50UmVzcG9uc2VzID0gc3RhdGUucmVzcG9uc2VzIHx8IHt9O1xuICAgICAgICAgIHRoaXMuYXNzZXNzbWVudFNjb3JlcyA9IHN0YXRlLnNjb3JlcyB8fCB7fTtcbiAgICAgICAgICB0aGlzLnJlY29tbWVuZGF0aW9ucyA9IHN0YXRlLnJlY29tbWVuZGF0aW9ucyB8fCB7fTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBGYWlsZWQgdG8gbG9hZCBzYXZlZCBhc3Nlc3NtZW50IHN0YXRlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNsZWFyQXNzZXNzbWVudFN0YXRlKCkge1xuICAgIHRoaXMuYXNzZXNzbWVudFJlc3BvbnNlcyA9IHt9O1xuICAgIHRoaXMuYXNzZXNzbWVudFNjb3JlcyA9IHtcbiAgICAgIGNvbXBsZXhpdHk6IDAsXG4gICAgICBzYWZldHk6IDAsXG4gICAgICBzY2FsZTogMCxcbiAgICAgIG1hdHVyaXR5OiAwLFxuICAgICAgb3ZlcmFsbDogMCxcbiAgICB9O1xuICAgIHRoaXMucmVjb21tZW5kYXRpb25zID0ge307XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oXCJzZS10YWlsb3JpbmctYXNzZXNzbWVudFwiKTtcbiAgICB0aGlzLnVwZGF0ZVByb2dyZXNzSW5kaWNhdG9yKCk7XG4gIH1cblxuICBzaG93TG9hZGluZygpIHtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxvYWRpbmctb3ZlcmxheVwiKS5zdHlsZS5kaXNwbGF5ID0gXCJmbGV4XCI7XG4gIH1cblxuICBoaWRlTG9hZGluZygpIHtcbiAgICBjb25zb2xlLmxvZyhcIj09PSBIaWRpbmcgbG9hZGluZyBvdmVybGF5ID09PVwiKTtcbiAgICBjb25zdCBsb2FkaW5nT3ZlcmxheSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibG9hZGluZy1vdmVybGF5XCIpO1xuICAgIGNvbnNvbGUubG9nKFwiTG9hZGluZyBvdmVybGF5IGVsZW1lbnQ6XCIsIGxvYWRpbmdPdmVybGF5KTtcblxuICAgIGlmIChsb2FkaW5nT3ZlcmxheSkge1xuICAgICAgY29uc29sZS5sb2coXCJDdXJyZW50IGRpc3BsYXkgc3R5bGU6XCIsIGxvYWRpbmdPdmVybGF5LnN0eWxlLmRpc3BsYXkpO1xuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIFwiQ3VycmVudCBjb21wdXRlZCBzdHlsZTpcIixcbiAgICAgICAgd2luZG93LmdldENvbXB1dGVkU3R5bGUobG9hZGluZ092ZXJsYXkpLmRpc3BsYXksXG4gICAgICApO1xuXG4gICAgICAvLyBUcnkgbXVsdGlwbGUgYXBwcm9hY2hlcyB0byBoaWRlIGl0XG4gICAgICBsb2FkaW5nT3ZlcmxheS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICBsb2FkaW5nT3ZlcmxheS5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgIGxvYWRpbmdPdmVybGF5LnN0eWxlLm9wYWNpdHkgPSBcIjBcIjtcbiAgICAgIGxvYWRpbmdPdmVybGF5LnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcblxuICAgICAgLy8gQWxzbyBhZGQgYSBjbGFzcyB0byBlbnN1cmUgaXQgc3RheXMgaGlkZGVuXG4gICAgICBsb2FkaW5nT3ZlcmxheS5jbGFzc0xpc3QuYWRkKFwiaGlkZGVuXCIpO1xuXG4gICAgICBjb25zb2xlLmxvZyhcIkxvYWRpbmcgb3ZlcmxheSBoaWRkZW4gd2l0aCBtdWx0aXBsZSBtZXRob2RzXCIpO1xuICAgICAgY29uc29sZS5sb2coXCJOZXcgZGlzcGxheSBzdHlsZTpcIiwgbG9hZGluZ092ZXJsYXkuc3R5bGUuZGlzcGxheSk7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgXCJOZXcgY29tcHV0ZWQgc3R5bGU6XCIsXG4gICAgICAgIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGxvYWRpbmdPdmVybGF5KS5kaXNwbGF5LFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFwiTG9hZGluZyBvdmVybGF5IGVsZW1lbnQgbm90IGZvdW5kXCIpO1xuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIFwiQXZhaWxhYmxlIGVsZW1lbnRzIHdpdGggbG9hZGluZyBpbiBJRDpcIixcbiAgICAgICAgQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbaWQqPVwibG9hZGluZ1wiXScpKS5tYXAoXG4gICAgICAgICAgKGVsKSA9PiBlbC5pZCxcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKFwiPT09IExvYWRpbmcgb3ZlcmxheSBoaWRlIGF0dGVtcHQgY29tcGxldGUgPT09XCIpO1xuICB9XG5cbiAgc2hvd0Vycm9yKG1lc3NhZ2UpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiU2hvd2luZyBlcnJvcjpcIiwgbWVzc2FnZSk7XG5cbiAgICAvLyBDcmVhdGUgYW5kIHNob3cgZXJyb3IgYWxlcnRcbiAgICBjb25zdCBhbGVydEh0bWwgPSBgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYWxlcnQgYWxlcnQtZGFuZ2VyIGFsZXJ0LWRpc21pc3NpYmxlIGZhZGUgc2hvd1wiIHJvbGU9XCJhbGVydFwiPlxuICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiYmkgYmktZXhjbGFtYXRpb24tdHJpYW5nbGUtZmlsbCBtZS0yXCI+PC9pPlxuICAgICAgICAgICAgICAgIDxzdHJvbmc+RXJyb3I6PC9zdHJvbmc+ICR7bWVzc2FnZX1cbiAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0bi1jbG9zZVwiIGRhdGEtYnMtZGlzbWlzcz1cImFsZXJ0XCI+PC9idXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgYDtcblxuICAgIC8vIEluc2VydCBhdCB0b3Agb2YgbWFpbiBjb250ZW50XG4gICAgY29uc3QgbWFpbkNvbnRlbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm1haW4tY29udGVudFwiKTtcbiAgICBpZiAobWFpbkNvbnRlbnQpIHtcbiAgICAgIG1haW5Db250ZW50Lmluc2VydEFkamFjZW50SFRNTChcImFmdGVyYmVnaW5cIiwgYWxlcnRIdG1sKTtcblxuICAgICAgLy8gQXV0by1yZW1vdmUgYWZ0ZXIgMTAgc2Vjb25kc1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGFsZXJ0ID0gbWFpbkNvbnRlbnQucXVlcnlTZWxlY3RvcihcIi5hbGVydC1kYW5nZXJcIik7XG4gICAgICAgIGlmIChhbGVydCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBic0FsZXJ0ID0gbmV3IGJvb3RzdHJhcC5BbGVydChhbGVydCk7XG4gICAgICAgICAgICBic0FsZXJ0LmNsb3NlKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gRmFsbGJhY2s6IGp1c3QgcmVtb3ZlIHRoZSBlbGVtZW50XG4gICAgICAgICAgICBhbGVydC5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIDEwMDAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihcIk1haW4gY29udGVudCBlbGVtZW50IG5vdCBmb3VuZCBmb3IgZXJyb3IgZGlzcGxheVwiKTtcbiAgICB9XG4gIH1cblxuICBzaG93U3VjY2VzcyhtZXNzYWdlKSB7XG4gICAgLy8gQ3JlYXRlIGFuZCBzaG93IHN1Y2Nlc3MgYWxlcnRcbiAgICBjb25zdCBhbGVydEh0bWwgPSBgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYWxlcnQgYWxlcnQtc3VjY2VzcyBhbGVydC1kaXNtaXNzaWJsZSBmYWRlIHNob3dcIiByb2xlPVwiYWxlcnRcIj5cbiAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImJpIGJpLWNoZWNrLWNpcmNsZS1maWxsIG1lLTJcIj48L2k+XG4gICAgICAgICAgICAgICAgJHttZXNzYWdlfVxuICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuLWNsb3NlXCIgZGF0YS1icy1kaXNtaXNzPVwiYWxlcnRcIj48L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICBgO1xuXG4gICAgLy8gSW5zZXJ0IGF0IHRvcCBvZiBtYWluIGNvbnRlbnRcbiAgICBjb25zdCBtYWluQ29udGVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibWFpbi1jb250ZW50XCIpO1xuICAgIG1haW5Db250ZW50Lmluc2VydEFkamFjZW50SFRNTChcImFmdGVyYmVnaW5cIiwgYWxlcnRIdG1sKTtcblxuICAgIC8vIEF1dG8tcmVtb3ZlIGFmdGVyIDUgc2Vjb25kc1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY29uc3QgYWxlcnQgPSBtYWluQ29udGVudC5xdWVyeVNlbGVjdG9yKFwiLmFsZXJ0LXN1Y2Nlc3NcIik7XG4gICAgICBpZiAoYWxlcnQpIHtcbiAgICAgICAgY29uc3QgYnNBbGVydCA9IG5ldyBib290c3RyYXAuQWxlcnQoYWxlcnQpO1xuICAgICAgICBic0FsZXJ0LmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSwgNTAwMCk7XG4gIH1cblxuICAvLyBVdGlsaXR5IG1ldGhvZHNcbiAgZ2V0UHJvY2Vzc0J5SWQocHJvY2Vzc0lkKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc0RhdGEucHJvY2Vzc2VzPy5maW5kKChwKSA9PiBwLmlkID09PSBwcm9jZXNzSWQpO1xuICB9XG5cbiAgZ2V0RGVwZW5kZW5jaWVzRm9yUHJvY2Vzcyhwcm9jZXNzSWQpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5kZXBlbmRlbmN5RGF0YS5kZXBlbmRlbmNpZXM/LmZpbHRlcigoZCkgPT4gZC5zb3VyY2UgPT09IHByb2Nlc3NJZCkgfHxcbiAgICAgIFtdXG4gICAgKTtcbiAgfVxuXG4gIGdldFByb2Nlc3Nlc0RlcGVuZGluZ09uKHByb2Nlc3NJZCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmRlcGVuZGVuY3lEYXRhLmRlcGVuZGVuY2llcz8uZmlsdGVyKChkKSA9PiBkLnRhcmdldCA9PT0gcHJvY2Vzc0lkKSB8fFxuICAgICAgW11cbiAgICApO1xuICB9XG5cbiAgc2hvd1Byb2Nlc3NEZXRhaWxzKHByb2Nlc3NJZCkge1xuICAgIGNvbnN0IG1vZGFsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Byb2Nlc3MtZGV0YWlsLW1vZGFsJyk7XG4gICAgY29uc3QgdGl0bGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJvY2Vzcy1tb2RhbC10aXRsZScpO1xuICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJvY2Vzcy1tb2RhbC1ib2R5Jyk7XG5cbiAgICBpZiAoIW1vZGFsIHx8ICF0aXRsZSB8fCAhYm9keSkge1xuICAgICAgY29uc29sZS5lcnJvcignTW9kYWwgZWxlbWVudHMgbm90IGZvdW5kIC0gY2hlY2sgSFRNTCBzdHJ1Y3R1cmUnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgbW9kYWwgaXMgcHJvcGVybHkgaW5pdGlhbGl6ZWQgaW4gdGhlIERPTVxuICAgIGlmICghbW9kYWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdtb2RhbCcpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdNb2RhbCBlbGVtZW50IGlzIG5vdCBwcm9wZXJseSBpbml0aWFsaXplZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHByb2Nlc3MgPSB0aGlzLmdldFByb2Nlc3NCeUlkKHByb2Nlc3NJZCk7XG4gICAgY29uc3QgcmVjb21tZW5kYXRpb24gPSB0aGlzLnJlY29tbWVuZGF0aW9uc1twcm9jZXNzSWRdO1xuXG4gICAgaWYgKCFwcm9jZXNzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcmVjb21tZW5kZWRMZXZlbCA9IHJlY29tbWVuZGF0aW9uPy5yZWNvbW1lbmRlZExldmVsIHx8ICdiYXNpYyc7XG4gICAgXG4gICAgdGl0bGUudGV4dENvbnRlbnQgPSBwcm9jZXNzLm5hbWU7XG5cbiAgICBib2R5LmlubmVySFRNTCA9IGBcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTZcIj5cbiAgICAgICAgICAgICAgICAgICAgPGg2PkN1cnJlbnQgUmVjb21tZW5kYXRpb248L2g2PlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImxldmVsLWJhZGdlIGxldmVsLSR7cmVjb21tZW5kZWRMZXZlbH1cIj4ke3JlY29tbWVuZGVkTGV2ZWx9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cIm10LTIgdGV4dC1tdXRlZFwiPiR7cHJvY2Vzcy5kZXNjcmlwdGlvbiB8fCAnTm8gZGVzY3JpcHRpb24gYXZhaWxhYmxlJ308L3A+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC02XCI+XG4gICAgICAgICAgICAgICAgICAgIDxoNj5Qcm9jZXNzIE1ldHJpY3M8L2g2PlxuICAgICAgICAgICAgICAgICAgICA8dWwgY2xhc3M9XCJsaXN0LXVuc3R5bGVkXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bGk+PHN0cm9uZz5FZmZvcnQ6PC9zdHJvbmc+ICR7cmVjb21tZW5kYXRpb24/LmVmZm9ydCB8fCAxfS81PC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaT48c3Ryb25nPkNvbXBsZXhpdHk6PC9zdHJvbmc+ICR7cmVjb21tZW5kYXRpb24/LmNvbXBsZXhpdHkgfHwgMX0vNTwvbGk+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bGk+PHN0cm9uZz5Db25maWRlbmNlOjwvc3Ryb25nPiAke01hdGgucm91bmQoKHJlY29tbWVuZGF0aW9uPy5jb25maWRlbmNlIHx8IDAuOCkgKiAxMDApfSU8L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpPjxzdHJvbmc+Q2F0ZWdvcnk6PC9zdHJvbmc+ICR7dGhpcy5wcm9jZXNzRGF0YS5wcm9jZXNzQ2F0ZWdvcmllcz8uW3Byb2Nlc3MuY2F0ZWdvcnldIHx8IHByb2Nlc3MuY2F0ZWdvcnl9PC9saT5cbiAgICAgICAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAke3JlY29tbWVuZGF0aW9uPy5yYXRpb25hbGUgPyBgXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm10LTNcIj5cbiAgICAgICAgICAgICAgICAgICAgPGg2PlJhdGlvbmFsZTwvaDY+XG4gICAgICAgICAgICAgICAgICAgIDx1bCBjbGFzcz1cImxpc3QtdW5zdHlsZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICR7cmVjb21tZW5kYXRpb24ucmF0aW9uYWxlLm1hcChyZWFzb24gPT4gYDxsaSBjbGFzcz1cInRleHQtbXV0ZWRcIj7igKIgJHtyZWFzb259PC9saT5gKS5qb2luKCcnKX1cbiAgICAgICAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIGAgOiAnJ31cblxuICAgICAgICAgICAgJHtwcm9jZXNzPy50YWlsb3JpbmdMZXZlbHMgPyBgXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm10LTNcIj5cbiAgICAgICAgICAgICAgICAgICAgPGg2PkF2YWlsYWJsZSBUYWlsb3JpbmcgTGV2ZWxzPC9oNj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImFjY29yZGlvblwiIGlkPVwibGV2ZWxzLWFjY29yZGlvblwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgJHtPYmplY3Qua2V5cyhwcm9jZXNzLnRhaWxvcmluZ0xldmVscykubWFwKChsZXZlbCwgaW5kZXgpID0+IGBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYWNjb3JkaW9uLWl0ZW1cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGgyIGNsYXNzPVwiYWNjb3JkaW9uLWhlYWRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImFjY29yZGlvbi1idXR0b24gJHtsZXZlbCAhPT0gcmVjb21tZW5kZWRMZXZlbCA/ICdjb2xsYXBzZWQnIDogJyd9XCIgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIiBkYXRhLWJzLXRvZ2dsZT1cImNvbGxhcHNlXCIgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtYnMtdGFyZ2V0PVwiI2xldmVsLSR7bGV2ZWx9XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJsZXZlbC1iYWRnZSBsZXZlbC0ke2xldmVsfSBtZS0yXCI+JHtsZXZlbH08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtwcm9jZXNzLnRhaWxvcmluZ0xldmVsc1tsZXZlbF0uZGVzY3JpcHRpb259XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9oMj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cImxldmVsLSR7bGV2ZWx9XCIgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJhY2NvcmRpb24tY29sbGFwc2UgY29sbGFwc2UgJHtsZXZlbCA9PT0gcmVjb21tZW5kZWRMZXZlbCA/ICdzaG93JyA6ICcnfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1icy1wYXJlbnQ9XCIjbGV2ZWxzLWFjY29yZGlvblwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImFjY29yZGlvbi1ib2R5XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHA+PHN0cm9uZz5BY3Rpdml0aWVzOjwvc3Ryb25nPjwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7cHJvY2Vzcy50YWlsb3JpbmdMZXZlbHNbbGV2ZWxdLmFjdGl2aXRpZXM/Lm1hcChhY3Rpdml0eSA9PiBgPGxpPiR7YWN0aXZpdHl9PC9saT5gKS5qb2luKCcnKSB8fCAnPGxpPk5vIGFjdGl2aXRpZXMgc3BlY2lmaWVkPC9saT4nfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHA+PHN0cm9uZz5LZXkgT3V0cHV0czo8L3N0cm9uZz48L3A+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAke3Byb2Nlc3MudGFpbG9yaW5nTGV2ZWxzW2xldmVsXS5vdXRwdXRzPy5tYXAob3V0cHV0ID0+IGA8bGk+JHtvdXRwdXR9PC9saT5gKS5qb2luKCcnKSB8fCAnPGxpPk5vIG91dHB1dHMgc3BlY2lmaWVkPC9saT4nfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICBgKS5qb2luKCcnKX1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICBgIDogJyd9XG4gICAgICAgIGA7XG5cbiAgICAvLyBFbnN1cmUgQm9vdHN0cmFwIGlzIGF2YWlsYWJsZVxuICAgIGlmICh0eXBlb2YgYm9vdHN0cmFwID09PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcignQm9vdHN0cmFwIG5vdCBhdmFpbGFibGUnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgYnNNb2RhbCA9IG5ldyBib290c3RyYXAuTW9kYWwobW9kYWwpO1xuICAgICAgYnNNb2RhbC5zaG93KCk7XG4gICAgICBjb25zb2xlLmxvZygnTW9kYWwgc2hvd24gc3VjY2Vzc2Z1bGx5IGZvciBwcm9jZXNzOicsIHByb2Nlc3NJZCk7XG4gICAgICBcbiAgICAgIC8vIERlYnVnOiBDaGVjayBtb2RhbCBzdGF0ZSBhZnRlciBzaG93aW5nXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJz09PSBNT0RBTCBERUJVRyBJTkZPID09PScpO1xuICAgICAgICBjb25zb2xlLmxvZygnTW9kYWwgZGlzcGxheTonLCBtb2RhbC5zdHlsZS5kaXNwbGF5KTtcbiAgICAgICAgY29uc29sZS5sb2coJ01vZGFsIGNsYXNzZXM6JywgbW9kYWwuY2xhc3NOYW1lKTtcbiAgICAgICAgY29uc29sZS5sb2coJ01vZGFsIHZpc2liaWxpdHk6JywgbW9kYWwub2Zmc2V0UGFyZW50ICE9PSBudWxsKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIGJhY2tkcm9wIGV4aXN0c1xuICAgICAgICBjb25zdCBiYWNrZHJvcHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcubW9kYWwtYmFja2Ryb3AnKTtcbiAgICAgICAgY29uc29sZS5sb2coJ0JhY2tkcm9wcyBmb3VuZDonLCBiYWNrZHJvcHMubGVuZ3RoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIHotaW5kZXggaXNzdWVzXG4gICAgICAgIGNvbnNvbGUubG9nKCdNb2RhbCB6LWluZGV4OicsIG1vZGFsLnN0eWxlLnpJbmRleCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdNb2RhbCBjb21wdXRlZCB6LWluZGV4OicsIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG1vZGFsKS56SW5kZXgpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgbW9kYWwgaXMgYWN0dWFsbHkgdmlzaWJsZVxuICAgICAgICBjb25zdCByZWN0ID0gbW9kYWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdNb2RhbCBwb3NpdGlvbjonLCByZWN0LnRvcCwgcmVjdC5sZWZ0LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdNb2RhbCBpbiB2aWV3cG9ydDonLCByZWN0LnRvcCA+PSAwICYmIHJlY3QubGVmdCA+PSAwICYmIFxuICAgICAgICAgIHJlY3QuYm90dG9tIDw9ICh3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkgJiYgXG4gICAgICAgICAgcmVjdC5yaWdodCA8PSAod2luZG93LmlubmVyV2lkdGggfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoKSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiBhbnkgcGFyZW50IGVsZW1lbnRzIGFyZSBoaWRkZW5cbiAgICAgICAgbGV0IGN1cnJlbnQgPSBtb2RhbDtcbiAgICAgICAgY29uc3QgaGlkZGVuUGFyZW50cyA9IFtdO1xuICAgICAgICB3aGlsZSAoY3VycmVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGN1cnJlbnQpO1xuICAgICAgICAgIGlmIChzdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgfHwgc3R5bGUudmlzaWJpbGl0eSA9PT0gJ2hpZGRlbicgfHwgc3R5bGUub3BhY2l0eSA9PT0gJzAnKSB7XG4gICAgICAgICAgICBoaWRkZW5QYXJlbnRzLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKCdIaWRkZW4gcGFyZW50czonLCBoaWRkZW5QYXJlbnRzLmxlbmd0aCwgaGlkZGVuUGFyZW50cyk7XG4gICAgICAgIFxuICAgICAgICAvLyBGb3JjZSBtb2RhbCB0byBiZSB2aXNpYmxlIGlmIGhpZGRlbiAtIGNoZWNrIGFsbCBwb3NzaWJsZSBoaWRpbmcgY29uZGl0aW9uc1xuICAgICAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobW9kYWwpO1xuICAgICAgICBpZiAobW9kYWwub2Zmc2V0UGFyZW50ID09PSBudWxsIHx8IFxuICAgICAgICAgICAgcmVjdC53aWR0aCA9PT0gMCB8fCBcbiAgICAgICAgICAgIHJlY3QuaGVpZ2h0ID09PSAwIHx8XG4gICAgICAgICAgICBjb21wdXRlZFN0eWxlLmRpc3BsYXkgPT09ICdub25lJyB8fFxuICAgICAgICAgICAgY29tcHV0ZWRTdHlsZS52aXNpYmlsaXR5ID09PSAnaGlkZGVuJyB8fFxuICAgICAgICAgICAgY29tcHV0ZWRTdHlsZS5vcGFjaXR5ID09PSAnMCcpIHtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZygnTW9kYWwgYXBwZWFycyBoaWRkZW4gLSBmb3JjaW5nIHZpc2liaWxpdHknKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZW1vdmUgZnJvbSBET00gYW5kIHJlLWFwcGVuZCB0byBlbnN1cmUgcHJvcGVyIHBvc2l0aW9uaW5nXG4gICAgICAgICAgY29uc3QgcGFyZW50ID0gbW9kYWwucGFyZW50RWxlbWVudDtcbiAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQobW9kYWwpO1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobW9kYWwpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZvcmNlIHZpc2libGUgc3R5bGVzXG4gICAgICAgICAgbW9kYWwuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgbW9kYWwuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICAgICAgICBtb2RhbC5zdHlsZS5vcGFjaXR5ID0gJzEnO1xuICAgICAgICAgIG1vZGFsLnN0eWxlLnpJbmRleCA9ICcxMDUwJztcbiAgICAgICAgICBtb2RhbC5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICAgICAgbW9kYWwuc3R5bGUudG9wID0gJzUwJSc7XG4gICAgICAgICAgbW9kYWwuc3R5bGUubGVmdCA9ICc1MCUnO1xuICAgICAgICAgIG1vZGFsLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoLTUwJSwgLTUwJSknO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEVuc3VyZSBiYWNrZHJvcCBpcyBwcm9wZXJseSBwb3NpdGlvbmVkXG4gICAgICAgICAgY29uc3QgYmFja2Ryb3BzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLm1vZGFsLWJhY2tkcm9wJyk7XG4gICAgICAgICAgYmFja2Ryb3BzLmZvckVhY2goYmFja2Ryb3AgPT4ge1xuICAgICAgICAgICAgYmFja2Ryb3Auc3R5bGUuekluZGV4ID0gJzEwNDAnO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZygnPT09IEVORCBERUJVRyA9PT0nKTtcbiAgICAgIH0sIDEwMCk7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNob3cgbW9kYWw6JywgZXJyb3IpO1xuICAgICAgLy8gRmFsbGJhY2s6IG1hbnVhbGx5IHNob3cgdGhlIG1vZGFsIGlmIEJvb3RzdHJhcCBmYWlsc1xuICAgICAgbW9kYWwuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICBtb2RhbC5jbGFzc0xpc3QuYWRkKCdzaG93Jyk7XG4gICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ21vZGFsLW9wZW4nKTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGJhY2tkcm9wIG1hbnVhbGx5XG4gICAgICBjb25zdCBiYWNrZHJvcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgYmFja2Ryb3AuY2xhc3NOYW1lID0gJ21vZGFsLWJhY2tkcm9wIGZhZGUgc2hvdyc7XG4gICAgICBiYWNrZHJvcC5zdHlsZS56SW5kZXggPSAnMTA0MCc7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGJhY2tkcm9wKTtcbiAgICAgIFxuICAgICAgLy8gRW5zdXJlIG1vZGFsIGhhcyBwcm9wZXIgei1pbmRleFxuICAgICAgbW9kYWwuc3R5bGUuekluZGV4ID0gJzEwNTAnO1xuICAgIH1cbiAgfVxuXG4gIC8vIFB1YmxpYyBBUEkgZm9yIGNvbXBvbmVudHNcbiAgZ2V0QXNzZXNzbWVudERhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3BvbnNlczogdGhpcy5hc3Nlc3NtZW50UmVzcG9uc2VzLFxuICAgICAgc2NvcmVzOiB0aGlzLmFzc2Vzc21lbnRTY29yZXMsXG4gICAgICByZWNvbW1lbmRhdGlvbnM6IHRoaXMucmVjb21tZW5kYXRpb25zLFxuICAgIH07XG4gIH1cblxuICBnZXRQcm9jZXNzRGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzRGF0YTtcbiAgfVxuXG4gIGdldERlcGVuZGVuY3lEYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmRlcGVuZGVuY3lEYXRhO1xuICB9XG59XG5cbi8vIEluaXRpYWxpemUgYXBwbGljYXRpb24gd2hlbiBET00gaXMgbG9hZGVkXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCAoKSA9PiB7XG4gIGNvbnNvbGUubG9nKFwiRE9NIGxvYWRlZCwgaW5pdGlhbGl6aW5nIGFwcC4uLlwiKTtcblxuICAvLyBGYWlsc2FmZTogSGlkZSBsb2FkaW5nIHNjcmVlbiBhZnRlciAxMCBzZWNvbmRzIHJlZ2FyZGxlc3Mgb2Ygd2hhdCBoYXBwZW5zXG4gIGNvbnN0IGZhaWxzYWZlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGNvbnNvbGUud2FybihcIkZhaWxzYWZlIHRpbWVvdXQgcmVhY2hlZCAtIGhpZGluZyBsb2FkaW5nIHNjcmVlblwiKTtcbiAgICBmb3JjZUhpZGVMb2FkaW5nT3ZlcmxheSgpO1xuICB9LCAxMDAwMCk7XG5cbiAgLy8gV2FpdCBhIGJpdCB0byBlbnN1cmUgYWxsIHNjcmlwdHMgYXJlIGxvYWRlZFxuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gQ2hlY2sgaWYgYWxsIHJlcXVpcmVkIGNvbXBvbmVudHMgYXJlIGF2YWlsYWJsZVxuICAgICAgY29uc3QgcmVxdWlyZWRDb21wb25lbnRzID0gW1xuICAgICAgICBcIkFzc2Vzc21lbnRFbmdpbmVcIixcbiAgICAgICAgXCJQcm9jZXNzTmV0d29ya1Zpc3VhbGl6ZXJcIixcbiAgICAgICAgXCJSZWNvbW1lbmRhdGlvbkVuZ2luZVwiLFxuICAgICAgICBcIkV4cG9ydE1hbmFnZXJcIixcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IG1pc3NpbmdDb21wb25lbnRzID0gcmVxdWlyZWRDb21wb25lbnRzLmZpbHRlcihcbiAgICAgICAgKGNvbXApID0+IHR5cGVvZiB3aW5kb3dbY29tcF0gPT09IFwidW5kZWZpbmVkXCIsXG4gICAgICApO1xuXG4gICAgICBpZiAobWlzc2luZ0NvbXBvbmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiTWlzc2luZyBjb21wb25lbnRzOlwiLCBtaXNzaW5nQ29tcG9uZW50cyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgUmVxdWlyZWQgY29tcG9uZW50cyBub3QgbG9hZGVkOiAke21pc3NpbmdDb21wb25lbnRzLmpvaW4oXCIsIFwiKX1gLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhcIkFsbCBjb21wb25lbnRzIGF2YWlsYWJsZSwgaW5pdGlhbGl6aW5nIGFwcC4uLlwiKTtcbiAgICAgIHdpbmRvdy5zZUFwcCA9IG5ldyBTRUZyYW1ld29ya0FwcCgpO1xuXG4gICAgICAvLyBDbGVhciBmYWlsc2FmZSB0aW1lb3V0IGlmIGFwcCBpbml0aWFsaXplcyBzdWNjZXNzZnVsbHlcbiAgICAgIGNsZWFyVGltZW91dChmYWlsc2FmZVRpbWVvdXQpO1xuXG4gICAgICAvLyBBZGRpdGlvbmFsIGZhaWxzYWZlOiBGb3JjZSBoaWRlIGxvYWRpbmcgb3ZlcmxheSBhZnRlciBzdWNjZXNzZnVsIGluaXRpYWxpemF0aW9uXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coXCJBZGRpdGlvbmFsIGZhaWxzYWZlOiBGb3JjaW5nIGxvYWRpbmcgb3ZlcmxheSB0byBoaWRlXCIpO1xuICAgICAgICBmb3JjZUhpZGVMb2FkaW5nT3ZlcmxheSgpO1xuICAgICAgfSwgMTAwMCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gaW5pdGlhbGl6ZSBhcHA6XCIsIGVycm9yKTtcblxuICAgICAgLy8gQ2xlYXIgZmFpbHNhZmUgdGltZW91dCBzaW5jZSB3ZSdyZSBoYW5kbGluZyB0aGUgZXJyb3JcbiAgICAgIGNsZWFyVGltZW91dChmYWlsc2FmZVRpbWVvdXQpO1xuXG4gICAgICAvLyBTaG93IGVycm9yIHRvIHVzZXJcbiAgICAgIGNvbnN0IGxvYWRpbmdPdmVybGF5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsb2FkaW5nLW92ZXJsYXlcIik7XG4gICAgICBpZiAobG9hZGluZ092ZXJsYXkpIHtcbiAgICAgICAgbG9hZGluZ092ZXJsYXkuaW5uZXJIVE1MID0gYFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGV4dC1jZW50ZXIgdGV4dC13aGl0ZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInNwaW5uZXItYm9yZGVyIG1iLTNcIiByb2xlPVwic3RhdHVzXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ2aXN1YWxseS1oaWRkZW5cIj5Mb2FkaW5nLi4uPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cInRleHQtZGFuZ2VyXCI+RmFpbGVkIHRvIGluaXRpYWxpemUgYXBwbGljYXRpb248L3A+XG4gICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cInNtYWxsXCI+JHtlcnJvci5tZXNzYWdlfTwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtbGlnaHRcIiBvbmNsaWNrPVwid2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXCI+UmV0cnk8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgYDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIDEwMCk7IC8vIFNtYWxsIGRlbGF5IHRvIGVuc3VyZSBzY3JpcHRzIGFyZSBsb2FkZWRcbn0pO1xuXG4vLyBBZ2dyZXNzaXZlIGZ1bmN0aW9uIHRvIGhpZGUgbG9hZGluZyBvdmVybGF5XG5mdW5jdGlvbiBmb3JjZUhpZGVMb2FkaW5nT3ZlcmxheSgpIHtcbiAgY29uc29sZS5sb2coXCI9PT0gRm9yY2UgaGlkaW5nIGxvYWRpbmcgb3ZlcmxheSA9PT1cIik7XG5cbiAgLy8gVHJ5IG11bHRpcGxlIHNlbGVjdG9yc1xuICBjb25zdCBzZWxlY3RvcnMgPSBbXG4gICAgXCIjbG9hZGluZy1vdmVybGF5XCIsXG4gICAgXCIubG9hZGluZy1vdmVybGF5XCIsXG4gICAgJ1tpZCo9XCJsb2FkaW5nXCJdJyxcbiAgICBcIi5wb3NpdGlvbi1maXhlZC50b3AtMC5zdGFydC0wLnctMTAwLmgtMTAwXCIsXG4gIF07XG5cbiAgc2VsZWN0b3JzLmZvckVhY2goKHNlbGVjdG9yKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICBlbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBIaWRpbmcgZWxlbWVudCB3aXRoIHNlbGVjdG9yOiAke3NlbGVjdG9yfWApO1xuICAgICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gXCIwXCI7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJoaWRkZW5cIik7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiaGlkZGVuXCIsIFwiXCIpO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybihgRXJyb3IgaGlkaW5nIGVsZW1lbnRzIHdpdGggc2VsZWN0b3IgJHtzZWxlY3Rvcn06YCwgZXJyb3IpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gQWxzbyB0cnkgdG8gcmVtb3ZlIHRoZSBsb2FkaW5nIG92ZXJsYXkgY29tcGxldGVseVxuICB0cnkge1xuICAgIGNvbnN0IGxvYWRpbmdPdmVybGF5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsb2FkaW5nLW92ZXJsYXlcIik7XG4gICAgaWYgKGxvYWRpbmdPdmVybGF5ICYmIGxvYWRpbmdPdmVybGF5LnBhcmVudE5vZGUpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiUmVtb3ZpbmcgbG9hZGluZyBvdmVybGF5IGZyb20gRE9NXCIpO1xuICAgICAgbG9hZGluZ092ZXJsYXkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsb2FkaW5nT3ZlcmxheSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUud2FybihcIkVycm9yIHJlbW92aW5nIGxvYWRpbmcgb3ZlcmxheSBmcm9tIERPTTpcIiwgZXJyb3IpO1xuICB9XG5cbiAgY29uc29sZS5sb2coXCI9PT0gRm9yY2UgaGlkZSBjb21wbGV0ZSA9PT1cIik7XG59XG5cbi8vIEhhbmRsZSBicm93c2VyIGJhY2svZm9yd2FyZCBidXR0b25zXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsIChldmVudCkgPT4ge1xuICBpZiAod2luZG93LnNlQXBwICYmIGV2ZW50LnN0YXRlKSB7XG4gICAgd2luZG93LnNlQXBwLnNob3dWaWV3KGV2ZW50LnN0YXRlLnZpZXcpO1xuICB9XG59KTtcblxuLy8gRXhwb3J0IGZvciBnbG9iYWwgYWNjZXNzXG53aW5kb3cuU0VGcmFtZXdvcmtBcHAgPSBTRUZyYW1ld29ya0FwcDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./js/app.js\n\n}");

/***/ }),

/***/ "./js/components/assessment.js":
/*!*************************************!*\
  !*** ./js/components/assessment.js ***!
  \*************************************/
/***/ (() => {

eval("{/**\n * Assessment Engine Component\n * Manages the assessment interface, question rendering, and response collection\n */\n\nclass AssessmentEngine {\n  constructor(questionData, app) {\n    this.questionData = questionData;\n    this.app = app;\n    this.currentCategoryIndex = 0;\n    this.currentQuestionIndex = 0;\n    this.assessmentContainer = null;\n  }\n\n  render() {\n    this.assessmentContainer = document.getElementById('assessment-content');\n    if (!this.assessmentContainer) return;\n\n    this.renderAssessmentInterface();\n  }\n\n  renderAssessmentInterface() {\n    if (!this.questionData.assessmentCategories || this.questionData.assessmentCategories.length === 0) {\n      this.renderNoQuestions();\n      return;\n    }\n\n    // Clear container once at the beginning to prevent duplicate elements\n    this.assessmentContainer.innerHTML = '';\n    \n    this.renderProgressBar();\n    this.renderCurrentQuestion();\n    this.renderNavigation();\n  }\n\n  renderProgressBar() {\n    const progressContainer = document.createElement('div');\n    progressContainer.className = 'assessment-progress mb-4';\n\n    const totalQuestions = this.getTotalQuestions();\n    const answeredQuestions = Object.keys(this.app.assessmentResponses).length;\n    const progressPercentage = totalQuestions > 0 ? (answeredQuestions / totalQuestions) * 100 : 0;\n\n    progressContainer.innerHTML = `\n            <div class=\"d-flex justify-content-between align-items-center mb-2\">\n                <h6 class=\"mb-0\">Assessment Progress</h6>\n                <small class=\"text-muted\">${answeredQuestions}/${totalQuestions} questions answered</small>\n            </div>\n            <div class=\"progress\" style=\"height: 8px;\">\n                <div class=\"progress-bar\" role=\"progressbar\" \n                     style=\"width: ${progressPercentage}%\" \n                     aria-valuenow=\"${progressPercentage}\" \n                     aria-valuemin=\"0\" \n                     aria-valuemax=\"100\">\n                </div>\n            </div>\n            <div class=\"mt-2\">\n                <small class=\"text-muted\">\n                    ${this.getCurrentCategory()?.name || 'No category'} \n                    (${this.currentQuestionIndex + 1}/${this.getCurrentCategory()?.questions?.length || 0})\n                </small>\n            </div>\n        `;\n\n    this.assessmentContainer.appendChild(progressContainer);\n  }\n\n  renderCurrentQuestion() {\n    const question = this.getCurrentQuestion();\n    if (!question) {\n      this.renderAssessmentComplete();\n      return;\n    }\n\n    const questionCard = document.createElement('div');\n    questionCard.className = 'card question-card';\n    questionCard.innerHTML = `\n            <div class=\"card-header\">\n                <h5 class=\"card-title mb-0\">\n                    <span class=\"badge bg-primary me-2\">Q${this.currentQuestionIndex + 1}</span>\n                    ${question.text}\n                </h5>\n                <small class=\"text-muted\">${this.getDimensionBadge(question.dimension)}</small>\n            </div>\n            <div class=\"card-body\">\n                ${this.renderResponseOptions(question)}\n                ${question.description ? `<p class=\"text-muted mt-3\">${question.description}</p>` : ''}\n            </div>\n        `;\n\n    this.assessmentContainer.appendChild(questionCard);\n  }\n\n  renderResponseOptions(question) {\n    const currentResponse = this.app.assessmentResponses[question.id];\n    const currentValue = currentResponse ? currentResponse.score : null;\n\n    return `\n            <div class=\"response-options\">\n                <div class=\"btn-group-vertical w-100\" role=\"group\">\n                    ${question.options.map(option => `\n                        <button type=\"button\" \n                                class=\"btn btn-outline-primary ${currentValue === option.value ? 'active' : ''}\"\n                                data-score=\"${option.value}\"\n                                onclick=\"window.seApp.assessmentEngine.selectResponse(${option.value}, '${option.label}')\">\n                            ${option.label}\n                        </button>\n                    `).join('')}\n                </div>\n            </div>\n        `;\n  }\n\n  renderNavigation() {\n    // Clear any existing navigation elements first to prevent duplicates\n    const existingNav = this.assessmentContainer.querySelector('.assessment-navigation');\n    if (existingNav) {\n      existingNav.remove();\n    }\n    \n    const navContainer = document.createElement('div');\n    navContainer.className = 'assessment-navigation mt-4';\n    \n    // Check if current question has been answered\n    const currentQuestion = this.getCurrentQuestion();\n    const hasAnswered = currentQuestion && this.app.assessmentResponses[currentQuestion.id];\n    \n    navContainer.innerHTML = `\n            <div class=\"d-flex justify-content-between\">\n                <button class=\"btn btn-outline-secondary\" \n                        onclick=\"window.seApp.assessmentEngine.previousQuestion()\"\n                        ${this.currentQuestionIndex === 0 && this.currentCategoryIndex === 0 ? 'disabled' : ''}>\n                    <i class=\"bi bi-arrow-left\"></i> Previous\n                </button>\n                <button class=\"btn btn-primary\" \n                        onclick=\"window.seApp.assessmentEngine.nextQuestion()\"\n                        ${!hasAnswered ? 'disabled' : ''}>\n                    ${this.isLastQuestion() ? 'Complete Assessment' : 'Next Question'} \n                    <i class=\"bi bi-arrow-right\"></i>\n                </button>\n            </div>\n        `;\n\n    this.assessmentContainer.appendChild(navContainer);\n  }\n\n  renderNoQuestions() {\n    this.assessmentContainer.innerHTML = `\n            <div class=\"text-center py-5\">\n                <div class=\"card\">\n                    <div class=\"card-body\">\n                        <i class=\"bi bi-exclamation-triangle display-1 text-warning mb-3\"></i>\n                        <h3>No Assessment Questions</h3>\n                        <p class=\"text-muted\">\n                            The assessment questions could not be loaded. Please check the data files.\n                        </p>\n                    </div>\n                </div>\n            </div>\n        `;\n  }\n\n  renderAssessmentComplete() {\n    // Generate recommendations automatically when assessment is complete\n    this.app.calculateScores();\n    \n    this.assessmentContainer.innerHTML = `\n            <div class=\"text-center py-5\">\n                <div class=\"card\">\n                    <div class=\"card-body\">\n                        <i class=\"bi bi-check-circle display-1 text-success mb-3\"></i>\n                        <h3>Assessment Complete!</h3>\n                        <p class=\"text-muted mb-4\">\n                            You have completed all assessment questions. Your process tailoring recommendations are ready.\n                        </p>\n                        <div class=\"mb-4\">\n                            <h5>Assessment Scores</h5>\n                            <div class=\"row\">\n                                <div class=\"col-6 col-md-3\">\n                                    <div class=\"card bg-light\">\n                                        <div class=\"card-body text-center\">\n                                            <h6 class=\"card-title\">Overall</h6>\n                                            <h3 class=\"text-primary\">${this.app.assessmentScores.overall?.toFixed(1) || '0.0'}</h3>\n                                        </div>\n                                    </div>\n                                </div>\n                                <div class=\"col-6 col-md-3\">\n                                    <div class=\"card bg-light\">\n                                        <div class=\"card-body text-center\">\n                                            <h6 class=\"card-title\">Complexity</h6>\n                                            <h3 class=\"text-info\">${this.app.assessmentScores.complexity?.toFixed(1) || '0.0'}</h3>\n                                        </div>\n                                    </div>\n                                </div>\n                                <div class=\"col-6 col-md-3\">\n                                    <div class=\"card bg-light\">\n                                        <div class=\"card-body text-center\">\n                                            <h6 class=\"card-title\">Safety</h6>\n                                            <h3 class=\"text-warning\">${this.app.assessmentScores.safety?.toFixed(1) || '0.0'}</h3>\n                                        </div>\n                                    </div>\n                                </div>\n                                <div class=\"col-6 col-md-3\">\n                                    <div class=\"card bg-light\">\n                                        <div class=\"card-body text-center\">\n                                            <h6 class=\"card-title\">Scale</h6>\n                                            <h3 class=\"text-success\">${this.app.assessmentScores.scale?.toFixed(1) || '0.0'}</h3>\n                                        </div>\n                                    </div>\n                                </div>\n                            </div>\n                        </div>\n                        <button class=\"btn btn-primary btn-lg\" onclick=\"window.seApp.showView('recommendations')\">\n                            <i class=\"bi bi-graph-up\"></i>\n                            View Recommendations\n                        </button>\n                    </div>\n                </div>\n            </div>\n        `;\n  }\n\n  selectResponse(score, label) {\n    const question = this.getCurrentQuestion();\n    if (!question) return;\n\n    this.app.updateAssessmentResponse(question.id, {\n      score: score,\n      label: label,\n      dimension: question.dimension,\n    });\n\n    // Update UI to show selected response\n    this.updateResponseButtons(score);\n  }\n\n  updateResponseButtons(selectedScore) {\n    const buttons = this.assessmentContainer.querySelectorAll('.response-options button');\n    buttons.forEach(button => {\n      const score = parseInt(button.getAttribute('data-score'));\n      if (score === selectedScore) {\n        button.classList.add('active');\n      } else {\n        button.classList.remove('active');\n      }\n    });\n    \n    // Re-render navigation to enable Next button after response selection\n    this.renderNavigation();\n  }\n\n  nextQuestion() {\n    const currentCategory = this.getCurrentCategory();\n    if (!currentCategory) return;\n\n    // Move to next question in current category\n    this.currentQuestionIndex++;\n\n    // If we've reached the end of current category, move to next category\n    if (this.currentQuestionIndex >= currentCategory.questions.length) {\n      this.currentCategoryIndex++;\n      this.currentQuestionIndex = 0;\n\n      // If we've reached the end of all categories, show completion\n      if (this.currentCategoryIndex >= this.questionData.assessmentCategories.length) {\n        this.renderAssessmentComplete();\n        return;\n      }\n    }\n\n    this.renderAssessmentInterface();\n  }\n\n  previousQuestion() {\n    // Move to previous question\n    this.currentQuestionIndex--;\n\n    // If we've gone before the first question in current category\n    if (this.currentQuestionIndex < 0) {\n      this.currentCategoryIndex--;\n\n      // If we've gone before the first category, stay at first question\n      if (this.currentCategoryIndex < 0) {\n        this.currentCategoryIndex = 0;\n        this.currentQuestionIndex = 0;\n      } else {\n        // Move to last question of previous category\n        const prevCategory = this.questionData.assessmentCategories[this.currentCategoryIndex];\n        this.currentQuestionIndex = prevCategory.questions.length - 1;\n      }\n    }\n\n    this.renderAssessmentInterface();\n  }\n\n  getCurrentCategory() {\n    return this.questionData.assessmentCategories[this.currentCategoryIndex];\n  }\n\n  getCurrentQuestion() {\n    const category = this.getCurrentCategory();\n    return category?.questions?.[this.currentQuestionIndex];\n  }\n\n  getTotalQuestions() {\n    if (!this.questionData.assessmentCategories) return 0;\n    return this.questionData.assessmentCategories.reduce((total, category) => {\n      return total + (category.questions ? category.questions.length : 0);\n    }, 0);\n  }\n\n  isLastQuestion() {\n    const lastCategoryIndex = this.questionData.assessmentCategories.length - 1;\n    const lastCategory = this.questionData.assessmentCategories[lastCategoryIndex];\n    return this.currentCategoryIndex === lastCategoryIndex &&\n               this.currentQuestionIndex === lastCategory.questions.length - 1;\n  }\n\n  getDimensionBadge(dimension) {\n    const badgeClasses = {\n      complexity: 'bg-info',\n      safety: 'bg-warning',\n      scale: 'bg-success',\n      maturity: 'bg-secondary',\n    };\n\n    const dimensionLabels = {\n      complexity: 'Technical Complexity',\n      safety: 'Safety Criticality',\n      scale: 'Project Scale',\n      maturity: 'Organizational Maturity',\n    };\n\n    return `<span class=\"badge ${badgeClasses[dimension] || 'bg-secondary'}\">${dimensionLabels[dimension] || dimension}</span>`;\n  }\n\n  resetAssessment() {\n    this.currentCategoryIndex = 0;\n    this.currentQuestionIndex = 0;\n    this.renderAssessmentInterface();\n  }\n}\n\n// Export for global access\nwindow.AssessmentEngine = AssessmentEngine;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9jb21wb25lbnRzL2Fzc2Vzc21lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGtCQUFrQixHQUFHLGdCQUFnQjtBQUNqRjtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBLHFDQUFxQyxtQkFBbUI7QUFDeEQsc0NBQXNDLG1CQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsdUJBQXVCLDhCQUE4QixHQUFHLGtEQUFrRDtBQUMxRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCw4QkFBOEI7QUFDekYsc0JBQXNCO0FBQ3RCO0FBQ0EsNENBQTRDLDJDQUEyQztBQUN2RjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGtCQUFrQixxREFBcUQscUJBQXFCO0FBQzVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsaUVBQWlFLDhDQUE4QztBQUMvRyw4Q0FBOEMsYUFBYTtBQUMzRCx3RkFBd0YsYUFBYSxLQUFLLGFBQWE7QUFDdkgsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUZBQXFGO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtCQUErQjtBQUN6RCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSx1REFBdUQ7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsMERBQTBEO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLHNEQUFzRDtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxxREFBcUQ7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsMENBQTBDLElBQUksd0NBQXdDO0FBQ3ZIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2UtdGFpbG9yaW5nLWZyYW1ld29yay8uL2pzL2NvbXBvbmVudHMvYXNzZXNzbWVudC5qcz9iNGE3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQXNzZXNzbWVudCBFbmdpbmUgQ29tcG9uZW50XG4gKiBNYW5hZ2VzIHRoZSBhc3Nlc3NtZW50IGludGVyZmFjZSwgcXVlc3Rpb24gcmVuZGVyaW5nLCBhbmQgcmVzcG9uc2UgY29sbGVjdGlvblxuICovXG5cbmNsYXNzIEFzc2Vzc21lbnRFbmdpbmUge1xuICBjb25zdHJ1Y3RvcihxdWVzdGlvbkRhdGEsIGFwcCkge1xuICAgIHRoaXMucXVlc3Rpb25EYXRhID0gcXVlc3Rpb25EYXRhO1xuICAgIHRoaXMuYXBwID0gYXBwO1xuICAgIHRoaXMuY3VycmVudENhdGVnb3J5SW5kZXggPSAwO1xuICAgIHRoaXMuY3VycmVudFF1ZXN0aW9uSW5kZXggPSAwO1xuICAgIHRoaXMuYXNzZXNzbWVudENvbnRhaW5lciA9IG51bGw7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5hc3Nlc3NtZW50Q29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Fzc2Vzc21lbnQtY29udGVudCcpO1xuICAgIGlmICghdGhpcy5hc3Nlc3NtZW50Q29udGFpbmVyKSByZXR1cm47XG5cbiAgICB0aGlzLnJlbmRlckFzc2Vzc21lbnRJbnRlcmZhY2UoKTtcbiAgfVxuXG4gIHJlbmRlckFzc2Vzc21lbnRJbnRlcmZhY2UoKSB7XG4gICAgaWYgKCF0aGlzLnF1ZXN0aW9uRGF0YS5hc3Nlc3NtZW50Q2F0ZWdvcmllcyB8fCB0aGlzLnF1ZXN0aW9uRGF0YS5hc3Nlc3NtZW50Q2F0ZWdvcmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMucmVuZGVyTm9RdWVzdGlvbnMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDbGVhciBjb250YWluZXIgb25jZSBhdCB0aGUgYmVnaW5uaW5nIHRvIHByZXZlbnQgZHVwbGljYXRlIGVsZW1lbnRzXG4gICAgdGhpcy5hc3Nlc3NtZW50Q29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgIFxuICAgIHRoaXMucmVuZGVyUHJvZ3Jlc3NCYXIoKTtcbiAgICB0aGlzLnJlbmRlckN1cnJlbnRRdWVzdGlvbigpO1xuICAgIHRoaXMucmVuZGVyTmF2aWdhdGlvbigpO1xuICB9XG5cbiAgcmVuZGVyUHJvZ3Jlc3NCYXIoKSB7XG4gICAgY29uc3QgcHJvZ3Jlc3NDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBwcm9ncmVzc0NvbnRhaW5lci5jbGFzc05hbWUgPSAnYXNzZXNzbWVudC1wcm9ncmVzcyBtYi00JztcblxuICAgIGNvbnN0IHRvdGFsUXVlc3Rpb25zID0gdGhpcy5nZXRUb3RhbFF1ZXN0aW9ucygpO1xuICAgIGNvbnN0IGFuc3dlcmVkUXVlc3Rpb25zID0gT2JqZWN0LmtleXModGhpcy5hcHAuYXNzZXNzbWVudFJlc3BvbnNlcykubGVuZ3RoO1xuICAgIGNvbnN0IHByb2dyZXNzUGVyY2VudGFnZSA9IHRvdGFsUXVlc3Rpb25zID4gMCA/IChhbnN3ZXJlZFF1ZXN0aW9ucyAvIHRvdGFsUXVlc3Rpb25zKSAqIDEwMCA6IDA7XG5cbiAgICBwcm9ncmVzc0NvbnRhaW5lci5pbm5lckhUTUwgPSBgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZC1mbGV4IGp1c3RpZnktY29udGVudC1iZXR3ZWVuIGFsaWduLWl0ZW1zLWNlbnRlciBtYi0yXCI+XG4gICAgICAgICAgICAgICAgPGg2IGNsYXNzPVwibWItMFwiPkFzc2Vzc21lbnQgUHJvZ3Jlc3M8L2g2PlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cInRleHQtbXV0ZWRcIj4ke2Fuc3dlcmVkUXVlc3Rpb25zfS8ke3RvdGFsUXVlc3Rpb25zfSBxdWVzdGlvbnMgYW5zd2VyZWQ8L3NtYWxsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwicHJvZ3Jlc3NcIiBzdHlsZT1cImhlaWdodDogOHB4O1wiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwcm9ncmVzcy1iYXJcIiByb2xlPVwicHJvZ3Jlc3NiYXJcIiBcbiAgICAgICAgICAgICAgICAgICAgIHN0eWxlPVwid2lkdGg6ICR7cHJvZ3Jlc3NQZXJjZW50YWdlfSVcIiBcbiAgICAgICAgICAgICAgICAgICAgIGFyaWEtdmFsdWVub3c9XCIke3Byb2dyZXNzUGVyY2VudGFnZX1cIiBcbiAgICAgICAgICAgICAgICAgICAgIGFyaWEtdmFsdWVtaW49XCIwXCIgXG4gICAgICAgICAgICAgICAgICAgICBhcmlhLXZhbHVlbWF4PVwiMTAwXCI+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtdC0yXCI+XG4gICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwidGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICAke3RoaXMuZ2V0Q3VycmVudENhdGVnb3J5KCk/Lm5hbWUgfHwgJ05vIGNhdGVnb3J5J30gXG4gICAgICAgICAgICAgICAgICAgICgke3RoaXMuY3VycmVudFF1ZXN0aW9uSW5kZXggKyAxfS8ke3RoaXMuZ2V0Q3VycmVudENhdGVnb3J5KCk/LnF1ZXN0aW9ucz8ubGVuZ3RoIHx8IDB9KVxuICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgYDtcblxuICAgIHRoaXMuYXNzZXNzbWVudENvbnRhaW5lci5hcHBlbmRDaGlsZChwcm9ncmVzc0NvbnRhaW5lcik7XG4gIH1cblxuICByZW5kZXJDdXJyZW50UXVlc3Rpb24oKSB7XG4gICAgY29uc3QgcXVlc3Rpb24gPSB0aGlzLmdldEN1cnJlbnRRdWVzdGlvbigpO1xuICAgIGlmICghcXVlc3Rpb24pIHtcbiAgICAgIHRoaXMucmVuZGVyQXNzZXNzbWVudENvbXBsZXRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcXVlc3Rpb25DYXJkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcXVlc3Rpb25DYXJkLmNsYXNzTmFtZSA9ICdjYXJkIHF1ZXN0aW9uLWNhcmQnO1xuICAgIHF1ZXN0aW9uQ2FyZC5pbm5lckhUTUwgPSBgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZC1oZWFkZXJcIj5cbiAgICAgICAgICAgICAgICA8aDUgY2xhc3M9XCJjYXJkLXRpdGxlIG1iLTBcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJiYWRnZSBiZy1wcmltYXJ5IG1lLTJcIj5RJHt0aGlzLmN1cnJlbnRRdWVzdGlvbkluZGV4ICsgMX08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICR7cXVlc3Rpb24udGV4dH1cbiAgICAgICAgICAgICAgICA8L2g1PlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cInRleHQtbXV0ZWRcIj4ke3RoaXMuZ2V0RGltZW5zaW9uQmFkZ2UocXVlc3Rpb24uZGltZW5zaW9uKX08L3NtYWxsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZC1ib2R5XCI+XG4gICAgICAgICAgICAgICAgJHt0aGlzLnJlbmRlclJlc3BvbnNlT3B0aW9ucyhxdWVzdGlvbil9XG4gICAgICAgICAgICAgICAgJHtxdWVzdGlvbi5kZXNjcmlwdGlvbiA/IGA8cCBjbGFzcz1cInRleHQtbXV0ZWQgbXQtM1wiPiR7cXVlc3Rpb24uZGVzY3JpcHRpb259PC9wPmAgOiAnJ31cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICBgO1xuXG4gICAgdGhpcy5hc3Nlc3NtZW50Q29udGFpbmVyLmFwcGVuZENoaWxkKHF1ZXN0aW9uQ2FyZCk7XG4gIH1cblxuICByZW5kZXJSZXNwb25zZU9wdGlvbnMocXVlc3Rpb24pIHtcbiAgICBjb25zdCBjdXJyZW50UmVzcG9uc2UgPSB0aGlzLmFwcC5hc3Nlc3NtZW50UmVzcG9uc2VzW3F1ZXN0aW9uLmlkXTtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBjdXJyZW50UmVzcG9uc2UgPyBjdXJyZW50UmVzcG9uc2Uuc2NvcmUgOiBudWxsO1xuXG4gICAgcmV0dXJuIGBcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyZXNwb25zZS1vcHRpb25zXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cC12ZXJ0aWNhbCB3LTEwMFwiIHJvbGU9XCJncm91cFwiPlxuICAgICAgICAgICAgICAgICAgICAke3F1ZXN0aW9uLm9wdGlvbnMubWFwKG9wdGlvbiA9PiBgXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtcHJpbWFyeSAke2N1cnJlbnRWYWx1ZSA9PT0gb3B0aW9uLnZhbHVlID8gJ2FjdGl2ZScgOiAnJ31cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLXNjb3JlPVwiJHtvcHRpb24udmFsdWV9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25jbGljaz1cIndpbmRvdy5zZUFwcC5hc3Nlc3NtZW50RW5naW5lLnNlbGVjdFJlc3BvbnNlKCR7b3B0aW9uLnZhbHVlfSwgJyR7b3B0aW9uLmxhYmVsfScpXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtvcHRpb24ubGFiZWx9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgYCkuam9pbignJyl9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgYDtcbiAgfVxuXG4gIHJlbmRlck5hdmlnYXRpb24oKSB7XG4gICAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIG5hdmlnYXRpb24gZWxlbWVudHMgZmlyc3QgdG8gcHJldmVudCBkdXBsaWNhdGVzXG4gICAgY29uc3QgZXhpc3RpbmdOYXYgPSB0aGlzLmFzc2Vzc21lbnRDb250YWluZXIucXVlcnlTZWxlY3RvcignLmFzc2Vzc21lbnQtbmF2aWdhdGlvbicpO1xuICAgIGlmIChleGlzdGluZ05hdikge1xuICAgICAgZXhpc3RpbmdOYXYucmVtb3ZlKCk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IG5hdkNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIG5hdkNvbnRhaW5lci5jbGFzc05hbWUgPSAnYXNzZXNzbWVudC1uYXZpZ2F0aW9uIG10LTQnO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIGN1cnJlbnQgcXVlc3Rpb24gaGFzIGJlZW4gYW5zd2VyZWRcbiAgICBjb25zdCBjdXJyZW50UXVlc3Rpb24gPSB0aGlzLmdldEN1cnJlbnRRdWVzdGlvbigpO1xuICAgIGNvbnN0IGhhc0Fuc3dlcmVkID0gY3VycmVudFF1ZXN0aW9uICYmIHRoaXMuYXBwLmFzc2Vzc21lbnRSZXNwb25zZXNbY3VycmVudFF1ZXN0aW9uLmlkXTtcbiAgICBcbiAgICBuYXZDb250YWluZXIuaW5uZXJIVE1MID0gYFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImQtZmxleCBqdXN0aWZ5LWNvbnRlbnQtYmV0d2VlblwiPlxuICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5XCIgXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmNsaWNrPVwid2luZG93LnNlQXBwLmFzc2Vzc21lbnRFbmdpbmUucHJldmlvdXNRdWVzdGlvbigpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICR7dGhpcy5jdXJyZW50UXVlc3Rpb25JbmRleCA9PT0gMCAmJiB0aGlzLmN1cnJlbnRDYXRlZ29yeUluZGV4ID09PSAwID8gJ2Rpc2FibGVkJyA6ICcnfT5cbiAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJiaSBiaS1hcnJvdy1sZWZ0XCI+PC9pPiBQcmV2aW91c1xuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLXByaW1hcnlcIiBcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2xpY2s9XCJ3aW5kb3cuc2VBcHAuYXNzZXNzbWVudEVuZ2luZS5uZXh0UXVlc3Rpb24oKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAkeyFoYXNBbnN3ZXJlZCA/ICdkaXNhYmxlZCcgOiAnJ30+XG4gICAgICAgICAgICAgICAgICAgICR7dGhpcy5pc0xhc3RRdWVzdGlvbigpID8gJ0NvbXBsZXRlIEFzc2Vzc21lbnQnIDogJ05leHQgUXVlc3Rpb24nfSBcbiAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJiaSBiaS1hcnJvdy1yaWdodFwiPjwvaT5cbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICBgO1xuXG4gICAgdGhpcy5hc3Nlc3NtZW50Q29udGFpbmVyLmFwcGVuZENoaWxkKG5hdkNvbnRhaW5lcik7XG4gIH1cblxuICByZW5kZXJOb1F1ZXN0aW9ucygpIHtcbiAgICB0aGlzLmFzc2Vzc21lbnRDb250YWluZXIuaW5uZXJIVE1MID0gYFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRleHQtY2VudGVyIHB5LTVcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZFwiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZC1ib2R5XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImJpIGJpLWV4Y2xhbWF0aW9uLXRyaWFuZ2xlIGRpc3BsYXktMSB0ZXh0LXdhcm5pbmcgbWItM1wiPjwvaT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxoMz5ObyBBc3Nlc3NtZW50IFF1ZXN0aW9uczwvaDM+XG4gICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cInRleHQtbXV0ZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgYXNzZXNzbWVudCBxdWVzdGlvbnMgY291bGQgbm90IGJlIGxvYWRlZC4gUGxlYXNlIGNoZWNrIHRoZSBkYXRhIGZpbGVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICBgO1xuICB9XG5cbiAgcmVuZGVyQXNzZXNzbWVudENvbXBsZXRlKCkge1xuICAgIC8vIEdlbmVyYXRlIHJlY29tbWVuZGF0aW9ucyBhdXRvbWF0aWNhbGx5IHdoZW4gYXNzZXNzbWVudCBpcyBjb21wbGV0ZVxuICAgIHRoaXMuYXBwLmNhbGN1bGF0ZVNjb3JlcygpO1xuICAgIFxuICAgIHRoaXMuYXNzZXNzbWVudENvbnRhaW5lci5pbm5lckhUTUwgPSBgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGV4dC1jZW50ZXIgcHktNVwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYXJkXCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYXJkLWJvZHlcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiYmkgYmktY2hlY2stY2lyY2xlIGRpc3BsYXktMSB0ZXh0LXN1Y2Nlc3MgbWItM1wiPjwvaT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxoMz5Bc3Nlc3NtZW50IENvbXBsZXRlITwvaDM+XG4gICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cInRleHQtbXV0ZWQgbWItNFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFlvdSBoYXZlIGNvbXBsZXRlZCBhbGwgYXNzZXNzbWVudCBxdWVzdGlvbnMuIFlvdXIgcHJvY2VzcyB0YWlsb3JpbmcgcmVjb21tZW5kYXRpb25zIGFyZSByZWFkeS5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtYi00XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGg1PkFzc2Vzc21lbnQgU2NvcmVzPC9oNT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtNiBjb2wtbWQtM1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhcmQgYmctbGlnaHRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZC1ib2R5IHRleHQtY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoNiBjbGFzcz1cImNhcmQtdGl0bGVcIj5PdmVyYWxsPC9oNj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGgzIGNsYXNzPVwidGV4dC1wcmltYXJ5XCI+JHt0aGlzLmFwcC5hc3Nlc3NtZW50U2NvcmVzLm92ZXJhbGw/LnRvRml4ZWQoMSkgfHwgJzAuMCd9PC9oMz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC02IGNvbC1tZC0zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZCBiZy1saWdodFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYXJkLWJvZHkgdGV4dC1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGg2IGNsYXNzPVwiY2FyZC10aXRsZVwiPkNvbXBsZXhpdHk8L2g2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDMgY2xhc3M9XCJ0ZXh0LWluZm9cIj4ke3RoaXMuYXBwLmFzc2Vzc21lbnRTY29yZXMuY29tcGxleGl0eT8udG9GaXhlZCgxKSB8fCAnMC4wJ308L2gzPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLTYgY29sLW1kLTNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYXJkIGJnLWxpZ2h0XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhcmQtYm9keSB0ZXh0LWNlbnRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDYgY2xhc3M9XCJjYXJkLXRpdGxlXCI+U2FmZXR5PC9oNj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGgzIGNsYXNzPVwidGV4dC13YXJuaW5nXCI+JHt0aGlzLmFwcC5hc3Nlc3NtZW50U2NvcmVzLnNhZmV0eT8udG9GaXhlZCgxKSB8fCAnMC4wJ308L2gzPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLTYgY29sLW1kLTNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYXJkIGJnLWxpZ2h0XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhcmQtYm9keSB0ZXh0LWNlbnRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDYgY2xhc3M9XCJjYXJkLXRpdGxlXCI+U2NhbGU8L2g2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDMgY2xhc3M9XCJ0ZXh0LXN1Y2Nlc3NcIj4ke3RoaXMuYXBwLmFzc2Vzc21lbnRTY29yZXMuc2NhbGU/LnRvRml4ZWQoMSkgfHwgJzAuMCd9PC9oMz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeSBidG4tbGdcIiBvbmNsaWNrPVwid2luZG93LnNlQXBwLnNob3dWaWV3KCdyZWNvbW1lbmRhdGlvbnMnKVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiYmkgYmktZ3JhcGgtdXBcIj48L2k+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVmlldyBSZWNvbW1lbmRhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICBgO1xuICB9XG5cbiAgc2VsZWN0UmVzcG9uc2Uoc2NvcmUsIGxhYmVsKSB7XG4gICAgY29uc3QgcXVlc3Rpb24gPSB0aGlzLmdldEN1cnJlbnRRdWVzdGlvbigpO1xuICAgIGlmICghcXVlc3Rpb24pIHJldHVybjtcblxuICAgIHRoaXMuYXBwLnVwZGF0ZUFzc2Vzc21lbnRSZXNwb25zZShxdWVzdGlvbi5pZCwge1xuICAgICAgc2NvcmU6IHNjb3JlLFxuICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgZGltZW5zaW9uOiBxdWVzdGlvbi5kaW1lbnNpb24sXG4gICAgfSk7XG5cbiAgICAvLyBVcGRhdGUgVUkgdG8gc2hvdyBzZWxlY3RlZCByZXNwb25zZVxuICAgIHRoaXMudXBkYXRlUmVzcG9uc2VCdXR0b25zKHNjb3JlKTtcbiAgfVxuXG4gIHVwZGF0ZVJlc3BvbnNlQnV0dG9ucyhzZWxlY3RlZFNjb3JlKSB7XG4gICAgY29uc3QgYnV0dG9ucyA9IHRoaXMuYXNzZXNzbWVudENvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCcucmVzcG9uc2Utb3B0aW9ucyBidXR0b24nKTtcbiAgICBidXR0b25zLmZvckVhY2goYnV0dG9uID0+IHtcbiAgICAgIGNvbnN0IHNjb3JlID0gcGFyc2VJbnQoYnV0dG9uLmdldEF0dHJpYnV0ZSgnZGF0YS1zY29yZScpKTtcbiAgICAgIGlmIChzY29yZSA9PT0gc2VsZWN0ZWRTY29yZSkge1xuICAgICAgICBidXR0b24uY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidXR0b24uY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gUmUtcmVuZGVyIG5hdmlnYXRpb24gdG8gZW5hYmxlIE5leHQgYnV0dG9uIGFmdGVyIHJlc3BvbnNlIHNlbGVjdGlvblxuICAgIHRoaXMucmVuZGVyTmF2aWdhdGlvbigpO1xuICB9XG5cbiAgbmV4dFF1ZXN0aW9uKCkge1xuICAgIGNvbnN0IGN1cnJlbnRDYXRlZ29yeSA9IHRoaXMuZ2V0Q3VycmVudENhdGVnb3J5KCk7XG4gICAgaWYgKCFjdXJyZW50Q2F0ZWdvcnkpIHJldHVybjtcblxuICAgIC8vIE1vdmUgdG8gbmV4dCBxdWVzdGlvbiBpbiBjdXJyZW50IGNhdGVnb3J5XG4gICAgdGhpcy5jdXJyZW50UXVlc3Rpb25JbmRleCsrO1xuXG4gICAgLy8gSWYgd2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIGN1cnJlbnQgY2F0ZWdvcnksIG1vdmUgdG8gbmV4dCBjYXRlZ29yeVxuICAgIGlmICh0aGlzLmN1cnJlbnRRdWVzdGlvbkluZGV4ID49IGN1cnJlbnRDYXRlZ29yeS5xdWVzdGlvbnMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmN1cnJlbnRDYXRlZ29yeUluZGV4Kys7XG4gICAgICB0aGlzLmN1cnJlbnRRdWVzdGlvbkluZGV4ID0gMDtcblxuICAgICAgLy8gSWYgd2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIGFsbCBjYXRlZ29yaWVzLCBzaG93IGNvbXBsZXRpb25cbiAgICAgIGlmICh0aGlzLmN1cnJlbnRDYXRlZ29yeUluZGV4ID49IHRoaXMucXVlc3Rpb25EYXRhLmFzc2Vzc21lbnRDYXRlZ29yaWVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnJlbmRlckFzc2Vzc21lbnRDb21wbGV0ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJBc3Nlc3NtZW50SW50ZXJmYWNlKCk7XG4gIH1cblxuICBwcmV2aW91c1F1ZXN0aW9uKCkge1xuICAgIC8vIE1vdmUgdG8gcHJldmlvdXMgcXVlc3Rpb25cbiAgICB0aGlzLmN1cnJlbnRRdWVzdGlvbkluZGV4LS07XG5cbiAgICAvLyBJZiB3ZSd2ZSBnb25lIGJlZm9yZSB0aGUgZmlyc3QgcXVlc3Rpb24gaW4gY3VycmVudCBjYXRlZ29yeVxuICAgIGlmICh0aGlzLmN1cnJlbnRRdWVzdGlvbkluZGV4IDwgMCkge1xuICAgICAgdGhpcy5jdXJyZW50Q2F0ZWdvcnlJbmRleC0tO1xuXG4gICAgICAvLyBJZiB3ZSd2ZSBnb25lIGJlZm9yZSB0aGUgZmlyc3QgY2F0ZWdvcnksIHN0YXkgYXQgZmlyc3QgcXVlc3Rpb25cbiAgICAgIGlmICh0aGlzLmN1cnJlbnRDYXRlZ29yeUluZGV4IDwgMCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRDYXRlZ29yeUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5jdXJyZW50UXVlc3Rpb25JbmRleCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNb3ZlIHRvIGxhc3QgcXVlc3Rpb24gb2YgcHJldmlvdXMgY2F0ZWdvcnlcbiAgICAgICAgY29uc3QgcHJldkNhdGVnb3J5ID0gdGhpcy5xdWVzdGlvbkRhdGEuYXNzZXNzbWVudENhdGVnb3JpZXNbdGhpcy5jdXJyZW50Q2F0ZWdvcnlJbmRleF07XG4gICAgICAgIHRoaXMuY3VycmVudFF1ZXN0aW9uSW5kZXggPSBwcmV2Q2F0ZWdvcnkucXVlc3Rpb25zLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJBc3Nlc3NtZW50SW50ZXJmYWNlKCk7XG4gIH1cblxuICBnZXRDdXJyZW50Q2F0ZWdvcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlc3Rpb25EYXRhLmFzc2Vzc21lbnRDYXRlZ29yaWVzW3RoaXMuY3VycmVudENhdGVnb3J5SW5kZXhdO1xuICB9XG5cbiAgZ2V0Q3VycmVudFF1ZXN0aW9uKCkge1xuICAgIGNvbnN0IGNhdGVnb3J5ID0gdGhpcy5nZXRDdXJyZW50Q2F0ZWdvcnkoKTtcbiAgICByZXR1cm4gY2F0ZWdvcnk/LnF1ZXN0aW9ucz8uW3RoaXMuY3VycmVudFF1ZXN0aW9uSW5kZXhdO1xuICB9XG5cbiAgZ2V0VG90YWxRdWVzdGlvbnMoKSB7XG4gICAgaWYgKCF0aGlzLnF1ZXN0aW9uRGF0YS5hc3Nlc3NtZW50Q2F0ZWdvcmllcykgcmV0dXJuIDA7XG4gICAgcmV0dXJuIHRoaXMucXVlc3Rpb25EYXRhLmFzc2Vzc21lbnRDYXRlZ29yaWVzLnJlZHVjZSgodG90YWwsIGNhdGVnb3J5KSA9PiB7XG4gICAgICByZXR1cm4gdG90YWwgKyAoY2F0ZWdvcnkucXVlc3Rpb25zID8gY2F0ZWdvcnkucXVlc3Rpb25zLmxlbmd0aCA6IDApO1xuICAgIH0sIDApO1xuICB9XG5cbiAgaXNMYXN0UXVlc3Rpb24oKSB7XG4gICAgY29uc3QgbGFzdENhdGVnb3J5SW5kZXggPSB0aGlzLnF1ZXN0aW9uRGF0YS5hc3Nlc3NtZW50Q2F0ZWdvcmllcy5sZW5ndGggLSAxO1xuICAgIGNvbnN0IGxhc3RDYXRlZ29yeSA9IHRoaXMucXVlc3Rpb25EYXRhLmFzc2Vzc21lbnRDYXRlZ29yaWVzW2xhc3RDYXRlZ29yeUluZGV4XTtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50Q2F0ZWdvcnlJbmRleCA9PT0gbGFzdENhdGVnb3J5SW5kZXggJiZcbiAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFF1ZXN0aW9uSW5kZXggPT09IGxhc3RDYXRlZ29yeS5xdWVzdGlvbnMubGVuZ3RoIC0gMTtcbiAgfVxuXG4gIGdldERpbWVuc2lvbkJhZGdlKGRpbWVuc2lvbikge1xuICAgIGNvbnN0IGJhZGdlQ2xhc3NlcyA9IHtcbiAgICAgIGNvbXBsZXhpdHk6ICdiZy1pbmZvJyxcbiAgICAgIHNhZmV0eTogJ2JnLXdhcm5pbmcnLFxuICAgICAgc2NhbGU6ICdiZy1zdWNjZXNzJyxcbiAgICAgIG1hdHVyaXR5OiAnYmctc2Vjb25kYXJ5JyxcbiAgICB9O1xuXG4gICAgY29uc3QgZGltZW5zaW9uTGFiZWxzID0ge1xuICAgICAgY29tcGxleGl0eTogJ1RlY2huaWNhbCBDb21wbGV4aXR5JyxcbiAgICAgIHNhZmV0eTogJ1NhZmV0eSBDcml0aWNhbGl0eScsXG4gICAgICBzY2FsZTogJ1Byb2plY3QgU2NhbGUnLFxuICAgICAgbWF0dXJpdHk6ICdPcmdhbml6YXRpb25hbCBNYXR1cml0eScsXG4gICAgfTtcblxuICAgIHJldHVybiBgPHNwYW4gY2xhc3M9XCJiYWRnZSAke2JhZGdlQ2xhc3Nlc1tkaW1lbnNpb25dIHx8ICdiZy1zZWNvbmRhcnknfVwiPiR7ZGltZW5zaW9uTGFiZWxzW2RpbWVuc2lvbl0gfHwgZGltZW5zaW9ufTwvc3Bhbj5gO1xuICB9XG5cbiAgcmVzZXRBc3Nlc3NtZW50KCkge1xuICAgIHRoaXMuY3VycmVudENhdGVnb3J5SW5kZXggPSAwO1xuICAgIHRoaXMuY3VycmVudFF1ZXN0aW9uSW5kZXggPSAwO1xuICAgIHRoaXMucmVuZGVyQXNzZXNzbWVudEludGVyZmFjZSgpO1xuICB9XG59XG5cbi8vIEV4cG9ydCBmb3IgZ2xvYmFsIGFjY2Vzc1xud2luZG93LkFzc2Vzc21lbnRFbmdpbmUgPSBBc3Nlc3NtZW50RW5naW5lO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./js/components/assessment.js\n\n}");

/***/ }),

/***/ "./js/components/export.js":
/*!*********************************!*\
  !*** ./js/components/export.js ***!
  \*********************************/
/***/ (() => {

eval("{/**\n * Export Manager Component\n * Handles PDF reports, JSON configuration, and Excel analytics export\n */\n\nclass ExportManager {\n  constructor(app) {\n    this.app = app;\n  }\n\n  render() {\n    const container = document.getElementById('export-content');\n    if (!container) return;\n\n    const assessmentData = this.app.getAssessmentData();\n    const hasData = assessmentData.recommendations && Object.keys(assessmentData.recommendations).length > 0;\n\n    if (!hasData) {\n      this.renderNoData(container);\n      return;\n    }\n\n    this.renderExportOptions(container, assessmentData);\n  }\n\n  renderNoData(container) {\n    container.innerHTML = `\n            <div class=\"text-center py-5\">\n                <div class=\"card\">\n                    <div class=\"card-body\">\n                        <i class=\"bi bi-exclamation-circle display-1 text-warning mb-3\"></i>\n                        <h3>No Data to Export</h3>\n                        <p class=\"text-muted mb-4\">\n                            Complete the assessment first to generate exportable recommendations and reports.\n                        </p>\n                        <button class=\"btn btn-primary\" onclick=\"window.seApp.showView('assessment')\">\n                            <i class=\"bi bi-clipboard-check\"></i>\n                            Start Assessment\n                        </button>\n                    </div>\n                </div>\n            </div>\n        `;\n  }\n\n  renderExportOptions(container, assessmentData) {\n    const stats = this.calculateExportStats(assessmentData);\n\n    container.innerHTML = `\n            <div class=\"card shadow-sm mb-4\">\n                <div class=\"card-header bg-gradient-primary text-white\">\n                    <h4 class=\"card-title mb-0\">\n                        <i class=\"bi bi-download\"></i>\n                        Export Reports & Data\n                    </h4>\n                </div>\n                <div class=\"card-body\">\n                    <div class=\"alert alert-info\">\n                        <i class=\"bi bi-info-circle me-2\"></i>\n                        <strong>Ready to Export:</strong> Your assessment contains ${stats.totalProcesses} process recommendations \n                        with ${stats.totalQuestions} assessment responses across ${stats.categories} categories.\n                    </div>\n                    \n                    <div class=\"row mb-4\">\n                        <div class=\"col-md-3 text-center\">\n                            <div class=\"stat-card\">\n                                <span class=\"stat-number text-primary\">${stats.totalProcesses}</span>\n                                <span class=\"stat-label\">Process Recommendations</span>\n                            </div>\n                        </div>\n                        <div class=\"col-md-3 text-center\">\n                            <div class=\"stat-card\">\n                                <span class=\"stat-number text-success\">${stats.averageConfidence}%</span>\n                                <span class=\"stat-label\">Average Confidence</span>\n                            </div>\n                        </div>\n                        <div class=\"col-md-3 text-center\">\n                            <div class=\"stat-card\">\n                                <span class=\"stat-number text-warning\">${stats.totalEffort}</span>\n                                <span class=\"stat-label\">Total Effort Score</span>\n                            </div>\n                        </div>\n                        <div class=\"col-md-3 text-center\">\n                            <div class=\"stat-card\">\n                                <span class=\"stat-number text-info\">${stats.dependencies}</span>\n                                <span class=\"stat-label\">Dependencies</span>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n            </div>\n\n            <div class=\"row\">\n                <div class=\"col-lg-4 mb-4\">\n                    <div class=\"export-option\" data-export-type=\"pdf\">\n                        <div class=\"export-icon\">\n                            <i class=\"bi bi-file-earmark-pdf-fill\"></i>\n                        </div>\n                        <h5 class=\"export-title\">Professional PDF Report</h5>\n                        <p class=\"export-description\">\n                            Comprehensive report with executive summary, detailed recommendations, \n                            process network visualization, and implementation roadmap.\n                        </p>\n                        <button class=\"btn btn-primary\" id=\"export-pdf-btn\">\n                            <i class=\"bi bi-download\"></i>\n                            Download PDF\n                        </button>\n                    </div>\n                </div>\n                \n                <div class=\"col-lg-4 mb-4\">\n                    <div class=\"export-option\" data-export-type=\"json\">\n                        <div class=\"export-icon\">\n                            <i class=\"bi bi-file-earmark-code-fill\"></i>\n                        </div>\n                        <h5 class=\"export-title\">JSON Configuration</h5>\n                        <p class=\"export-description\">\n                            Machine-readable format containing assessment data, scores, and recommendations \n                            for integration with other tools and systems.\n                        </p>\n                        <button class=\"btn btn-outline-primary\" id=\"export-json-btn\">\n                            <i class=\"bi bi-download\"></i>\n                            Download JSON\n                        </button>\n                    </div>\n                </div>\n                \n                <div class=\"col-lg-4 mb-4\">\n                    <div class=\"export-option\" data-export-type=\"excel\">\n                        <div class=\"export-icon\">\n                            <i class=\"bi bi-file-earmark-spreadsheet-fill\"></i>\n                        </div>\n                        <h5 class=\"export-title\">Excel Analytics</h5>\n                        <p class=\"export-description\">\n                            Spreadsheet format with assessment responses, process recommendations, \n                            effort calculations, and pivot tables for further analysis.\n                        </p>\n                        <button class=\"btn btn-outline-success\" id=\"export-excel-btn\">\n                            <i class=\"bi bi-download\"></i>\n                            Download Excel\n                        </button>\n                    </div>\n                </div>\n            </div>\n\n            <div class=\"card\">\n                <div class=\"card-header\">\n                    <h6 class=\"card-title mb-0\">\n                        <i class=\"bi bi-gear\"></i>\n                        Export Options\n                    </h6>\n                </div>\n                <div class=\"card-body\">\n                    <div class=\"row\">\n                        <div class=\"col-md-6\">\n                            <div class=\"form-check\">\n                                <input class=\"form-check-input\" type=\"checkbox\" id=\"include-assessment-details\" checked>\n                                <label class=\"form-check-label\" for=\"include-assessment-details\">\n                                    Include detailed assessment responses\n                                </label>\n                            </div>\n                            <div class=\"form-check\">\n                                <input class=\"form-check-input\" type=\"checkbox\" id=\"include-rationale\" checked>\n                                <label class=\"form-check-label\" for=\"include-rationale\">\n                                    Include recommendation rationale\n                                </label>\n                            </div>\n                            <div class=\"form-check\">\n                                <input class=\"form-check-input\" type=\"checkbox\" id=\"include-dependencies\" checked>\n                                <label class=\"form-check-label\" for=\"include-dependencies\">\n                                    Include process dependencies\n                                </label>\n                            </div>\n                        </div>\n                        <div class=\"col-md-6\">\n                            <div class=\"form-check\">\n                                <input class=\"form-check-input\" type=\"checkbox\" id=\"include-visualization\" checked>\n                                <label class=\"form-check-label\" for=\"include-visualization\">\n                                    Include process network visualization\n                                </label>\n                            </div>\n                            <div class=\"form-check\">\n                                <input class=\"form-check-input\" type=\"checkbox\" id=\"include-metadata\" checked>\n                                <label class=\"form-check-label\" for=\"include-metadata\">\n                                    Include metadata and timestamps\n                                </label>\n                            </div>\n                            <div class=\"form-check\">\n                                <input class=\"form-check-input\" type=\"checkbox\" id=\"include-implementation-guide\">\n                                <label class=\"form-check-label\" for=\"include-implementation-guide\">\n                                    Include implementation guidance\n                                </label>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n            </div>\n\n            <div class=\"mt-4 text-center\">\n                <small class=\"text-muted\">\n                    <i class=\"bi bi-shield-check\"></i>\n                    All exports are generated locally in your browser. No data is sent to external servers.\n                </small>\n            </div>\n        `;\n\n    this.attachExportEventListeners();\n  }\n\n  calculateExportStats(assessmentData) {\n    const recommendations = assessmentData.recommendations || {};\n    const responses = assessmentData.responses || {};\n\n    const totalProcesses = Object.keys(recommendations).length;\n    const totalQuestions = Object.keys(responses).length;\n    const categories = new Set(Object.values(responses).map(r => r.dimension)).size;\n\n    const confidenceValues = Object.values(recommendations).map(r => r.confidence || 0);\n    const averageConfidence = confidenceValues.length > 0\n      ? Math.round(confidenceValues.reduce((sum, c) => sum + c, 0) / confidenceValues.length * 100)\n      : 0;\n\n    const totalEffort = Object.values(recommendations).reduce((sum, r) => sum + (r.effort || 0), 0);\n\n    const dependencies = Object.values(recommendations).reduce((sum, r) => sum + (r.dependencies?.length || 0), 0);\n\n    return {\n      totalProcesses,\n      totalQuestions,\n      categories,\n      averageConfidence,\n      totalEffort,\n      dependencies,\n    };\n  }\n\n  attachExportEventListeners() {\n    document.getElementById('export-pdf-btn')?.addEventListener('click', () => {\n      this.exportPDF();\n    });\n\n    document.getElementById('export-json-btn')?.addEventListener('click', () => {\n      this.exportJSON();\n    });\n\n    document.getElementById('export-excel-btn')?.addEventListener('click', () => {\n      this.exportExcel();\n    });\n\n    // Export option hover effects\n    document.querySelectorAll('.export-option').forEach(option => {\n      option.addEventListener('click', (e) => {\n        if (!e.target.closest('button')) {\n          const button = option.querySelector('button');\n          if (button) button.click();\n        }\n      });\n    });\n  }\n\n  getExportOptions() {\n    return {\n      includeAssessmentDetails: document.getElementById('include-assessment-details')?.checked ?? true,\n      includeRationale: document.getElementById('include-rationale')?.checked ?? true,\n      includeDependencies: document.getElementById('include-dependencies')?.checked ?? true,\n      includeVisualization: document.getElementById('include-visualization')?.checked ?? true,\n      includeMetadata: document.getElementById('include-metadata')?.checked ?? true,\n      includeImplementationGuide: document.getElementById('include-implementation-guide')?.checked ?? false,\n    };\n  }\n\n  async exportPDF() {\n    try {\n      this.showExportProgress('Generating PDF report...');\n\n      const assessmentData = this.app.getAssessmentData();\n      const options = this.getExportOptions();\n\n      // Initialize jsPDF\n      const { jsPDF } = window.jspdf;\n      const doc = new jsPDF();\n\n      let yPosition = 20;\n      const pageHeight = doc.internal.pageSize.height;\n      const marginBottom = 20;\n\n      // Helper function to add new page if needed\n      const checkNewPage = (neededSpace = 20) => {\n        if (yPosition + neededSpace > pageHeight - marginBottom) {\n          doc.addPage();\n          yPosition = 20;\n        }\n      };\n\n      // Title Page\n      doc.setFontSize(24);\n      doc.setTextColor(13, 110, 253);\n      doc.text('Systems Engineering Process', 20, yPosition);\n      yPosition += 10;\n      doc.text('Tailoring Report', 20, yPosition);\n      yPosition += 20;\n\n      doc.setFontSize(12);\n      doc.setTextColor(0, 0, 0);\n      doc.text(`Generated: ${new Date().toLocaleDateString()}`, 20, yPosition);\n      yPosition += 10;\n      doc.text('Based on ISO/IEC/IEEE 15288:2023', 20, yPosition);\n      yPosition += 30;\n\n      // Executive Summary\n      checkNewPage(40);\n      doc.setFontSize(16);\n      doc.setTextColor(13, 110, 253);\n      doc.text('Executive Summary', 20, yPosition);\n      yPosition += 15;\n\n      doc.setFontSize(10);\n      doc.setTextColor(0, 0, 0);\n\n      const scores = assessmentData.scores;\n      const summary = [\n        `Overall Assessment Score: ${scores.overall?.toFixed(1) || 'N/A'}/5.0`,\n        `Technical Complexity: ${scores.complexity?.toFixed(1) || 'N/A'}/5.0`,\n        `Safety Criticality: ${scores.safety?.toFixed(1) || 'N/A'}/5.0`,\n        `Project Scale: ${scores.scale?.toFixed(1) || 'N/A'}/5.0`,\n        `Organizational Maturity: ${scores.maturity?.toFixed(1) || 'N/A'}/5.0`,\n      ];\n\n      summary.forEach(line => {\n        checkNewPage();\n        doc.text(line, 20, yPosition);\n        yPosition += 6;\n      });\n\n      yPosition += 10;\n\n      // Process Recommendations\n      const recommendations = assessmentData.recommendations || {};\n      const levelCounts = this.getLevelCounts(recommendations);\n\n      const recSummary = [\n        `Total Processes Analyzed: ${Object.keys(recommendations).length}`,\n        `Basic Level Processes: ${levelCounts.basic}`,\n        `Standard Level Processes: ${levelCounts.standard}`,\n        `Comprehensive Level Processes: ${levelCounts.comprehensive}`,\n      ];\n\n      recSummary.forEach(line => {\n        checkNewPage();\n        doc.text(line, 20, yPosition);\n        yPosition += 6;\n      });\n\n      // Process Recommendations Section\n      checkNewPage(30);\n      yPosition += 10;\n      doc.setFontSize(16);\n      doc.setTextColor(13, 110, 253);\n      doc.text('Process Recommendations', 20, yPosition);\n      yPosition += 15;\n\n      // Group by category\n      const grouped = this.groupRecommendationsByCategory(recommendations);\n\n      Object.keys(grouped).forEach(category => {\n        checkNewPage(20);\n        doc.setFontSize(14);\n        doc.setTextColor(0, 0, 0);\n        const categoryName = this.app.processData.processCategories?.[category] || category;\n        doc.text(categoryName, 20, yPosition);\n        yPosition += 10;\n\n        grouped[category].forEach(process => {\n          checkNewPage(15);\n          doc.setFontSize(10);\n          doc.setTextColor(0, 0, 0);\n\n          const processLine = `${process.processName}: ${process.recommendedLevel.toUpperCase()}`;\n          doc.text(processLine, 25, yPosition);\n          yPosition += 5;\n\n          if (options.includeRationale && process.rationale) {\n            process.rationale.slice(0, 2).forEach(reason => {\n              checkNewPage();\n              const reasonText = `  â€¢ ${reason}`;\n              const splitText = doc.splitTextToSize(reasonText, 160);\n              splitText.forEach(line => {\n                doc.text(line, 30, yPosition);\n                yPosition += 4;\n              });\n            });\n          }\n          yPosition += 3;\n        });\n        yPosition += 5;\n      });\n\n      // Implementation Guidance\n      if (options.includeImplementationGuide) {\n        checkNewPage(30);\n        doc.setFontSize(16);\n        doc.setTextColor(13, 110, 253);\n        doc.text('Implementation Guidance', 20, yPosition);\n        yPosition += 15;\n\n        doc.setFontSize(10);\n        doc.setTextColor(0, 0, 0);\n\n        const guidance = [\n          '1. Begin with high-priority Technical Management processes',\n          '2. Implement processes in dependency order',\n          '3. Start with Basic level and mature gradually',\n          '4. Monitor effectiveness and adjust as needed',\n          '5. Regular reviews ensure continued alignment',\n        ];\n\n        guidance.forEach(item => {\n          checkNewPage();\n          doc.text(item, 20, yPosition);\n          yPosition += 6;\n        });\n      }\n\n      // Assessment Details\n      if (options.includeAssessmentDetails) {\n        checkNewPage(30);\n        doc.setFontSize(16);\n        doc.setTextColor(13, 110, 253);\n        doc.text('Assessment Details', 20, yPosition);\n        yPosition += 15;\n\n        const responses = assessmentData.responses || {};\n        const categories = this.app.questionData.assessmentCategories || [];\n\n        categories.forEach(category => {\n          checkNewPage(15);\n          doc.setFontSize(12);\n          doc.setTextColor(0, 0, 0);\n          doc.text(category.name, 20, yPosition);\n          yPosition += 8;\n\n          category.questions.forEach(question => {\n            const response = responses[question.id];\n            if (response) {\n              checkNewPage(12);\n              doc.setFontSize(9);\n              doc.text(`Q: ${question.text}`, 25, yPosition);\n              yPosition += 5;\n              doc.text(`A: ${response.label} (Score: ${response.score})`, 25, yPosition);\n              yPosition += 7;\n            }\n          });\n          yPosition += 5;\n        });\n      }\n\n      // Metadata\n      if (options.includeMetadata) {\n        checkNewPage(20);\n        doc.setFontSize(12);\n        doc.setTextColor(100, 100, 100);\n        doc.text('Report Metadata', 20, yPosition);\n        yPosition += 10;\n\n        doc.setFontSize(8);\n        const metadata = [\n          `Generated: ${new Date().toISOString()}`,\n          'Framework Version: 1.0.0',\n          'Standard: ISO/IEC/IEEE 15288:2023',\n          `Processes Analyzed: ${Object.keys(recommendations).length}`,\n          `Assessment Questions: ${Object.keys(assessmentData.responses || {}).length}`,\n        ];\n\n        metadata.forEach(line => {\n          doc.text(line, 20, yPosition);\n          yPosition += 4;\n        });\n      }\n\n      // Save the PDF\n      const fileName = `SE_Process_Tailoring_Report_${new Date().toISOString().split('T')[0]}.pdf`;\n      doc.save(fileName);\n\n      this.hideExportProgress();\n      this.app.showSuccess('PDF report downloaded successfully!');\n\n    } catch (error) {\n      // PDF export error\n      this.hideExportProgress();\n      this.app.showError('Failed to generate PDF report. Please try again.');\n    }\n  }\n\n  exportJSON() {\n    try {\n      const assessmentData = this.app.getAssessmentData();\n      const options = this.getExportOptions();\n\n      const exportData = {\n        metadata: {\n          generatedAt: new Date().toISOString(),\n          version: '1.0.0',\n          standard: 'ISO/IEC/IEEE 15288:2023',\n          frameworkVersion: '1.0.0',\n        },\n        assessmentScores: assessmentData.scores,\n        recommendations: assessmentData.recommendations,\n      };\n\n      if (options.includeAssessmentDetails) {\n        exportData.assessmentResponses = assessmentData.responses;\n      }\n\n      if (options.includeDependencies) {\n        exportData.dependencies = this.app.getDependencyData();\n      }\n\n      if (options.includeMetadata) {\n        exportData.processData = this.app.getProcessData();\n      }\n\n      const jsonString = JSON.stringify(exportData, null, 2);\n      const blob = new Blob([jsonString], { type: 'application/json' });\n      const url = URL.createObjectURL(blob);\n\n      const a = document.createElement('a');\n      a.href = url;\n      a.download = `SE_Process_Tailoring_Config_${new Date().toISOString().split('T')[0]}.json`;\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n\n      this.app.showSuccess('JSON configuration downloaded successfully!');\n\n    } catch (error) {\n      // JSON export error\n      this.app.showError('Failed to export JSON configuration. Please try again.');\n    }\n  }\n\n  exportExcel() {\n    try {\n      const assessmentData = this.app.getAssessmentData();\n      const options = this.getExportOptions();\n\n      // Create CSV content (simplified Excel export)\n      let csvContent = 'Process Name,Category,Recommended Level,Effort,Complexity,Confidence,Rationale\\n';\n\n      const recommendations = assessmentData.recommendations || {};\n      Object.values(recommendations).forEach(rec => {\n        const rationale = options.includeRationale\n          ? rec.rationale?.join('; ') || ''\n          : '';\n\n        csvContent += `\"${rec.processName}\",\"${rec.category}\",\"${rec.recommendedLevel}\",${rec.effort},${rec.complexity},${Math.round(rec.confidence * 100)},\"${rationale}\"\\n`;\n      });\n\n      // Add assessment data if requested\n      if (options.includeAssessmentDetails) {\n        csvContent += '\\n\\nAssessment Responses\\n';\n        csvContent += 'Question,Response,Score,Dimension\\n';\n\n        Object.values(assessmentData.responses || {}).forEach(response => {\n          csvContent += `\"${response.questionId}\",\"${response.label}\",${response.score},\"${response.dimension}\"\\n`;\n        });\n      }\n\n      const blob = new Blob([csvContent], { type: 'text/csv' });\n      const url = URL.createObjectURL(blob);\n\n      const a = document.createElement('a');\n      a.href = url;\n      a.download = `SE_Process_Tailoring_Analysis_${new Date().toISOString().split('T')[0]}.csv`;\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n\n      this.app.showSuccess('Excel/CSV file downloaded successfully!');\n\n    } catch (error) {\n      // Excel export error\n      this.app.showError('Failed to export Excel file. Please try again.');\n    }\n  }\n\n  showExportProgress(message) {\n    // Show loading state\n    const loadingHtml = `\n            <div class=\"text-center py-4\" id=\"export-progress\">\n                <div class=\"spinner-border text-primary mb-3\" role=\"status\">\n                    <span class=\"visually-hidden\">Loading...</span>\n                </div>\n                <p class=\"text-muted\">${message}</p>\n            </div>\n        `;\n\n    document.body.insertAdjacentHTML('beforeend', `\n            <div class=\"position-fixed top-0 start-0 w-100 h-100 d-flex align-items-center justify-content-center bg-dark bg-opacity-50\" style=\"z-index: 9999;\" id=\"export-overlay\">\n                ${loadingHtml}\n            </div>\n        `);\n  }\n\n  hideExportProgress() {\n    const overlay = document.getElementById('export-overlay');\n    if (overlay) {\n      overlay.remove();\n    }\n  }\n\n  // Helper methods\n  getLevelCounts(recommendations) {\n    const counts = { basic: 0, standard: 0, comprehensive: 0 };\n    Object.values(recommendations).forEach(rec => {\n      counts[rec.recommendedLevel] = (counts[rec.recommendedLevel] || 0) + 1;\n    });\n    return counts;\n  }\n\n  groupRecommendationsByCategory(recommendations) {\n    const grouped = {};\n    Object.values(recommendations).forEach(rec => {\n      const category = rec.category || 'other';\n      if (!grouped[category]) {\n        grouped[category] = [];\n      }\n      grouped[category].push(rec);\n    });\n\n    // Sort within categories\n    Object.keys(grouped).forEach(category => {\n      grouped[category].sort((a, b) => a.processName.localeCompare(b.processName));\n    });\n\n    return grouped;\n  }\n}\n\n// Export for global access\nwindow.ExportManager = ExportManager;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2UtdGFpbG9yaW5nLWZyYW1ld29yay8uL2pzL2NvbXBvbmVudHMvZXhwb3J0LmpzP2YxZDkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFeHBvcnQgTWFuYWdlciBDb21wb25lbnRcbiAqIEhhbmRsZXMgUERGIHJlcG9ydHMsIEpTT04gY29uZmlndXJhdGlvbiwgYW5kIEV4Y2VsIGFuYWx5dGljcyBleHBvcnRcbiAqL1xuXG5jbGFzcyBFeHBvcnRNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoYXBwKSB7XG4gICAgdGhpcy5hcHAgPSBhcHA7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2V4cG9ydC1jb250ZW50Jyk7XG4gICAgaWYgKCFjb250YWluZXIpIHJldHVybjtcblxuICAgIGNvbnN0IGFzc2Vzc21lbnREYXRhID0gdGhpcy5hcHAuZ2V0QXNzZXNzbWVudERhdGEoKTtcbiAgICBjb25zdCBoYXNEYXRhID0gYXNzZXNzbWVudERhdGEucmVjb21tZW5kYXRpb25zICYmIE9iamVjdC5rZXlzKGFzc2Vzc21lbnREYXRhLnJlY29tbWVuZGF0aW9ucykubGVuZ3RoID4gMDtcblxuICAgIGlmICghaGFzRGF0YSkge1xuICAgICAgdGhpcy5yZW5kZXJOb0RhdGEoY29udGFpbmVyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlckV4cG9ydE9wdGlvbnMoY29udGFpbmVyLCBhc3Nlc3NtZW50RGF0YSk7XG4gIH1cblxuICByZW5kZXJOb0RhdGEoY29udGFpbmVyKSB7XG4gICAgY29udGFpbmVyLmlubmVySFRNTCA9IGBcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0ZXh0LWNlbnRlciBweS01XCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhcmRcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhcmQtYm9keVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJiaSBiaS1leGNsYW1hdGlvbi1jaXJjbGUgZGlzcGxheS0xIHRleHQtd2FybmluZyBtYi0zXCI+PC9pPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGgzPk5vIERhdGEgdG8gRXhwb3J0PC9oMz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVwidGV4dC1tdXRlZCBtYi00XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29tcGxldGUgdGhlIGFzc2Vzc21lbnQgZmlyc3QgdG8gZ2VuZXJhdGUgZXhwb3J0YWJsZSByZWNvbW1lbmRhdGlvbnMgYW5kIHJlcG9ydHMuXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5XCIgb25jbGljaz1cIndpbmRvdy5zZUFwcC5zaG93VmlldygnYXNzZXNzbWVudCcpXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJiaSBiaS1jbGlwYm9hcmQtY2hlY2tcIj48L2k+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU3RhcnQgQXNzZXNzbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIGA7XG4gIH1cblxuICByZW5kZXJFeHBvcnRPcHRpb25zKGNvbnRhaW5lciwgYXNzZXNzbWVudERhdGEpIHtcbiAgICBjb25zdCBzdGF0cyA9IHRoaXMuY2FsY3VsYXRlRXhwb3J0U3RhdHMoYXNzZXNzbWVudERhdGEpO1xuXG4gICAgY29udGFpbmVyLmlubmVySFRNTCA9IGBcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYXJkIHNoYWRvdy1zbSBtYi00XCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhcmQtaGVhZGVyIGJnLWdyYWRpZW50LXByaW1hcnkgdGV4dC13aGl0ZVwiPlxuICAgICAgICAgICAgICAgICAgICA8aDQgY2xhc3M9XCJjYXJkLXRpdGxlIG1iLTBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiYmkgYmktZG93bmxvYWRcIj48L2k+XG4gICAgICAgICAgICAgICAgICAgICAgICBFeHBvcnQgUmVwb3J0cyAmIERhdGFcbiAgICAgICAgICAgICAgICAgICAgPC9oND5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZC1ib2R5XCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJhbGVydCBhbGVydC1pbmZvXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImJpIGJpLWluZm8tY2lyY2xlIG1lLTJcIj48L2k+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3Ryb25nPlJlYWR5IHRvIEV4cG9ydDo8L3N0cm9uZz4gWW91ciBhc3Nlc3NtZW50IGNvbnRhaW5zICR7c3RhdHMudG90YWxQcm9jZXNzZXN9IHByb2Nlc3MgcmVjb21tZW5kYXRpb25zIFxuICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCAke3N0YXRzLnRvdGFsUXVlc3Rpb25zfSBhc3Nlc3NtZW50IHJlc3BvbnNlcyBhY3Jvc3MgJHtzdGF0cy5jYXRlZ29yaWVzfSBjYXRlZ29yaWVzLlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyb3cgbWItNFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC0zIHRleHQtY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInN0YXQtY2FyZFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInN0YXQtbnVtYmVyIHRleHQtcHJpbWFyeVwiPiR7c3RhdHMudG90YWxQcm9jZXNzZXN9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInN0YXQtbGFiZWxcIj5Qcm9jZXNzIFJlY29tbWVuZGF0aW9uczwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC0zIHRleHQtY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInN0YXQtY2FyZFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInN0YXQtbnVtYmVyIHRleHQtc3VjY2Vzc1wiPiR7c3RhdHMuYXZlcmFnZUNvbmZpZGVuY2V9JTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJzdGF0LWxhYmVsXCI+QXZlcmFnZSBDb25maWRlbmNlPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTMgdGV4dC1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3RhdC1jYXJkXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwic3RhdC1udW1iZXIgdGV4dC13YXJuaW5nXCI+JHtzdGF0cy50b3RhbEVmZm9ydH08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwic3RhdC1sYWJlbFwiPlRvdGFsIEVmZm9ydCBTY29yZTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC0zIHRleHQtY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInN0YXQtY2FyZFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInN0YXQtbnVtYmVyIHRleHQtaW5mb1wiPiR7c3RhdHMuZGVwZW5kZW5jaWVzfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJzdGF0LWxhYmVsXCI+RGVwZW5kZW5jaWVzPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLWxnLTQgbWItNFwiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZXhwb3J0LW9wdGlvblwiIGRhdGEtZXhwb3J0LXR5cGU9XCJwZGZcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJleHBvcnQtaWNvblwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiYmkgYmktZmlsZS1lYXJtYXJrLXBkZi1maWxsXCI+PC9pPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aDUgY2xhc3M9XCJleHBvcnQtdGl0bGVcIj5Qcm9mZXNzaW9uYWwgUERGIFJlcG9ydDwvaDU+XG4gICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cImV4cG9ydC1kZXNjcmlwdGlvblwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbXByZWhlbnNpdmUgcmVwb3J0IHdpdGggZXhlY3V0aXZlIHN1bW1hcnksIGRldGFpbGVkIHJlY29tbWVuZGF0aW9ucywgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2VzcyBuZXR3b3JrIHZpc3VhbGl6YXRpb24sIGFuZCBpbXBsZW1lbnRhdGlvbiByb2FkbWFwLlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeVwiIGlkPVwiZXhwb3J0LXBkZi1idG5cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImJpIGJpLWRvd25sb2FkXCI+PC9pPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIERvd25sb2FkIFBERlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbGctNCBtYi00XCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJleHBvcnQtb3B0aW9uXCIgZGF0YS1leHBvcnQtdHlwZT1cImpzb25cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJleHBvcnQtaWNvblwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiYmkgYmktZmlsZS1lYXJtYXJrLWNvZGUtZmlsbFwiPjwvaT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGg1IGNsYXNzPVwiZXhwb3J0LXRpdGxlXCI+SlNPTiBDb25maWd1cmF0aW9uPC9oNT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVwiZXhwb3J0LWRlc2NyaXB0aW9uXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWFjaGluZS1yZWFkYWJsZSBmb3JtYXQgY29udGFpbmluZyBhc3Nlc3NtZW50IGRhdGEsIHNjb3JlcywgYW5kIHJlY29tbWVuZGF0aW9ucyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgaW50ZWdyYXRpb24gd2l0aCBvdGhlciB0b29scyBhbmQgc3lzdGVtcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtcHJpbWFyeVwiIGlkPVwiZXhwb3J0LWpzb24tYnRuXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJiaSBiaS1kb3dubG9hZFwiPjwvaT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBEb3dubG9hZCBKU09OXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1sZy00IG1iLTRcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImV4cG9ydC1vcHRpb25cIiBkYXRhLWV4cG9ydC10eXBlPVwiZXhjZWxcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJleHBvcnQtaWNvblwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiYmkgYmktZmlsZS1lYXJtYXJrLXNwcmVhZHNoZWV0LWZpbGxcIj48L2k+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxoNSBjbGFzcz1cImV4cG9ydC10aXRsZVwiPkV4Y2VsIEFuYWx5dGljczwvaDU+XG4gICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cImV4cG9ydC1kZXNjcmlwdGlvblwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNwcmVhZHNoZWV0IGZvcm1hdCB3aXRoIGFzc2Vzc21lbnQgcmVzcG9uc2VzLCBwcm9jZXNzIHJlY29tbWVuZGF0aW9ucywgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWZmb3J0IGNhbGN1bGF0aW9ucywgYW5kIHBpdm90IHRhYmxlcyBmb3IgZnVydGhlciBhbmFseXNpcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc3VjY2Vzc1wiIGlkPVwiZXhwb3J0LWV4Y2VsLWJ0blwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiYmkgYmktZG93bmxvYWRcIj48L2k+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRG93bmxvYWQgRXhjZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZFwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYXJkLWhlYWRlclwiPlxuICAgICAgICAgICAgICAgICAgICA8aDYgY2xhc3M9XCJjYXJkLXRpdGxlIG1iLTBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiYmkgYmktZ2VhclwiPjwvaT5cbiAgICAgICAgICAgICAgICAgICAgICAgIEV4cG9ydCBPcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIDwvaDY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhcmQtYm9keVwiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTZcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1jaGVja1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJmb3JtLWNoZWNrLWlucHV0XCIgdHlwZT1cImNoZWNrYm94XCIgaWQ9XCJpbmNsdWRlLWFzc2Vzc21lbnQtZGV0YWlsc1wiIGNoZWNrZWQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImZvcm0tY2hlY2stbGFiZWxcIiBmb3I9XCJpbmNsdWRlLWFzc2Vzc21lbnQtZGV0YWlsc1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5jbHVkZSBkZXRhaWxlZCBhc3Nlc3NtZW50IHJlc3BvbnNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWNoZWNrXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImZvcm0tY2hlY2staW5wdXRcIiB0eXBlPVwiY2hlY2tib3hcIiBpZD1cImluY2x1ZGUtcmF0aW9uYWxlXCIgY2hlY2tlZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiZm9ybS1jaGVjay1sYWJlbFwiIGZvcj1cImluY2x1ZGUtcmF0aW9uYWxlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmNsdWRlIHJlY29tbWVuZGF0aW9uIHJhdGlvbmFsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWNoZWNrXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImZvcm0tY2hlY2staW5wdXRcIiB0eXBlPVwiY2hlY2tib3hcIiBpZD1cImluY2x1ZGUtZGVwZW5kZW5jaWVzXCIgY2hlY2tlZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiZm9ybS1jaGVjay1sYWJlbFwiIGZvcj1cImluY2x1ZGUtZGVwZW5kZW5jaWVzXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmNsdWRlIHByb2Nlc3MgZGVwZW5kZW5jaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNlwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWNoZWNrXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImZvcm0tY2hlY2staW5wdXRcIiB0eXBlPVwiY2hlY2tib3hcIiBpZD1cImluY2x1ZGUtdmlzdWFsaXphdGlvblwiIGNoZWNrZWQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImZvcm0tY2hlY2stbGFiZWxcIiBmb3I9XCJpbmNsdWRlLXZpc3VhbGl6YXRpb25cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEluY2x1ZGUgcHJvY2VzcyBuZXR3b3JrIHZpc3VhbGl6YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1jaGVja1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJmb3JtLWNoZWNrLWlucHV0XCIgdHlwZT1cImNoZWNrYm94XCIgaWQ9XCJpbmNsdWRlLW1ldGFkYXRhXCIgY2hlY2tlZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiZm9ybS1jaGVjay1sYWJlbFwiIGZvcj1cImluY2x1ZGUtbWV0YWRhdGFcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEluY2x1ZGUgbWV0YWRhdGEgYW5kIHRpbWVzdGFtcHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1jaGVja1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJmb3JtLWNoZWNrLWlucHV0XCIgdHlwZT1cImNoZWNrYm94XCIgaWQ9XCJpbmNsdWRlLWltcGxlbWVudGF0aW9uLWd1aWRlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImZvcm0tY2hlY2stbGFiZWxcIiBmb3I9XCJpbmNsdWRlLWltcGxlbWVudGF0aW9uLWd1aWRlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmNsdWRlIGltcGxlbWVudGF0aW9uIGd1aWRhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm10LTQgdGV4dC1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJ0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiYmkgYmktc2hpZWxkLWNoZWNrXCI+PC9pPlxuICAgICAgICAgICAgICAgICAgICBBbGwgZXhwb3J0cyBhcmUgZ2VuZXJhdGVkIGxvY2FsbHkgaW4geW91ciBicm93c2VyLiBObyBkYXRhIGlzIHNlbnQgdG8gZXh0ZXJuYWwgc2VydmVycy5cbiAgICAgICAgICAgICAgICA8L3NtYWxsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIGA7XG5cbiAgICB0aGlzLmF0dGFjaEV4cG9ydEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICBjYWxjdWxhdGVFeHBvcnRTdGF0cyhhc3Nlc3NtZW50RGF0YSkge1xuICAgIGNvbnN0IHJlY29tbWVuZGF0aW9ucyA9IGFzc2Vzc21lbnREYXRhLnJlY29tbWVuZGF0aW9ucyB8fCB7fTtcbiAgICBjb25zdCByZXNwb25zZXMgPSBhc3Nlc3NtZW50RGF0YS5yZXNwb25zZXMgfHwge307XG5cbiAgICBjb25zdCB0b3RhbFByb2Nlc3NlcyA9IE9iamVjdC5rZXlzKHJlY29tbWVuZGF0aW9ucykubGVuZ3RoO1xuICAgIGNvbnN0IHRvdGFsUXVlc3Rpb25zID0gT2JqZWN0LmtleXMocmVzcG9uc2VzKS5sZW5ndGg7XG4gICAgY29uc3QgY2F0ZWdvcmllcyA9IG5ldyBTZXQoT2JqZWN0LnZhbHVlcyhyZXNwb25zZXMpLm1hcChyID0+IHIuZGltZW5zaW9uKSkuc2l6ZTtcblxuICAgIGNvbnN0IGNvbmZpZGVuY2VWYWx1ZXMgPSBPYmplY3QudmFsdWVzKHJlY29tbWVuZGF0aW9ucykubWFwKHIgPT4gci5jb25maWRlbmNlIHx8IDApO1xuICAgIGNvbnN0IGF2ZXJhZ2VDb25maWRlbmNlID0gY29uZmlkZW5jZVZhbHVlcy5sZW5ndGggPiAwXG4gICAgICA/IE1hdGgucm91bmQoY29uZmlkZW5jZVZhbHVlcy5yZWR1Y2UoKHN1bSwgYykgPT4gc3VtICsgYywgMCkgLyBjb25maWRlbmNlVmFsdWVzLmxlbmd0aCAqIDEwMClcbiAgICAgIDogMDtcblxuICAgIGNvbnN0IHRvdGFsRWZmb3J0ID0gT2JqZWN0LnZhbHVlcyhyZWNvbW1lbmRhdGlvbnMpLnJlZHVjZSgoc3VtLCByKSA9PiBzdW0gKyAoci5lZmZvcnQgfHwgMCksIDApO1xuXG4gICAgY29uc3QgZGVwZW5kZW5jaWVzID0gT2JqZWN0LnZhbHVlcyhyZWNvbW1lbmRhdGlvbnMpLnJlZHVjZSgoc3VtLCByKSA9PiBzdW0gKyAoci5kZXBlbmRlbmNpZXM/Lmxlbmd0aCB8fCAwKSwgMCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG90YWxQcm9jZXNzZXMsXG4gICAgICB0b3RhbFF1ZXN0aW9ucyxcbiAgICAgIGNhdGVnb3JpZXMsXG4gICAgICBhdmVyYWdlQ29uZmlkZW5jZSxcbiAgICAgIHRvdGFsRWZmb3J0LFxuICAgICAgZGVwZW5kZW5jaWVzLFxuICAgIH07XG4gIH1cblxuICBhdHRhY2hFeHBvcnRFdmVudExpc3RlbmVycygpIHtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXhwb3J0LXBkZi1idG4nKT8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICB0aGlzLmV4cG9ydFBERigpO1xuICAgIH0pO1xuXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2V4cG9ydC1qc29uLWJ0bicpPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgIHRoaXMuZXhwb3J0SlNPTigpO1xuICAgIH0pO1xuXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2V4cG9ydC1leGNlbC1idG4nKT8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICB0aGlzLmV4cG9ydEV4Y2VsKCk7XG4gICAgfSk7XG5cbiAgICAvLyBFeHBvcnQgb3B0aW9uIGhvdmVyIGVmZmVjdHNcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZXhwb3J0LW9wdGlvbicpLmZvckVhY2gob3B0aW9uID0+IHtcbiAgICAgIG9wdGlvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gICAgICAgIGlmICghZS50YXJnZXQuY2xvc2VzdCgnYnV0dG9uJykpIHtcbiAgICAgICAgICBjb25zdCBidXR0b24gPSBvcHRpb24ucXVlcnlTZWxlY3RvcignYnV0dG9uJyk7XG4gICAgICAgICAgaWYgKGJ1dHRvbikgYnV0dG9uLmNsaWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0RXhwb3J0T3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW5jbHVkZUFzc2Vzc21lbnREZXRhaWxzOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW5jbHVkZS1hc3Nlc3NtZW50LWRldGFpbHMnKT8uY2hlY2tlZCA/PyB0cnVlLFxuICAgICAgaW5jbHVkZVJhdGlvbmFsZTogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2luY2x1ZGUtcmF0aW9uYWxlJyk/LmNoZWNrZWQgPz8gdHJ1ZSxcbiAgICAgIGluY2x1ZGVEZXBlbmRlbmNpZXM6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbmNsdWRlLWRlcGVuZGVuY2llcycpPy5jaGVja2VkID8/IHRydWUsXG4gICAgICBpbmNsdWRlVmlzdWFsaXphdGlvbjogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2luY2x1ZGUtdmlzdWFsaXphdGlvbicpPy5jaGVja2VkID8/IHRydWUsXG4gICAgICBpbmNsdWRlTWV0YWRhdGE6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbmNsdWRlLW1ldGFkYXRhJyk/LmNoZWNrZWQgPz8gdHJ1ZSxcbiAgICAgIGluY2x1ZGVJbXBsZW1lbnRhdGlvbkd1aWRlOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW5jbHVkZS1pbXBsZW1lbnRhdGlvbi1ndWlkZScpPy5jaGVja2VkID8/IGZhbHNlLFxuICAgIH07XG4gIH1cblxuICBhc3luYyBleHBvcnRQREYoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuc2hvd0V4cG9ydFByb2dyZXNzKCdHZW5lcmF0aW5nIFBERiByZXBvcnQuLi4nKTtcblxuICAgICAgY29uc3QgYXNzZXNzbWVudERhdGEgPSB0aGlzLmFwcC5nZXRBc3Nlc3NtZW50RGF0YSgpO1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZ2V0RXhwb3J0T3B0aW9ucygpO1xuXG4gICAgICAvLyBJbml0aWFsaXplIGpzUERGXG4gICAgICBjb25zdCB7IGpzUERGIH0gPSB3aW5kb3cuanNwZGY7XG4gICAgICBjb25zdCBkb2MgPSBuZXcganNQREYoKTtcblxuICAgICAgbGV0IHlQb3NpdGlvbiA9IDIwO1xuICAgICAgY29uc3QgcGFnZUhlaWdodCA9IGRvYy5pbnRlcm5hbC5wYWdlU2l6ZS5oZWlnaHQ7XG4gICAgICBjb25zdCBtYXJnaW5Cb3R0b20gPSAyMDtcblxuICAgICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGFkZCBuZXcgcGFnZSBpZiBuZWVkZWRcbiAgICAgIGNvbnN0IGNoZWNrTmV3UGFnZSA9IChuZWVkZWRTcGFjZSA9IDIwKSA9PiB7XG4gICAgICAgIGlmICh5UG9zaXRpb24gKyBuZWVkZWRTcGFjZSA+IHBhZ2VIZWlnaHQgLSBtYXJnaW5Cb3R0b20pIHtcbiAgICAgICAgICBkb2MuYWRkUGFnZSgpO1xuICAgICAgICAgIHlQb3NpdGlvbiA9IDIwO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBUaXRsZSBQYWdlXG4gICAgICBkb2Muc2V0Rm9udFNpemUoMjQpO1xuICAgICAgZG9jLnNldFRleHRDb2xvcigxMywgMTEwLCAyNTMpO1xuICAgICAgZG9jLnRleHQoJ1N5c3RlbXMgRW5naW5lZXJpbmcgUHJvY2VzcycsIDIwLCB5UG9zaXRpb24pO1xuICAgICAgeVBvc2l0aW9uICs9IDEwO1xuICAgICAgZG9jLnRleHQoJ1RhaWxvcmluZyBSZXBvcnQnLCAyMCwgeVBvc2l0aW9uKTtcbiAgICAgIHlQb3NpdGlvbiArPSAyMDtcblxuICAgICAgZG9jLnNldEZvbnRTaXplKDEyKTtcbiAgICAgIGRvYy5zZXRUZXh0Q29sb3IoMCwgMCwgMCk7XG4gICAgICBkb2MudGV4dChgR2VuZXJhdGVkOiAke25ldyBEYXRlKCkudG9Mb2NhbGVEYXRlU3RyaW5nKCl9YCwgMjAsIHlQb3NpdGlvbik7XG4gICAgICB5UG9zaXRpb24gKz0gMTA7XG4gICAgICBkb2MudGV4dCgnQmFzZWQgb24gSVNPL0lFQy9JRUVFIDE1Mjg4OjIwMjMnLCAyMCwgeVBvc2l0aW9uKTtcbiAgICAgIHlQb3NpdGlvbiArPSAzMDtcblxuICAgICAgLy8gRXhlY3V0aXZlIFN1bW1hcnlcbiAgICAgIGNoZWNrTmV3UGFnZSg0MCk7XG4gICAgICBkb2Muc2V0Rm9udFNpemUoMTYpO1xuICAgICAgZG9jLnNldFRleHRDb2xvcigxMywgMTEwLCAyNTMpO1xuICAgICAgZG9jLnRleHQoJ0V4ZWN1dGl2ZSBTdW1tYXJ5JywgMjAsIHlQb3NpdGlvbik7XG4gICAgICB5UG9zaXRpb24gKz0gMTU7XG5cbiAgICAgIGRvYy5zZXRGb250U2l6ZSgxMCk7XG4gICAgICBkb2Muc2V0VGV4dENvbG9yKDAsIDAsIDApO1xuXG4gICAgICBjb25zdCBzY29yZXMgPSBhc3Nlc3NtZW50RGF0YS5zY29yZXM7XG4gICAgICBjb25zdCBzdW1tYXJ5ID0gW1xuICAgICAgICBgT3ZlcmFsbCBBc3Nlc3NtZW50IFNjb3JlOiAke3Njb3Jlcy5vdmVyYWxsPy50b0ZpeGVkKDEpIHx8ICdOL0EnfS81LjBgLFxuICAgICAgICBgVGVjaG5pY2FsIENvbXBsZXhpdHk6ICR7c2NvcmVzLmNvbXBsZXhpdHk/LnRvRml4ZWQoMSkgfHwgJ04vQSd9LzUuMGAsXG4gICAgICAgIGBTYWZldHkgQ3JpdGljYWxpdHk6ICR7c2NvcmVzLnNhZmV0eT8udG9GaXhlZCgxKSB8fCAnTi9BJ30vNS4wYCxcbiAgICAgICAgYFByb2plY3QgU2NhbGU6ICR7c2NvcmVzLnNjYWxlPy50b0ZpeGVkKDEpIHx8ICdOL0EnfS81LjBgLFxuICAgICAgICBgT3JnYW5pemF0aW9uYWwgTWF0dXJpdHk6ICR7c2NvcmVzLm1hdHVyaXR5Py50b0ZpeGVkKDEpIHx8ICdOL0EnfS81LjBgLFxuICAgICAgXTtcblxuICAgICAgc3VtbWFyeS5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgICBjaGVja05ld1BhZ2UoKTtcbiAgICAgICAgZG9jLnRleHQobGluZSwgMjAsIHlQb3NpdGlvbik7XG4gICAgICAgIHlQb3NpdGlvbiArPSA2O1xuICAgICAgfSk7XG5cbiAgICAgIHlQb3NpdGlvbiArPSAxMDtcblxuICAgICAgLy8gUHJvY2VzcyBSZWNvbW1lbmRhdGlvbnNcbiAgICAgIGNvbnN0IHJlY29tbWVuZGF0aW9ucyA9IGFzc2Vzc21lbnREYXRhLnJlY29tbWVuZGF0aW9ucyB8fCB7fTtcbiAgICAgIGNvbnN0IGxldmVsQ291bnRzID0gdGhpcy5nZXRMZXZlbENvdW50cyhyZWNvbW1lbmRhdGlvbnMpO1xuXG4gICAgICBjb25zdCByZWNTdW1tYXJ5ID0gW1xuICAgICAgICBgVG90YWwgUHJvY2Vzc2VzIEFuYWx5emVkOiAke09iamVjdC5rZXlzKHJlY29tbWVuZGF0aW9ucykubGVuZ3RofWAsXG4gICAgICAgIGBCYXNpYyBMZXZlbCBQcm9jZXNzZXM6ICR7bGV2ZWxDb3VudHMuYmFzaWN9YCxcbiAgICAgICAgYFN0YW5kYXJkIExldmVsIFByb2Nlc3NlczogJHtsZXZlbENvdW50cy5zdGFuZGFyZH1gLFxuICAgICAgICBgQ29tcHJlaGVuc2l2ZSBMZXZlbCBQcm9jZXNzZXM6ICR7bGV2ZWxDb3VudHMuY29tcHJlaGVuc2l2ZX1gLFxuICAgICAgXTtcblxuICAgICAgcmVjU3VtbWFyeS5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgICBjaGVja05ld1BhZ2UoKTtcbiAgICAgICAgZG9jLnRleHQobGluZSwgMjAsIHlQb3NpdGlvbik7XG4gICAgICAgIHlQb3NpdGlvbiArPSA2O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFByb2Nlc3MgUmVjb21tZW5kYXRpb25zIFNlY3Rpb25cbiAgICAgIGNoZWNrTmV3UGFnZSgzMCk7XG4gICAgICB5UG9zaXRpb24gKz0gMTA7XG4gICAgICBkb2Muc2V0Rm9udFNpemUoMTYpO1xuICAgICAgZG9jLnNldFRleHRDb2xvcigxMywgMTEwLCAyNTMpO1xuICAgICAgZG9jLnRleHQoJ1Byb2Nlc3MgUmVjb21tZW5kYXRpb25zJywgMjAsIHlQb3NpdGlvbik7XG4gICAgICB5UG9zaXRpb24gKz0gMTU7XG5cbiAgICAgIC8vIEdyb3VwIGJ5IGNhdGVnb3J5XG4gICAgICBjb25zdCBncm91cGVkID0gdGhpcy5ncm91cFJlY29tbWVuZGF0aW9uc0J5Q2F0ZWdvcnkocmVjb21tZW5kYXRpb25zKTtcblxuICAgICAgT2JqZWN0LmtleXMoZ3JvdXBlZCkuZm9yRWFjaChjYXRlZ29yeSA9PiB7XG4gICAgICAgIGNoZWNrTmV3UGFnZSgyMCk7XG4gICAgICAgIGRvYy5zZXRGb250U2l6ZSgxNCk7XG4gICAgICAgIGRvYy5zZXRUZXh0Q29sb3IoMCwgMCwgMCk7XG4gICAgICAgIGNvbnN0IGNhdGVnb3J5TmFtZSA9IHRoaXMuYXBwLnByb2Nlc3NEYXRhLnByb2Nlc3NDYXRlZ29yaWVzPy5bY2F0ZWdvcnldIHx8IGNhdGVnb3J5O1xuICAgICAgICBkb2MudGV4dChjYXRlZ29yeU5hbWUsIDIwLCB5UG9zaXRpb24pO1xuICAgICAgICB5UG9zaXRpb24gKz0gMTA7XG5cbiAgICAgICAgZ3JvdXBlZFtjYXRlZ29yeV0uZm9yRWFjaChwcm9jZXNzID0+IHtcbiAgICAgICAgICBjaGVja05ld1BhZ2UoMTUpO1xuICAgICAgICAgIGRvYy5zZXRGb250U2l6ZSgxMCk7XG4gICAgICAgICAgZG9jLnNldFRleHRDb2xvcigwLCAwLCAwKTtcblxuICAgICAgICAgIGNvbnN0IHByb2Nlc3NMaW5lID0gYCR7cHJvY2Vzcy5wcm9jZXNzTmFtZX06ICR7cHJvY2Vzcy5yZWNvbW1lbmRlZExldmVsLnRvVXBwZXJDYXNlKCl9YDtcbiAgICAgICAgICBkb2MudGV4dChwcm9jZXNzTGluZSwgMjUsIHlQb3NpdGlvbik7XG4gICAgICAgICAgeVBvc2l0aW9uICs9IDU7XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5pbmNsdWRlUmF0aW9uYWxlICYmIHByb2Nlc3MucmF0aW9uYWxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLnJhdGlvbmFsZS5zbGljZSgwLCAyKS5mb3JFYWNoKHJlYXNvbiA9PiB7XG4gICAgICAgICAgICAgIGNoZWNrTmV3UGFnZSgpO1xuICAgICAgICAgICAgICBjb25zdCByZWFzb25UZXh0ID0gYCAg4oCiICR7cmVhc29ufWA7XG4gICAgICAgICAgICAgIGNvbnN0IHNwbGl0VGV4dCA9IGRvYy5zcGxpdFRleHRUb1NpemUocmVhc29uVGV4dCwgMTYwKTtcbiAgICAgICAgICAgICAgc3BsaXRUZXh0LmZvckVhY2gobGluZSA9PiB7XG4gICAgICAgICAgICAgICAgZG9jLnRleHQobGluZSwgMzAsIHlQb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgeVBvc2l0aW9uICs9IDQ7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHlQb3NpdGlvbiArPSAzO1xuICAgICAgICB9KTtcbiAgICAgICAgeVBvc2l0aW9uICs9IDU7XG4gICAgICB9KTtcblxuICAgICAgLy8gSW1wbGVtZW50YXRpb24gR3VpZGFuY2VcbiAgICAgIGlmIChvcHRpb25zLmluY2x1ZGVJbXBsZW1lbnRhdGlvbkd1aWRlKSB7XG4gICAgICAgIGNoZWNrTmV3UGFnZSgzMCk7XG4gICAgICAgIGRvYy5zZXRGb250U2l6ZSgxNik7XG4gICAgICAgIGRvYy5zZXRUZXh0Q29sb3IoMTMsIDExMCwgMjUzKTtcbiAgICAgICAgZG9jLnRleHQoJ0ltcGxlbWVudGF0aW9uIEd1aWRhbmNlJywgMjAsIHlQb3NpdGlvbik7XG4gICAgICAgIHlQb3NpdGlvbiArPSAxNTtcblxuICAgICAgICBkb2Muc2V0Rm9udFNpemUoMTApO1xuICAgICAgICBkb2Muc2V0VGV4dENvbG9yKDAsIDAsIDApO1xuXG4gICAgICAgIGNvbnN0IGd1aWRhbmNlID0gW1xuICAgICAgICAgICcxLiBCZWdpbiB3aXRoIGhpZ2gtcHJpb3JpdHkgVGVjaG5pY2FsIE1hbmFnZW1lbnQgcHJvY2Vzc2VzJyxcbiAgICAgICAgICAnMi4gSW1wbGVtZW50IHByb2Nlc3NlcyBpbiBkZXBlbmRlbmN5IG9yZGVyJyxcbiAgICAgICAgICAnMy4gU3RhcnQgd2l0aCBCYXNpYyBsZXZlbCBhbmQgbWF0dXJlIGdyYWR1YWxseScsXG4gICAgICAgICAgJzQuIE1vbml0b3IgZWZmZWN0aXZlbmVzcyBhbmQgYWRqdXN0IGFzIG5lZWRlZCcsXG4gICAgICAgICAgJzUuIFJlZ3VsYXIgcmV2aWV3cyBlbnN1cmUgY29udGludWVkIGFsaWdubWVudCcsXG4gICAgICAgIF07XG5cbiAgICAgICAgZ3VpZGFuY2UuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICBjaGVja05ld1BhZ2UoKTtcbiAgICAgICAgICBkb2MudGV4dChpdGVtLCAyMCwgeVBvc2l0aW9uKTtcbiAgICAgICAgICB5UG9zaXRpb24gKz0gNjtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFzc2Vzc21lbnQgRGV0YWlsc1xuICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZUFzc2Vzc21lbnREZXRhaWxzKSB7XG4gICAgICAgIGNoZWNrTmV3UGFnZSgzMCk7XG4gICAgICAgIGRvYy5zZXRGb250U2l6ZSgxNik7XG4gICAgICAgIGRvYy5zZXRUZXh0Q29sb3IoMTMsIDExMCwgMjUzKTtcbiAgICAgICAgZG9jLnRleHQoJ0Fzc2Vzc21lbnQgRGV0YWlscycsIDIwLCB5UG9zaXRpb24pO1xuICAgICAgICB5UG9zaXRpb24gKz0gMTU7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2VzID0gYXNzZXNzbWVudERhdGEucmVzcG9uc2VzIHx8IHt9O1xuICAgICAgICBjb25zdCBjYXRlZ29yaWVzID0gdGhpcy5hcHAucXVlc3Rpb25EYXRhLmFzc2Vzc21lbnRDYXRlZ29yaWVzIHx8IFtdO1xuXG4gICAgICAgIGNhdGVnb3JpZXMuZm9yRWFjaChjYXRlZ29yeSA9PiB7XG4gICAgICAgICAgY2hlY2tOZXdQYWdlKDE1KTtcbiAgICAgICAgICBkb2Muc2V0Rm9udFNpemUoMTIpO1xuICAgICAgICAgIGRvYy5zZXRUZXh0Q29sb3IoMCwgMCwgMCk7XG4gICAgICAgICAgZG9jLnRleHQoY2F0ZWdvcnkubmFtZSwgMjAsIHlQb3NpdGlvbik7XG4gICAgICAgICAgeVBvc2l0aW9uICs9IDg7XG5cbiAgICAgICAgICBjYXRlZ29yeS5xdWVzdGlvbnMuZm9yRWFjaChxdWVzdGlvbiA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHJlc3BvbnNlc1txdWVzdGlvbi5pZF07XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgY2hlY2tOZXdQYWdlKDEyKTtcbiAgICAgICAgICAgICAgZG9jLnNldEZvbnRTaXplKDkpO1xuICAgICAgICAgICAgICBkb2MudGV4dChgUTogJHtxdWVzdGlvbi50ZXh0fWAsIDI1LCB5UG9zaXRpb24pO1xuICAgICAgICAgICAgICB5UG9zaXRpb24gKz0gNTtcbiAgICAgICAgICAgICAgZG9jLnRleHQoYEE6ICR7cmVzcG9uc2UubGFiZWx9IChTY29yZTogJHtyZXNwb25zZS5zY29yZX0pYCwgMjUsIHlQb3NpdGlvbik7XG4gICAgICAgICAgICAgIHlQb3NpdGlvbiArPSA3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHlQb3NpdGlvbiArPSA1O1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gTWV0YWRhdGFcbiAgICAgIGlmIChvcHRpb25zLmluY2x1ZGVNZXRhZGF0YSkge1xuICAgICAgICBjaGVja05ld1BhZ2UoMjApO1xuICAgICAgICBkb2Muc2V0Rm9udFNpemUoMTIpO1xuICAgICAgICBkb2Muc2V0VGV4dENvbG9yKDEwMCwgMTAwLCAxMDApO1xuICAgICAgICBkb2MudGV4dCgnUmVwb3J0IE1ldGFkYXRhJywgMjAsIHlQb3NpdGlvbik7XG4gICAgICAgIHlQb3NpdGlvbiArPSAxMDtcblxuICAgICAgICBkb2Muc2V0Rm9udFNpemUoOCk7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gW1xuICAgICAgICAgIGBHZW5lcmF0ZWQ6ICR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfWAsXG4gICAgICAgICAgJ0ZyYW1ld29yayBWZXJzaW9uOiAxLjAuMCcsXG4gICAgICAgICAgJ1N0YW5kYXJkOiBJU08vSUVDL0lFRUUgMTUyODg6MjAyMycsXG4gICAgICAgICAgYFByb2Nlc3NlcyBBbmFseXplZDogJHtPYmplY3Qua2V5cyhyZWNvbW1lbmRhdGlvbnMpLmxlbmd0aH1gLFxuICAgICAgICAgIGBBc3Nlc3NtZW50IFF1ZXN0aW9uczogJHtPYmplY3Qua2V5cyhhc3Nlc3NtZW50RGF0YS5yZXNwb25zZXMgfHwge30pLmxlbmd0aH1gLFxuICAgICAgICBdO1xuXG4gICAgICAgIG1ldGFkYXRhLmZvckVhY2gobGluZSA9PiB7XG4gICAgICAgICAgZG9jLnRleHQobGluZSwgMjAsIHlQb3NpdGlvbik7XG4gICAgICAgICAgeVBvc2l0aW9uICs9IDQ7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBTYXZlIHRoZSBQREZcbiAgICAgIGNvbnN0IGZpbGVOYW1lID0gYFNFX1Byb2Nlc3NfVGFpbG9yaW5nX1JlcG9ydF8ke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdfS5wZGZgO1xuICAgICAgZG9jLnNhdmUoZmlsZU5hbWUpO1xuXG4gICAgICB0aGlzLmhpZGVFeHBvcnRQcm9ncmVzcygpO1xuICAgICAgdGhpcy5hcHAuc2hvd1N1Y2Nlc3MoJ1BERiByZXBvcnQgZG93bmxvYWRlZCBzdWNjZXNzZnVsbHkhJyk7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gUERGIGV4cG9ydCBlcnJvclxuICAgICAgdGhpcy5oaWRlRXhwb3J0UHJvZ3Jlc3MoKTtcbiAgICAgIHRoaXMuYXBwLnNob3dFcnJvcignRmFpbGVkIHRvIGdlbmVyYXRlIFBERiByZXBvcnQuIFBsZWFzZSB0cnkgYWdhaW4uJyk7XG4gICAgfVxuICB9XG5cbiAgZXhwb3J0SlNPTigpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYXNzZXNzbWVudERhdGEgPSB0aGlzLmFwcC5nZXRBc3Nlc3NtZW50RGF0YSgpO1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZ2V0RXhwb3J0T3B0aW9ucygpO1xuXG4gICAgICBjb25zdCBleHBvcnREYXRhID0ge1xuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIGdlbmVyYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgICBzdGFuZGFyZDogJ0lTTy9JRUMvSUVFRSAxNTI4ODoyMDIzJyxcbiAgICAgICAgICBmcmFtZXdvcmtWZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICB9LFxuICAgICAgICBhc3Nlc3NtZW50U2NvcmVzOiBhc3Nlc3NtZW50RGF0YS5zY29yZXMsXG4gICAgICAgIHJlY29tbWVuZGF0aW9uczogYXNzZXNzbWVudERhdGEucmVjb21tZW5kYXRpb25zLFxuICAgICAgfTtcblxuICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZUFzc2Vzc21lbnREZXRhaWxzKSB7XG4gICAgICAgIGV4cG9ydERhdGEuYXNzZXNzbWVudFJlc3BvbnNlcyA9IGFzc2Vzc21lbnREYXRhLnJlc3BvbnNlcztcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZURlcGVuZGVuY2llcykge1xuICAgICAgICBleHBvcnREYXRhLmRlcGVuZGVuY2llcyA9IHRoaXMuYXBwLmdldERlcGVuZGVuY3lEYXRhKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmluY2x1ZGVNZXRhZGF0YSkge1xuICAgICAgICBleHBvcnREYXRhLnByb2Nlc3NEYXRhID0gdGhpcy5hcHAuZ2V0UHJvY2Vzc0RhdGEoKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QganNvblN0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cG9ydERhdGEsIG51bGwsIDIpO1xuICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtqc29uU3RyaW5nXSwgeyB0eXBlOiAnYXBwbGljYXRpb24vanNvbicgfSk7XG4gICAgICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG4gICAgICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgYS5ocmVmID0gdXJsO1xuICAgICAgYS5kb3dubG9hZCA9IGBTRV9Qcm9jZXNzX1RhaWxvcmluZ19Db25maWdfJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXX0uanNvbmA7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGEpO1xuICAgICAgYS5jbGljaygpO1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChhKTtcbiAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcblxuICAgICAgdGhpcy5hcHAuc2hvd1N1Y2Nlc3MoJ0pTT04gY29uZmlndXJhdGlvbiBkb3dubG9hZGVkIHN1Y2Nlc3NmdWxseSEnKTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBKU09OIGV4cG9ydCBlcnJvclxuICAgICAgdGhpcy5hcHAuc2hvd0Vycm9yKCdGYWlsZWQgdG8gZXhwb3J0IEpTT04gY29uZmlndXJhdGlvbi4gUGxlYXNlIHRyeSBhZ2Fpbi4nKTtcbiAgICB9XG4gIH1cblxuICBleHBvcnRFeGNlbCgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYXNzZXNzbWVudERhdGEgPSB0aGlzLmFwcC5nZXRBc3Nlc3NtZW50RGF0YSgpO1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZ2V0RXhwb3J0T3B0aW9ucygpO1xuXG4gICAgICAvLyBDcmVhdGUgQ1NWIGNvbnRlbnQgKHNpbXBsaWZpZWQgRXhjZWwgZXhwb3J0KVxuICAgICAgbGV0IGNzdkNvbnRlbnQgPSAnUHJvY2VzcyBOYW1lLENhdGVnb3J5LFJlY29tbWVuZGVkIExldmVsLEVmZm9ydCxDb21wbGV4aXR5LENvbmZpZGVuY2UsUmF0aW9uYWxlXFxuJztcblxuICAgICAgY29uc3QgcmVjb21tZW5kYXRpb25zID0gYXNzZXNzbWVudERhdGEucmVjb21tZW5kYXRpb25zIHx8IHt9O1xuICAgICAgT2JqZWN0LnZhbHVlcyhyZWNvbW1lbmRhdGlvbnMpLmZvckVhY2gocmVjID0+IHtcbiAgICAgICAgY29uc3QgcmF0aW9uYWxlID0gb3B0aW9ucy5pbmNsdWRlUmF0aW9uYWxlXG4gICAgICAgICAgPyByZWMucmF0aW9uYWxlPy5qb2luKCc7ICcpIHx8ICcnXG4gICAgICAgICAgOiAnJztcblxuICAgICAgICBjc3ZDb250ZW50ICs9IGBcIiR7cmVjLnByb2Nlc3NOYW1lfVwiLFwiJHtyZWMuY2F0ZWdvcnl9XCIsXCIke3JlYy5yZWNvbW1lbmRlZExldmVsfVwiLCR7cmVjLmVmZm9ydH0sJHtyZWMuY29tcGxleGl0eX0sJHtNYXRoLnJvdW5kKHJlYy5jb25maWRlbmNlICogMTAwKX0sXCIke3JhdGlvbmFsZX1cIlxcbmA7XG4gICAgICB9KTtcblxuICAgICAgLy8gQWRkIGFzc2Vzc21lbnQgZGF0YSBpZiByZXF1ZXN0ZWRcbiAgICAgIGlmIChvcHRpb25zLmluY2x1ZGVBc3Nlc3NtZW50RGV0YWlscykge1xuICAgICAgICBjc3ZDb250ZW50ICs9ICdcXG5cXG5Bc3Nlc3NtZW50IFJlc3BvbnNlc1xcbic7XG4gICAgICAgIGNzdkNvbnRlbnQgKz0gJ1F1ZXN0aW9uLFJlc3BvbnNlLFNjb3JlLERpbWVuc2lvblxcbic7XG5cbiAgICAgICAgT2JqZWN0LnZhbHVlcyhhc3Nlc3NtZW50RGF0YS5yZXNwb25zZXMgfHwge30pLmZvckVhY2gocmVzcG9uc2UgPT4ge1xuICAgICAgICAgIGNzdkNvbnRlbnQgKz0gYFwiJHtyZXNwb25zZS5xdWVzdGlvbklkfVwiLFwiJHtyZXNwb25zZS5sYWJlbH1cIiwke3Jlc3BvbnNlLnNjb3JlfSxcIiR7cmVzcG9uc2UuZGltZW5zaW9ufVwiXFxuYDtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbY3N2Q29udGVudF0sIHsgdHlwZTogJ3RleHQvY3N2JyB9KTtcbiAgICAgIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cbiAgICAgIGNvbnN0IGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICBhLmhyZWYgPSB1cmw7XG4gICAgICBhLmRvd25sb2FkID0gYFNFX1Byb2Nlc3NfVGFpbG9yaW5nX0FuYWx5c2lzXyR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF19LmNzdmA7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGEpO1xuICAgICAgYS5jbGljaygpO1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChhKTtcbiAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcblxuICAgICAgdGhpcy5hcHAuc2hvd1N1Y2Nlc3MoJ0V4Y2VsL0NTViBmaWxlIGRvd25sb2FkZWQgc3VjY2Vzc2Z1bGx5IScpO1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIEV4Y2VsIGV4cG9ydCBlcnJvclxuICAgICAgdGhpcy5hcHAuc2hvd0Vycm9yKCdGYWlsZWQgdG8gZXhwb3J0IEV4Y2VsIGZpbGUuIFBsZWFzZSB0cnkgYWdhaW4uJyk7XG4gICAgfVxuICB9XG5cbiAgc2hvd0V4cG9ydFByb2dyZXNzKG1lc3NhZ2UpIHtcbiAgICAvLyBTaG93IGxvYWRpbmcgc3RhdGVcbiAgICBjb25zdCBsb2FkaW5nSHRtbCA9IGBcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0ZXh0LWNlbnRlciBweS00XCIgaWQ9XCJleHBvcnQtcHJvZ3Jlc3NcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3Bpbm5lci1ib3JkZXIgdGV4dC1wcmltYXJ5IG1iLTNcIiByb2xlPVwic3RhdHVzXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwidmlzdWFsbHktaGlkZGVuXCI+TG9hZGluZy4uLjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8cCBjbGFzcz1cInRleHQtbXV0ZWRcIj4ke21lc3NhZ2V9PC9wPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIGA7XG5cbiAgICBkb2N1bWVudC5ib2R5Lmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgYFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInBvc2l0aW9uLWZpeGVkIHRvcC0wIHN0YXJ0LTAgdy0xMDAgaC0xMDAgZC1mbGV4IGFsaWduLWl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNvbnRlbnQtY2VudGVyIGJnLWRhcmsgYmctb3BhY2l0eS01MFwiIHN0eWxlPVwiei1pbmRleDogOTk5OTtcIiBpZD1cImV4cG9ydC1vdmVybGF5XCI+XG4gICAgICAgICAgICAgICAgJHtsb2FkaW5nSHRtbH1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICBgKTtcbiAgfVxuXG4gIGhpZGVFeHBvcnRQcm9ncmVzcygpIHtcbiAgICBjb25zdCBvdmVybGF5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2V4cG9ydC1vdmVybGF5Jyk7XG4gICAgaWYgKG92ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkucmVtb3ZlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSGVscGVyIG1ldGhvZHNcbiAgZ2V0TGV2ZWxDb3VudHMocmVjb21tZW5kYXRpb25zKSB7XG4gICAgY29uc3QgY291bnRzID0geyBiYXNpYzogMCwgc3RhbmRhcmQ6IDAsIGNvbXByZWhlbnNpdmU6IDAgfTtcbiAgICBPYmplY3QudmFsdWVzKHJlY29tbWVuZGF0aW9ucykuZm9yRWFjaChyZWMgPT4ge1xuICAgICAgY291bnRzW3JlYy5yZWNvbW1lbmRlZExldmVsXSA9IChjb3VudHNbcmVjLnJlY29tbWVuZGVkTGV2ZWxdIHx8IDApICsgMTtcbiAgICB9KTtcbiAgICByZXR1cm4gY291bnRzO1xuICB9XG5cbiAgZ3JvdXBSZWNvbW1lbmRhdGlvbnNCeUNhdGVnb3J5KHJlY29tbWVuZGF0aW9ucykge1xuICAgIGNvbnN0IGdyb3VwZWQgPSB7fTtcbiAgICBPYmplY3QudmFsdWVzKHJlY29tbWVuZGF0aW9ucykuZm9yRWFjaChyZWMgPT4ge1xuICAgICAgY29uc3QgY2F0ZWdvcnkgPSByZWMuY2F0ZWdvcnkgfHwgJ290aGVyJztcbiAgICAgIGlmICghZ3JvdXBlZFtjYXRlZ29yeV0pIHtcbiAgICAgICAgZ3JvdXBlZFtjYXRlZ29yeV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIGdyb3VwZWRbY2F0ZWdvcnldLnB1c2gocmVjKTtcbiAgICB9KTtcblxuICAgIC8vIFNvcnQgd2l0aGluIGNhdGVnb3JpZXNcbiAgICBPYmplY3Qua2V5cyhncm91cGVkKS5mb3JFYWNoKGNhdGVnb3J5ID0+IHtcbiAgICAgIGdyb3VwZWRbY2F0ZWdvcnldLnNvcnQoKGEsIGIpID0+IGEucHJvY2Vzc05hbWUubG9jYWxlQ29tcGFyZShiLnByb2Nlc3NOYW1lKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZ3JvdXBlZDtcbiAgfVxufVxuXG4vLyBFeHBvcnQgZm9yIGdsb2JhbCBhY2Nlc3NcbndpbmRvdy5FeHBvcnRNYW5hZ2VyID0gRXhwb3J0TWFuYWdlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./js/components/export.js\n\n}");

/***/ }),

/***/ "./js/components/recommendations.js":
/*!******************************************!*\
  !*** ./js/components/recommendations.js ***!
  \******************************************/
/***/ (() => {

eval("{/**\n * Recommendation Engine Component\n * Generates process tailoring recommendations based on assessment scores\n */\n\nclass RecommendationEngine {\n  constructor(processData, dependencyData, app) {\n    this.processData = processData;\n    this.dependencyData = dependencyData;\n    this.app = app;\n    this.recommendations = {};\n  }\n\n  generateRecommendations(assessmentScores) {\n    const processes = this.processData.processes || [];\n    const recommendations = {};\n\n    // Generate base recommendations for each process\n    processes.forEach(process => {\n      recommendations[process.id] = this.calculateProcessLevel(process, assessmentScores);\n    });\n\n    // Apply dependency constraints\n    this.applyDependencyConstraints(recommendations);\n\n    // Apply safety and other constraints\n    this.applyProcessConstraints(recommendations, assessmentScores);\n\n    // Calculate confidence scores\n    this.calculateConfidenceScores(recommendations, assessmentScores);\n\n    this.recommendations = recommendations;\n    return recommendations;\n  }\n\n  calculateProcessLevel(process, scores) {\n    // Base level calculation using weighted assessment scores\n    const baseScore = this.calculateBaseScore(process, scores);\n\n    // Determine level based on score thresholds\n    let level = 'basic';\n    if (baseScore >= 3.6) {\n      level = 'comprehensive';\n    } else if (baseScore >= 2.1) {\n      level = 'standard';\n    }\n\n    return {\n      processId: process.id,\n      processName: process.name,\n      category: process.category,\n      recommendedLevel: level,\n      baseScore: baseScore,\n      rationale: this.generateRationale(process, scores, level),\n      effort: process.tailoringLevels[level]?.effort || 1,\n      complexity: process.tailoringLevels[level]?.complexity || 1,\n      activities: process.tailoringLevels[level]?.activities || [],\n      outputs: process.tailoringLevels[level]?.outputs || [],\n      dependencies: [],\n      constraints: [],\n      confidence: 0.8, // Will be calculated later\n    };\n  }\n\n  calculateBaseScore(process, scores) {\n    // Process-specific scoring weights based on category\n    const weights = this.getProcessWeights(process);\n\n    // Calculate weighted score\n    let weightedScore = 0;\n    let totalWeight = 0;\n\n    Object.keys(weights).forEach(dimension => {\n      if (scores[dimension] !== undefined) {\n        weightedScore += scores[dimension] * weights[dimension];\n        totalWeight += weights[dimension];\n      }\n    });\n\n    return totalWeight > 0 ? weightedScore / totalWeight : 0;\n  }\n\n  getProcessWeights(process) {\n    // Default weights - can be customized per process\n    const defaultWeights = {\n      complexity: 0.3,\n      safety: 0.25,\n      scale: 0.25,\n      maturity: 0.2,\n    };\n\n    // Process-specific weight adjustments\n    const adjustments = {\n      // Safety-critical processes weight safety more heavily\n      'risk_management': { safety: 0.4, complexity: 0.25, scale: 0.2, maturity: 0.15 },\n      'quality_assurance': { safety: 0.35, complexity: 0.25, scale: 0.2, maturity: 0.2 },\n      'verification': { safety: 0.35, complexity: 0.3, scale: 0.2, maturity: 0.15 },\n      'validation': { safety: 0.35, complexity: 0.25, scale: 0.2, maturity: 0.2 },\n\n      // Technical processes weight complexity more heavily\n      'system_analysis': { complexity: 0.4, safety: 0.2, scale: 0.25, maturity: 0.15 },\n      'architecture_definition': { complexity: 0.4, safety: 0.2, scale: 0.25, maturity: 0.15 },\n      'design_definition': { complexity: 0.4, safety: 0.2, scale: 0.25, maturity: 0.15 },\n\n      // Management processes weight scale and maturity more heavily\n      'project_planning': { scale: 0.35, maturity: 0.25, complexity: 0.2, safety: 0.2 },\n      'project_assessment_control': { scale: 0.35, maturity: 0.25, complexity: 0.2, safety: 0.2 },\n      'configuration_management': { scale: 0.3, maturity: 0.3, complexity: 0.2, safety: 0.2 },\n    };\n\n    return adjustments[process.id] || defaultWeights;\n  }\n\n  applyDependencyConstraints(recommendations) {\n    const dependencies = this.dependencyData.dependencies || [];\n    let changed = true;\n    let iterations = 0;\n    const maxIterations = 10; // Prevent infinite loops\n\n    // Iteratively apply constraints until no more changes\n    while (changed && iterations < maxIterations) {\n      changed = false;\n      iterations++;\n\n      dependencies.forEach(dep => {\n        const sourceRec = recommendations[dep.source];\n        const targetRec = recommendations[dep.target];\n\n        if (sourceRec && targetRec) {\n          const sourceLevel = this.getLevelValue(sourceRec.recommendedLevel);\n          const requiredTargetLevel = this.getLevelValue(dep.targetLevel);\n          const currentTargetLevel = this.getLevelValue(targetRec.recommendedLevel);\n\n          // If source is at the specified level and target is below required minimum\n          if (sourceLevel >= this.getLevelValue(dep.sourceLevel) &&\n                        currentTargetLevel < requiredTargetLevel) {\n\n            const newLevel = dep.targetLevel;\n            targetRec.recommendedLevel = newLevel;\n            targetRec.effort = this.processData.processes.find(p => p.id === dep.target)?.tailoringLevels[newLevel]?.effort || targetRec.effort;\n            targetRec.complexity = this.processData.processes.find(p => p.id === dep.target)?.tailoringLevels[newLevel]?.complexity || targetRec.complexity;\n\n            // Add dependency constraint to rationale\n            targetRec.constraints.push({\n              type: 'dependency',\n              source: dep.source,\n              sourceLevel: dep.sourceLevel,\n              reason: `Required by ${sourceRec.processName} at ${dep.sourceLevel} level`,\n            });\n\n            // Track the dependency\n            sourceRec.dependencies.push({\n              target: dep.target,\n              targetName: targetRec.processName,\n              requiredLevel: dep.targetLevel,\n              type: dep.type || 'horizontal',\n            });\n\n            changed = true;\n          }\n        }\n      });\n    }\n\n    if (iterations >= maxIterations) {\n      // Dependency constraint resolution reached maximum iterations\n    }\n  }\n\n  applyProcessConstraints(recommendations, scores) {\n    const processes = this.processData.processes || [];\n\n    processes.forEach(process => {\n      const rec = recommendations[process.id];\n      if (!rec || !process.constraints) return;\n\n      process.constraints.forEach(constraint => {\n        if (this.evaluateConstraintCondition(constraint.condition, scores)) {\n          const requiredLevel = constraint.requiredLevel;\n          const currentLevel = this.getLevelValue(rec.recommendedLevel);\n          const requiredLevelValue = this.getLevelValue(requiredLevel);\n\n          if (currentLevel < requiredLevelValue) {\n            rec.recommendedLevel = requiredLevel;\n            rec.effort = process.tailoringLevels[requiredLevel]?.effort || rec.effort;\n            rec.complexity = process.tailoringLevels[requiredLevel]?.complexity || rec.complexity;\n\n            rec.constraints.push({\n              type: 'process',\n              condition: constraint.condition,\n              reason: constraint.rationale || 'Process constraint applied',\n            });\n          }\n        }\n      });\n    });\n  }\n\n  evaluateConstraintCondition(condition, scores) {\n    try {\n      // Simple condition evaluation - extend as needed\n      // Example: \"safety_criticality > 3\"\n      const match = condition.match(/(\\w+)\\s*([><=]+)\\s*(\\d+\\.?\\d*)/);\n      if (match) {\n        const [, dimension, operator, threshold] = match;\n        const score = scores[dimension];\n        const thresholdValue = parseFloat(threshold);\n\n        switch (operator) {\n          case '>': return score > thresholdValue;\n          case '>=': return score >= thresholdValue;\n          case '<': return score < thresholdValue;\n          case '<=': return score <= thresholdValue;\n          case '=': case '==': return Math.abs(score - thresholdValue) < 0.1;\n          default: return false;\n        }\n      }\n    } catch (error) {\n      // Failed to evaluate constraint condition\n    }\n    return false;\n  }\n\n  calculateConfidenceScores(recommendations, scores) {\n    Object.values(recommendations).forEach(rec => {\n      let confidence = 0.8; // Base confidence\n\n      // Reduce confidence if score is near threshold boundaries\n      const baseScore = rec.baseScore;\n      if ((baseScore >= 2.0 && baseScore <= 2.2) || (baseScore >= 3.5 && baseScore <= 3.7)) {\n        confidence -= 0.2;\n      }\n\n      // Reduce confidence if conflicting constraints\n      if (rec.constraints.length > 2) {\n        confidence -= 0.1;\n      }\n\n      // Increase confidence if multiple factors align\n      const extremeScores = Object.values(scores).filter(s => s <= 1.5 || s >= 4.5).length;\n      if (extremeScores >= 2) {\n        confidence += 0.1;\n      }\n\n      rec.confidence = Math.max(0.4, Math.min(1.0, confidence));\n    });\n  }\n\n  getLevelValue(level) {\n    const values = { 'basic': 1, 'standard': 2, 'comprehensive': 3 };\n    return values[level] || 1;\n  }\n\n  generateRationale(process, scores, level) {\n    const rationale = [];\n    const weights = this.getProcessWeights(process);\n\n    // Primary drivers\n    const primaryFactors = Object.keys(weights)\n      .map(dim => ({ dimension: dim, weight: weights[dim], score: scores[dim] }))\n      .sort((a, b) => b.weight - a.weight)\n      .slice(0, 2);\n\n    primaryFactors.forEach(factor => {\n      const impact = this.getScoreImpact(factor.score);\n      rationale.push(`${this.getDimensionName(factor.dimension)} (${factor.score.toFixed(1)}/5.0) ${impact.description}`);\n    });\n\n    // Level justification\n    switch (level) {\n      case 'basic':\n        rationale.push('Basic level recommended for low complexity and risk profile');\n        break;\n      case 'standard':\n        rationale.push('Standard level provides balanced formality for moderate complexity');\n        break;\n      case 'comprehensive':\n        rationale.push('Comprehensive level required for high complexity and criticality');\n        break;\n    }\n\n    return rationale;\n  }\n\n  getDimensionName(dimension) {\n    const names = {\n      complexity: 'Technical Complexity',\n      safety: 'Safety Criticality',\n      scale: 'Project Scale',\n      maturity: 'Organizational Maturity',\n    };\n    return names[dimension] || dimension;\n  }\n\n  getScoreImpact(score) {\n    if (score <= 2.0) return { level: 'low', description: 'suggests minimal formality' };\n    if (score <= 3.5) return { level: 'medium', description: 'indicates moderate formality needed' };\n    return { level: 'high', description: 'requires high formality and rigor' };\n  }\n\n  render() {\n    const container = document.getElementById('recommendations-content');\n    if (!container) return;\n\n    const assessmentData = this.app.getAssessmentData();\n\n    if (!assessmentData.recommendations || Object.keys(assessmentData.recommendations).length === 0) {\n      this.renderNoRecommendations(container);\n      return;\n    }\n\n    this.renderRecommendations(container, assessmentData);\n  }\n\n  renderNoRecommendations(container) {\n    container.innerHTML = `\n            <div class=\"text-center py-5\">\n                <div class=\"card\">\n                    <div class=\"card-body\">\n                        <i class=\"bi bi-exclamation-circle display-1 text-warning mb-3\"></i>\n                        <h3>No Recommendations Available</h3>\n                        <p class=\"text-muted mb-4\">\n                            Complete the assessment first to generate personalized process tailoring recommendations.\n                        </p>\n                        <button class=\"btn btn-primary\" onclick=\"window.seApp.showView('assessment')\">\n                            <i class=\"bi bi-clipboard-check\"></i>\n                            Start Assessment\n                        </button>\n                    </div>\n                </div>\n            </div>\n        `;\n  }\n\n  renderRecommendations(container, assessmentData) {\n    const recommendations = assessmentData.recommendations;\n\n    // Group recommendations by category\n    const groupedRecs = this.groupRecommendationsByCategory(recommendations);\n\n    // Calculate summary statistics\n    const stats = this.calculateSummaryStats(recommendations);\n\n    const html = `\n            <div class=\"mb-4\">\n                <div class=\"card shadow-sm\">\n                    <div class=\"card-header bg-gradient-primary text-white\">\n                        <h4 class=\"card-title mb-0\">\n                            <i class=\"bi bi-lightbulb-fill\"></i>\n                            Process Tailoring Recommendations\n                        </h4>\n                    </div>\n                    <div class=\"card-body\">\n                        <div class=\"row mb-4\">\n                            <div class=\"col-md-3\">\n                                <div class=\"stat-card border-start-primary\">\n                                    <span class=\"stat-number text-success\">${stats.basic}</span>\n                                    <span class=\"stat-label\">Basic Level</span>\n                                </div>\n                            </div>\n                            <div class=\"col-md-3\">\n                                <div class=\"stat-card border-start-warning\">\n                                    <span class=\"stat-number text-warning\">${stats.standard}</span>\n                                    <span class=\"stat-label\">Standard Level</span>\n                                </div>\n                            </div>\n                            <div class=\"col-md-3\">\n                                <div class=\"stat-card border-start-danger\">\n                                    <span class=\"stat-number text-danger\">${stats.comprehensive}</span>\n                                    <span class=\"stat-label\">Comprehensive Level</span>\n                                </div>\n                            </div>\n                            <div class=\"col-md-3\">\n                                <div class=\"stat-card\">\n                                    <span class=\"stat-number\">${stats.totalEffort}</span>\n                                    <span class=\"stat-label\">Total Effort Score</span>\n                                </div>\n                            </div>\n                        </div>\n                        \n                        <div class=\"alert alert-info\">\n                            <i class=\"bi bi-info-circle me-2\"></i>\n                            <strong>Implementation Guidance:</strong> Start with high-priority processes and gradually implement others. \n                            Pay special attention to dependency relationships shown in the visualization.\n                        </div>\n                    </div>\n                </div>\n            </div>\n\n            ${Object.keys(groupedRecs).map(category => this.renderCategorySection(category, groupedRecs[category])).join('')}\n        `;\n\n    container.innerHTML = html;\n    this.attachRecommendationEventListeners();\n  }\n\n  groupRecommendationsByCategory(recommendations) {\n    const grouped = {};\n\n    Object.values(recommendations).forEach(rec => {\n      const category = rec.category || 'other';\n      if (!grouped[category]) {\n        grouped[category] = [];\n      }\n      grouped[category].push(rec);\n    });\n\n    // Sort processes within each category by name\n    Object.keys(grouped).forEach(category => {\n      grouped[category].sort((a, b) => a.processName.localeCompare(b.processName));\n    });\n\n    return grouped;\n  }\n\n  renderCategorySection(category, processes) {\n    const categoryName = this.processData.processCategories?.[category] || category;\n\n    return `\n            <div class=\"mb-4\">\n                <h5 class=\"mb-3\">\n                    <i class=\"bi bi-${this.getCategoryIcon(category)}\"></i>\n                    ${categoryName}\n                </h5>\n                <div class=\"row\">\n                    ${processes.map(process => this.renderProcessCard(process)).join('')}\n                </div>\n            </div>\n        `;\n  }\n\n  renderProcessCard(process) {\n    const levelClass = process.recommendedLevel;\n    const confidencePercent = Math.round(process.confidence * 100);\n\n    return `\n            <div class=\"col-lg-6 mb-3\">\n                <div class=\"process-card card ${levelClass}\">\n                    <div class=\"card-body\">\n                        <div class=\"d-flex justify-content-between align-items-start mb-2\">\n                            <h6 class=\"process-title mb-1\">${process.processName}</h6>\n                            <span class=\"level-badge level-${levelClass}\">${process.recommendedLevel}</span>\n                        </div>\n                        \n                        <div class=\"mb-2\">\n                            <small class=\"text-muted\">\n                                Effort: <strong>${process.effort}</strong> | \n                                Complexity: <strong>${process.complexity}</strong> | \n                                Confidence: <strong>${confidencePercent}%</strong>\n                            </small>\n                        </div>\n\n                        <div class=\"mb-3\">\n                            <strong>Rationale:</strong>\n                            <ul class=\"list-unstyled mt-1 mb-0\">\n                                ${process.rationale.map(reason => `<li class=\"text-small text-muted\">â€¢ ${reason}</li>`).join('')}\n                            </ul>\n                        </div>\n\n                        ${process.constraints.length > 0 ? `\n                            <div class=\"mb-3\">\n                                <strong>Constraints Applied:</strong>\n                                <ul class=\"list-unstyled mt-1 mb-0\">\n                                    ${process.constraints.map(constraint => `\n                                        <li class=\"text-small text-warning\">â€¢ ${constraint.reason}</li>\n                                    `).join('')}\n                                </ul>\n                            </div>\n                        ` : ''}\n\n                        ${process.dependencies.length > 0 ? `\n                            <div class=\"mb-3\">\n                                <strong>Dependencies:</strong>\n                                <ul class=\"dependency-list\">\n                                    ${process.dependencies.map(dep => `\n                                        <li class=\"dependency-item ${dep.type === 'vertical' ? 'critical' : 'important'}\">\n                                            <small>\n                                                <strong>${dep.targetName}</strong> requires <em>${dep.requiredLevel}</em> level\n                                                <span class=\"badge badge-sm bg-secondary ms-1\">${dep.type}</span>\n                                            </small>\n                                        </li>\n                                    `).join('')}\n                                </ul>\n                            </div>\n                        ` : ''}\n\n                        <div class=\"text-end\">\n                            <button class=\"btn btn-outline-primary btn-sm\" onclick=\"window.seApp.showProcessDetails('${process.processId}')\">\n                                <i class=\"bi bi-info-circle\"></i>\n                                Details\n                            </button>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        `;\n  }\n\n  calculateSummaryStats(recommendations) {\n    const stats = {\n      basic: 0,\n      standard: 0,\n      comprehensive: 0,\n      totalEffort: 0,\n      averageConfidence: 0,\n    };\n\n    const recs = Object.values(recommendations);\n\n    recs.forEach(rec => {\n      stats[rec.recommendedLevel]++;\n      stats.totalEffort += rec.effort || 0;\n    });\n\n    stats.averageConfidence = recs.length > 0\n      ? recs.reduce((sum, rec) => sum + rec.confidence, 0) / recs.length\n      : 0;\n\n    return stats;\n  }\n\n  getCategoryIcon(category) {\n    const icons = {\n      'technical_management': 'gear',\n      'technical': 'cpu',\n      'other': 'circle',\n    };\n    return icons[category] || 'circle';\n  }\n\n  attachRecommendationEventListeners() {\n    // Add any interactive event listeners here\n    // Currently handled through onclick attributes in the HTML\n  }\n\n  // Public methods for app integration\n  getRecommendations() {\n    return this.recommendations;\n  }\n\n  getProcessRecommendation(processId) {\n    return this.recommendations[processId];\n  }\n}\n\n// Export for global access\nwindow.RecommendationEngine = RecommendationEngine;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9jb21wb25lbnRzL3JlY29tbWVuZGF0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJEQUEyRDtBQUN0Riw2QkFBNkIsMkRBQTJEO0FBQ3hGLHdCQUF3QiwyREFBMkQ7QUFDbkYsc0JBQXNCLDJEQUEyRDs7QUFFakY7QUFDQSwyQkFBMkIsMkRBQTJEO0FBQ3RGLG1DQUFtQywyREFBMkQ7QUFDOUYsNkJBQTZCLDJEQUEyRDs7QUFFeEY7QUFDQSw0QkFBNEIsMkRBQTJEO0FBQ3ZGLHNDQUFzQywyREFBMkQ7QUFDakcsb0NBQW9DLHlEQUF5RDtBQUM3Rjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsdUJBQXVCLEtBQUssaUJB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Q2xHO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMscUVBQXFFLG1EQUFtRDtBQUN4SDtBQUNBLDBEQUEwRCxlQUFlLHlCQUF5QixrQkFBa0I7QUFDcEgsaUdBQWlHLFNBQVM7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUhBQXVILGtCQUFrQjtBQUN6STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NlLXRhaWxvcmluZy1mcmFtZXdvcmsvLi9qcy9jb21wb25lbnRzL3JlY29tbWVuZGF0aW9ucy5qcz9jYmUwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmVjb21tZW5kYXRpb24gRW5naW5lIENvbXBvbmVudFxuICogR2VuZXJhdGVzIHByb2Nlc3MgdGFpbG9yaW5nIHJlY29tbWVuZGF0aW9ucyBiYXNlZCBvbiBhc3Nlc3NtZW50IHNjb3Jlc1xuICovXG5cbmNsYXNzIFJlY29tbWVuZGF0aW9uRW5naW5lIHtcbiAgY29uc3RydWN0b3IocHJvY2Vzc0RhdGEsIGRlcGVuZGVuY3lEYXRhLCBhcHApIHtcbiAgICB0aGlzLnByb2Nlc3NEYXRhID0gcHJvY2Vzc0RhdGE7XG4gICAgdGhpcy5kZXBlbmRlbmN5RGF0YSA9IGRlcGVuZGVuY3lEYXRhO1xuICAgIHRoaXMuYXBwID0gYXBwO1xuICAgIHRoaXMucmVjb21tZW5kYXRpb25zID0ge307XG4gIH1cblxuICBnZW5lcmF0ZVJlY29tbWVuZGF0aW9ucyhhc3Nlc3NtZW50U2NvcmVzKSB7XG4gICAgY29uc3QgcHJvY2Vzc2VzID0gdGhpcy5wcm9jZXNzRGF0YS5wcm9jZXNzZXMgfHwgW107XG4gICAgY29uc3QgcmVjb21tZW5kYXRpb25zID0ge307XG5cbiAgICAvLyBHZW5lcmF0ZSBiYXNlIHJlY29tbWVuZGF0aW9ucyBmb3IgZWFjaCBwcm9jZXNzXG4gICAgcHJvY2Vzc2VzLmZvckVhY2gocHJvY2VzcyA9PiB7XG4gICAgICByZWNvbW1lbmRhdGlvbnNbcHJvY2Vzcy5pZF0gPSB0aGlzLmNhbGN1bGF0ZVByb2Nlc3NMZXZlbChwcm9jZXNzLCBhc3Nlc3NtZW50U2NvcmVzKTtcbiAgICB9KTtcblxuICAgIC8vIEFwcGx5IGRlcGVuZGVuY3kgY29uc3RyYWludHNcbiAgICB0aGlzLmFwcGx5RGVwZW5kZW5jeUNvbnN0cmFpbnRzKHJlY29tbWVuZGF0aW9ucyk7XG5cbiAgICAvLyBBcHBseSBzYWZldHkgYW5kIG90aGVyIGNvbnN0cmFpbnRzXG4gICAgdGhpcy5hcHBseVByb2Nlc3NDb25zdHJhaW50cyhyZWNvbW1lbmRhdGlvbnMsIGFzc2Vzc21lbnRTY29yZXMpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIGNvbmZpZGVuY2Ugc2NvcmVzXG4gICAgdGhpcy5jYWxjdWxhdGVDb25maWRlbmNlU2NvcmVzKHJlY29tbWVuZGF0aW9ucywgYXNzZXNzbWVudFNjb3Jlcyk7XG5cbiAgICB0aGlzLnJlY29tbWVuZGF0aW9ucyA9IHJlY29tbWVuZGF0aW9ucztcbiAgICByZXR1cm4gcmVjb21tZW5kYXRpb25zO1xuICB9XG5cbiAgY2FsY3VsYXRlUHJvY2Vzc0xldmVsKHByb2Nlc3MsIHNjb3Jlcykge1xuICAgIC8vIEJhc2UgbGV2ZWwgY2FsY3VsYXRpb24gdXNpbmcgd2VpZ2h0ZWQgYXNzZXNzbWVudCBzY29yZXNcbiAgICBjb25zdCBiYXNlU2NvcmUgPSB0aGlzLmNhbGN1bGF0ZUJhc2VTY29yZShwcm9jZXNzLCBzY29yZXMpO1xuXG4gICAgLy8gRGV0ZXJtaW5lIGxldmVsIGJhc2VkIG9uIHNjb3JlIHRocmVzaG9sZHNcbiAgICBsZXQgbGV2ZWwgPSAnYmFzaWMnO1xuICAgIGlmIChiYXNlU2NvcmUgPj0gMy42KSB7XG4gICAgICBsZXZlbCA9ICdjb21wcmVoZW5zaXZlJztcbiAgICB9IGVsc2UgaWYgKGJhc2VTY29yZSA+PSAyLjEpIHtcbiAgICAgIGxldmVsID0gJ3N0YW5kYXJkJztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcHJvY2Vzc0lkOiBwcm9jZXNzLmlkLFxuICAgICAgcHJvY2Vzc05hbWU6IHByb2Nlc3MubmFtZSxcbiAgICAgIGNhdGVnb3J5OiBwcm9jZXNzLmNhdGVnb3J5LFxuICAgICAgcmVjb21tZW5kZWRMZXZlbDogbGV2ZWwsXG4gICAgICBiYXNlU2NvcmU6IGJhc2VTY29yZSxcbiAgICAgIHJhdGlvbmFsZTogdGhpcy5nZW5lcmF0ZVJhdGlvbmFsZShwcm9jZXNzLCBzY29yZXMsIGxldmVsKSxcbiAgICAgIGVmZm9ydDogcHJvY2Vzcy50YWlsb3JpbmdMZXZlbHNbbGV2ZWxdPy5lZmZvcnQgfHwgMSxcbiAgICAgIGNvbXBsZXhpdHk6IHByb2Nlc3MudGFpbG9yaW5nTGV2ZWxzW2xldmVsXT8uY29tcGxleGl0eSB8fCAxLFxuICAgICAgYWN0aXZpdGllczogcHJvY2Vzcy50YWlsb3JpbmdMZXZlbHNbbGV2ZWxdPy5hY3Rpdml0aWVzIHx8IFtdLFxuICAgICAgb3V0cHV0czogcHJvY2Vzcy50YWlsb3JpbmdMZXZlbHNbbGV2ZWxdPy5vdXRwdXRzIHx8IFtdLFxuICAgICAgZGVwZW5kZW5jaWVzOiBbXSxcbiAgICAgIGNvbnN0cmFpbnRzOiBbXSxcbiAgICAgIGNvbmZpZGVuY2U6IDAuOCwgLy8gV2lsbCBiZSBjYWxjdWxhdGVkIGxhdGVyXG4gICAgfTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUJhc2VTY29yZShwcm9jZXNzLCBzY29yZXMpIHtcbiAgICAvLyBQcm9jZXNzLXNwZWNpZmljIHNjb3Jpbmcgd2VpZ2h0cyBiYXNlZCBvbiBjYXRlZ29yeVxuICAgIGNvbnN0IHdlaWdodHMgPSB0aGlzLmdldFByb2Nlc3NXZWlnaHRzKHByb2Nlc3MpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHdlaWdodGVkIHNjb3JlXG4gICAgbGV0IHdlaWdodGVkU2NvcmUgPSAwO1xuICAgIGxldCB0b3RhbFdlaWdodCA9IDA7XG5cbiAgICBPYmplY3Qua2V5cyh3ZWlnaHRzKS5mb3JFYWNoKGRpbWVuc2lvbiA9PiB7XG4gICAgICBpZiAoc2NvcmVzW2RpbWVuc2lvbl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3ZWlnaHRlZFNjb3JlICs9IHNjb3Jlc1tkaW1lbnNpb25dICogd2VpZ2h0c1tkaW1lbnNpb25dO1xuICAgICAgICB0b3RhbFdlaWdodCArPSB3ZWlnaHRzW2RpbWVuc2lvbl07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdG90YWxXZWlnaHQgPiAwID8gd2VpZ2h0ZWRTY29yZSAvIHRvdGFsV2VpZ2h0IDogMDtcbiAgfVxuXG4gIGdldFByb2Nlc3NXZWlnaHRzKHByb2Nlc3MpIHtcbiAgICAvLyBEZWZhdWx0IHdlaWdodHMgLSBjYW4gYmUgY3VzdG9taXplZCBwZXIgcHJvY2Vzc1xuICAgIGNvbnN0IGRlZmF1bHRXZWlnaHRzID0ge1xuICAgICAgY29tcGxleGl0eTogMC4zLFxuICAgICAgc2FmZXR5OiAwLjI1LFxuICAgICAgc2NhbGU6IDAuMjUsXG4gICAgICBtYXR1cml0eTogMC4yLFxuICAgIH07XG5cbiAgICAvLyBQcm9jZXNzLXNwZWNpZmljIHdlaWdodCBhZGp1c3RtZW50c1xuICAgIGNvbnN0IGFkanVzdG1lbnRzID0ge1xuICAgICAgLy8gU2FmZXR5LWNyaXRpY2FsIHByb2Nlc3NlcyB3ZWlnaHQgc2FmZXR5IG1vcmUgaGVhdmlseVxuICAgICAgJ3Jpc2tfbWFuYWdlbWVudCc6IHsgc2FmZXR5OiAwLjQsIGNvbXBsZXhpdHk6IDAuMjUsIHNjYWxlOiAwLjIsIG1hdHVyaXR5OiAwLjE1IH0sXG4gICAgICAncXVhbGl0eV9hc3N1cmFuY2UnOiB7IHNhZmV0eTogMC4zNSwgY29tcGxleGl0eTogMC4yNSwgc2NhbGU6IDAuMiwgbWF0dXJpdHk6IDAuMiB9LFxuICAgICAgJ3ZlcmlmaWNhdGlvbic6IHsgc2FmZXR5OiAwLjM1LCBjb21wbGV4aXR5OiAwLjMsIHNjYWxlOiAwLjIsIG1hdHVyaXR5OiAwLjE1IH0sXG4gICAgICAndmFsaWRhdGlvbic6IHsgc2FmZXR5OiAwLjM1LCBjb21wbGV4aXR5OiAwLjI1LCBzY2FsZTogMC4yLCBtYXR1cml0eTogMC4yIH0sXG5cbiAgICAgIC8vIFRlY2huaWNhbCBwcm9jZXNzZXMgd2VpZ2h0IGNvbXBsZXhpdHkgbW9yZSBoZWF2aWx5XG4gICAgICAnc3lzdGVtX2FuYWx5c2lzJzogeyBjb21wbGV4aXR5OiAwLjQsIHNhZmV0eTogMC4yLCBzY2FsZTogMC4yNSwgbWF0dXJpdHk6IDAuMTUgfSxcbiAgICAgICdhcmNoaXRlY3R1cmVfZGVmaW5pdGlvbic6IHsgY29tcGxleGl0eTogMC40LCBzYWZldHk6IDAuMiwgc2NhbGU6IDAuMjUsIG1hdHVyaXR5OiAwLjE1IH0sXG4gICAgICAnZGVzaWduX2RlZmluaXRpb24nOiB7IGNvbXBsZXhpdHk6IDAuNCwgc2FmZXR5OiAwLjIsIHNjYWxlOiAwLjI1LCBtYXR1cml0eTogMC4xNSB9LFxuXG4gICAgICAvLyBNYW5hZ2VtZW50IHByb2Nlc3NlcyB3ZWlnaHQgc2NhbGUgYW5kIG1hdHVyaXR5IG1vcmUgaGVhdmlseVxuICAgICAgJ3Byb2plY3RfcGxhbm5pbmcnOiB7IHNjYWxlOiAwLjM1LCBtYXR1cml0eTogMC4yNSwgY29tcGxleGl0eTogMC4yLCBzYWZldHk6IDAuMiB9LFxuICAgICAgJ3Byb2plY3RfYXNzZXNzbWVudF9jb250cm9sJzogeyBzY2FsZTogMC4zNSwgbWF0dXJpdHk6IDAuMjUsIGNvbXBsZXhpdHk6IDAuMiwgc2FmZXR5OiAwLjIgfSxcbiAgICAgICdjb25maWd1cmF0aW9uX21hbmFnZW1lbnQnOiB7IHNjYWxlOiAwLjMsIG1hdHVyaXR5OiAwLjMsIGNvbXBsZXhpdHk6IDAuMiwgc2FmZXR5OiAwLjIgfSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIGFkanVzdG1lbnRzW3Byb2Nlc3MuaWRdIHx8IGRlZmF1bHRXZWlnaHRzO1xuICB9XG5cbiAgYXBwbHlEZXBlbmRlbmN5Q29uc3RyYWludHMocmVjb21tZW5kYXRpb25zKSB7XG4gICAgY29uc3QgZGVwZW5kZW5jaWVzID0gdGhpcy5kZXBlbmRlbmN5RGF0YS5kZXBlbmRlbmNpZXMgfHwgW107XG4gICAgbGV0IGNoYW5nZWQgPSB0cnVlO1xuICAgIGxldCBpdGVyYXRpb25zID0gMDtcbiAgICBjb25zdCBtYXhJdGVyYXRpb25zID0gMTA7IC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcHNcblxuICAgIC8vIEl0ZXJhdGl2ZWx5IGFwcGx5IGNvbnN0cmFpbnRzIHVudGlsIG5vIG1vcmUgY2hhbmdlc1xuICAgIHdoaWxlIChjaGFuZ2VkICYmIGl0ZXJhdGlvbnMgPCBtYXhJdGVyYXRpb25zKSB7XG4gICAgICBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICBpdGVyYXRpb25zKys7XG5cbiAgICAgIGRlcGVuZGVuY2llcy5mb3JFYWNoKGRlcCA9PiB7XG4gICAgICAgIGNvbnN0IHNvdXJjZVJlYyA9IHJlY29tbWVuZGF0aW9uc1tkZXAuc291cmNlXTtcbiAgICAgICAgY29uc3QgdGFyZ2V0UmVjID0gcmVjb21tZW5kYXRpb25zW2RlcC50YXJnZXRdO1xuXG4gICAgICAgIGlmIChzb3VyY2VSZWMgJiYgdGFyZ2V0UmVjKSB7XG4gICAgICAgICAgY29uc3Qgc291cmNlTGV2ZWwgPSB0aGlzLmdldExldmVsVmFsdWUoc291cmNlUmVjLnJlY29tbWVuZGVkTGV2ZWwpO1xuICAgICAgICAgIGNvbnN0IHJlcXVpcmVkVGFyZ2V0TGV2ZWwgPSB0aGlzLmdldExldmVsVmFsdWUoZGVwLnRhcmdldExldmVsKTtcbiAgICAgICAgICBjb25zdCBjdXJyZW50VGFyZ2V0TGV2ZWwgPSB0aGlzLmdldExldmVsVmFsdWUodGFyZ2V0UmVjLnJlY29tbWVuZGVkTGV2ZWwpO1xuXG4gICAgICAgICAgLy8gSWYgc291cmNlIGlzIGF0IHRoZSBzcGVjaWZpZWQgbGV2ZWwgYW5kIHRhcmdldCBpcyBiZWxvdyByZXF1aXJlZCBtaW5pbXVtXG4gICAgICAgICAgaWYgKHNvdXJjZUxldmVsID49IHRoaXMuZ2V0TGV2ZWxWYWx1ZShkZXAuc291cmNlTGV2ZWwpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGFyZ2V0TGV2ZWwgPCByZXF1aXJlZFRhcmdldExldmVsKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IG5ld0xldmVsID0gZGVwLnRhcmdldExldmVsO1xuICAgICAgICAgICAgdGFyZ2V0UmVjLnJlY29tbWVuZGVkTGV2ZWwgPSBuZXdMZXZlbDtcbiAgICAgICAgICAgIHRhcmdldFJlYy5lZmZvcnQgPSB0aGlzLnByb2Nlc3NEYXRhLnByb2Nlc3Nlcy5maW5kKHAgPT4gcC5pZCA9PT0gZGVwLnRhcmdldCk/LnRhaWxvcmluZ0xldmVsc1tuZXdMZXZlbF0/LmVmZm9ydCB8fCB0YXJnZXRSZWMuZWZmb3J0O1xuICAgICAgICAgICAgdGFyZ2V0UmVjLmNvbXBsZXhpdHkgPSB0aGlzLnByb2Nlc3NEYXRhLnByb2Nlc3Nlcy5maW5kKHAgPT4gcC5pZCA9PT0gZGVwLnRhcmdldCk/LnRhaWxvcmluZ0xldmVsc1tuZXdMZXZlbF0/LmNvbXBsZXhpdHkgfHwgdGFyZ2V0UmVjLmNvbXBsZXhpdHk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBkZXBlbmRlbmN5IGNvbnN0cmFpbnQgdG8gcmF0aW9uYWxlXG4gICAgICAgICAgICB0YXJnZXRSZWMuY29uc3RyYWludHMucHVzaCh7XG4gICAgICAgICAgICAgIHR5cGU6ICdkZXBlbmRlbmN5JyxcbiAgICAgICAgICAgICAgc291cmNlOiBkZXAuc291cmNlLFxuICAgICAgICAgICAgICBzb3VyY2VMZXZlbDogZGVwLnNvdXJjZUxldmVsLFxuICAgICAgICAgICAgICByZWFzb246IGBSZXF1aXJlZCBieSAke3NvdXJjZVJlYy5wcm9jZXNzTmFtZX0gYXQgJHtkZXAuc291cmNlTGV2ZWx9IGxldmVsYCxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBUcmFjayB0aGUgZGVwZW5kZW5jeVxuICAgICAgICAgICAgc291cmNlUmVjLmRlcGVuZGVuY2llcy5wdXNoKHtcbiAgICAgICAgICAgICAgdGFyZ2V0OiBkZXAudGFyZ2V0LFxuICAgICAgICAgICAgICB0YXJnZXROYW1lOiB0YXJnZXRSZWMucHJvY2Vzc05hbWUsXG4gICAgICAgICAgICAgIHJlcXVpcmVkTGV2ZWw6IGRlcC50YXJnZXRMZXZlbCxcbiAgICAgICAgICAgICAgdHlwZTogZGVwLnR5cGUgfHwgJ2hvcml6b250YWwnLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGl0ZXJhdGlvbnMgPj0gbWF4SXRlcmF0aW9ucykge1xuICAgICAgLy8gRGVwZW5kZW5jeSBjb25zdHJhaW50IHJlc29sdXRpb24gcmVhY2hlZCBtYXhpbXVtIGl0ZXJhdGlvbnNcbiAgICB9XG4gIH1cblxuICBhcHBseVByb2Nlc3NDb25zdHJhaW50cyhyZWNvbW1lbmRhdGlvbnMsIHNjb3Jlcykge1xuICAgIGNvbnN0IHByb2Nlc3NlcyA9IHRoaXMucHJvY2Vzc0RhdGEucHJvY2Vzc2VzIHx8IFtdO1xuXG4gICAgcHJvY2Vzc2VzLmZvckVhY2gocHJvY2VzcyA9PiB7XG4gICAgICBjb25zdCByZWMgPSByZWNvbW1lbmRhdGlvbnNbcHJvY2Vzcy5pZF07XG4gICAgICBpZiAoIXJlYyB8fCAhcHJvY2Vzcy5jb25zdHJhaW50cykgcmV0dXJuO1xuXG4gICAgICBwcm9jZXNzLmNvbnN0cmFpbnRzLmZvckVhY2goY29uc3RyYWludCA9PiB7XG4gICAgICAgIGlmICh0aGlzLmV2YWx1YXRlQ29uc3RyYWludENvbmRpdGlvbihjb25zdHJhaW50LmNvbmRpdGlvbiwgc2NvcmVzKSkge1xuICAgICAgICAgIGNvbnN0IHJlcXVpcmVkTGV2ZWwgPSBjb25zdHJhaW50LnJlcXVpcmVkTGV2ZWw7XG4gICAgICAgICAgY29uc3QgY3VycmVudExldmVsID0gdGhpcy5nZXRMZXZlbFZhbHVlKHJlYy5yZWNvbW1lbmRlZExldmVsKTtcbiAgICAgICAgICBjb25zdCByZXF1aXJlZExldmVsVmFsdWUgPSB0aGlzLmdldExldmVsVmFsdWUocmVxdWlyZWRMZXZlbCk7XG5cbiAgICAgICAgICBpZiAoY3VycmVudExldmVsIDwgcmVxdWlyZWRMZXZlbFZhbHVlKSB7XG4gICAgICAgICAgICByZWMucmVjb21tZW5kZWRMZXZlbCA9IHJlcXVpcmVkTGV2ZWw7XG4gICAgICAgICAgICByZWMuZWZmb3J0ID0gcHJvY2Vzcy50YWlsb3JpbmdMZXZlbHNbcmVxdWlyZWRMZXZlbF0/LmVmZm9ydCB8fCByZWMuZWZmb3J0O1xuICAgICAgICAgICAgcmVjLmNvbXBsZXhpdHkgPSBwcm9jZXNzLnRhaWxvcmluZ0xldmVsc1tyZXF1aXJlZExldmVsXT8uY29tcGxleGl0eSB8fCByZWMuY29tcGxleGl0eTtcblxuICAgICAgICAgICAgcmVjLmNvbnN0cmFpbnRzLnB1c2goe1xuICAgICAgICAgICAgICB0eXBlOiAncHJvY2VzcycsXG4gICAgICAgICAgICAgIGNvbmRpdGlvbjogY29uc3RyYWludC5jb25kaXRpb24sXG4gICAgICAgICAgICAgIHJlYXNvbjogY29uc3RyYWludC5yYXRpb25hbGUgfHwgJ1Byb2Nlc3MgY29uc3RyYWludCBhcHBsaWVkJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBldmFsdWF0ZUNvbnN0cmFpbnRDb25kaXRpb24oY29uZGl0aW9uLCBzY29yZXMpIHtcbiAgICB0cnkge1xuICAgICAgLy8gU2ltcGxlIGNvbmRpdGlvbiBldmFsdWF0aW9uIC0gZXh0ZW5kIGFzIG5lZWRlZFxuICAgICAgLy8gRXhhbXBsZTogXCJzYWZldHlfY3JpdGljYWxpdHkgPiAzXCJcbiAgICAgIGNvbnN0IG1hdGNoID0gY29uZGl0aW9uLm1hdGNoKC8oXFx3KylcXHMqKFs+PD1dKylcXHMqKFxcZCtcXC4/XFxkKikvKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBjb25zdCBbLCBkaW1lbnNpb24sIG9wZXJhdG9yLCB0aHJlc2hvbGRdID0gbWF0Y2g7XG4gICAgICAgIGNvbnN0IHNjb3JlID0gc2NvcmVzW2RpbWVuc2lvbl07XG4gICAgICAgIGNvbnN0IHRocmVzaG9sZFZhbHVlID0gcGFyc2VGbG9hdCh0aHJlc2hvbGQpO1xuXG4gICAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgICBjYXNlICc+JzogcmV0dXJuIHNjb3JlID4gdGhyZXNob2xkVmFsdWU7XG4gICAgICAgICAgY2FzZSAnPj0nOiByZXR1cm4gc2NvcmUgPj0gdGhyZXNob2xkVmFsdWU7XG4gICAgICAgICAgY2FzZSAnPCc6IHJldHVybiBzY29yZSA8IHRocmVzaG9sZFZhbHVlO1xuICAgICAgICAgIGNhc2UgJzw9JzogcmV0dXJuIHNjb3JlIDw9IHRocmVzaG9sZFZhbHVlO1xuICAgICAgICAgIGNhc2UgJz0nOiBjYXNlICc9PSc6IHJldHVybiBNYXRoLmFicyhzY29yZSAtIHRocmVzaG9sZFZhbHVlKSA8IDAuMTtcbiAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gRmFpbGVkIHRvIGV2YWx1YXRlIGNvbnN0cmFpbnQgY29uZGl0aW9uXG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUNvbmZpZGVuY2VTY29yZXMocmVjb21tZW5kYXRpb25zLCBzY29yZXMpIHtcbiAgICBPYmplY3QudmFsdWVzKHJlY29tbWVuZGF0aW9ucykuZm9yRWFjaChyZWMgPT4ge1xuICAgICAgbGV0IGNvbmZpZGVuY2UgPSAwLjg7IC8vIEJhc2UgY29uZmlkZW5jZVxuXG4gICAgICAvLyBSZWR1Y2UgY29uZmlkZW5jZSBpZiBzY29yZSBpcyBuZWFyIHRocmVzaG9sZCBib3VuZGFyaWVzXG4gICAgICBjb25zdCBiYXNlU2NvcmUgPSByZWMuYmFzZVNjb3JlO1xuICAgICAgaWYgKChiYXNlU2NvcmUgPj0gMi4wICYmIGJhc2VTY29yZSA8PSAyLjIpIHx8IChiYXNlU2NvcmUgPj0gMy41ICYmIGJhc2VTY29yZSA8PSAzLjcpKSB7XG4gICAgICAgIGNvbmZpZGVuY2UgLT0gMC4yO1xuICAgICAgfVxuXG4gICAgICAvLyBSZWR1Y2UgY29uZmlkZW5jZSBpZiBjb25mbGljdGluZyBjb25zdHJhaW50c1xuICAgICAgaWYgKHJlYy5jb25zdHJhaW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgIGNvbmZpZGVuY2UgLT0gMC4xO1xuICAgICAgfVxuXG4gICAgICAvLyBJbmNyZWFzZSBjb25maWRlbmNlIGlmIG11bHRpcGxlIGZhY3RvcnMgYWxpZ25cbiAgICAgIGNvbnN0IGV4dHJlbWVTY29yZXMgPSBPYmplY3QudmFsdWVzKHNjb3JlcykuZmlsdGVyKHMgPT4gcyA8PSAxLjUgfHwgcyA+PSA0LjUpLmxlbmd0aDtcbiAgICAgIGlmIChleHRyZW1lU2NvcmVzID49IDIpIHtcbiAgICAgICAgY29uZmlkZW5jZSArPSAwLjE7XG4gICAgICB9XG5cbiAgICAgIHJlYy5jb25maWRlbmNlID0gTWF0aC5tYXgoMC40LCBNYXRoLm1pbigxLjAsIGNvbmZpZGVuY2UpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldExldmVsVmFsdWUobGV2ZWwpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSB7ICdiYXNpYyc6IDEsICdzdGFuZGFyZCc6IDIsICdjb21wcmVoZW5zaXZlJzogMyB9O1xuICAgIHJldHVybiB2YWx1ZXNbbGV2ZWxdIHx8IDE7XG4gIH1cblxuICBnZW5lcmF0ZVJhdGlvbmFsZShwcm9jZXNzLCBzY29yZXMsIGxldmVsKSB7XG4gICAgY29uc3QgcmF0aW9uYWxlID0gW107XG4gICAgY29uc3Qgd2VpZ2h0cyA9IHRoaXMuZ2V0UHJvY2Vzc1dlaWdodHMocHJvY2Vzcyk7XG5cbiAgICAvLyBQcmltYXJ5IGRyaXZlcnNcbiAgICBjb25zdCBwcmltYXJ5RmFjdG9ycyA9IE9iamVjdC5rZXlzKHdlaWdodHMpXG4gICAgICAubWFwKGRpbSA9PiAoeyBkaW1lbnNpb246IGRpbSwgd2VpZ2h0OiB3ZWlnaHRzW2RpbV0sIHNjb3JlOiBzY29yZXNbZGltXSB9KSlcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBiLndlaWdodCAtIGEud2VpZ2h0KVxuICAgICAgLnNsaWNlKDAsIDIpO1xuXG4gICAgcHJpbWFyeUZhY3RvcnMuZm9yRWFjaChmYWN0b3IgPT4ge1xuICAgICAgY29uc3QgaW1wYWN0ID0gdGhpcy5nZXRTY29yZUltcGFjdChmYWN0b3Iuc2NvcmUpO1xuICAgICAgcmF0aW9uYWxlLnB1c2goYCR7dGhpcy5nZXREaW1lbnNpb25OYW1lKGZhY3Rvci5kaW1lbnNpb24pfSAoJHtmYWN0b3Iuc2NvcmUudG9GaXhlZCgxKX0vNS4wKSAke2ltcGFjdC5kZXNjcmlwdGlvbn1gKTtcbiAgICB9KTtcblxuICAgIC8vIExldmVsIGp1c3RpZmljYXRpb25cbiAgICBzd2l0Y2ggKGxldmVsKSB7XG4gICAgICBjYXNlICdiYXNpYyc6XG4gICAgICAgIHJhdGlvbmFsZS5wdXNoKCdCYXNpYyBsZXZlbCByZWNvbW1lbmRlZCBmb3IgbG93IGNvbXBsZXhpdHkgYW5kIHJpc2sgcHJvZmlsZScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3N0YW5kYXJkJzpcbiAgICAgICAgcmF0aW9uYWxlLnB1c2goJ1N0YW5kYXJkIGxldmVsIHByb3ZpZGVzIGJhbGFuY2VkIGZvcm1hbGl0eSBmb3IgbW9kZXJhdGUgY29tcGxleGl0eScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NvbXByZWhlbnNpdmUnOlxuICAgICAgICByYXRpb25hbGUucHVzaCgnQ29tcHJlaGVuc2l2ZSBsZXZlbCByZXF1aXJlZCBmb3IgaGlnaCBjb21wbGV4aXR5IGFuZCBjcml0aWNhbGl0eScpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gcmF0aW9uYWxlO1xuICB9XG5cbiAgZ2V0RGltZW5zaW9uTmFtZShkaW1lbnNpb24pIHtcbiAgICBjb25zdCBuYW1lcyA9IHtcbiAgICAgIGNvbXBsZXhpdHk6ICdUZWNobmljYWwgQ29tcGxleGl0eScsXG4gICAgICBzYWZldHk6ICdTYWZldHkgQ3JpdGljYWxpdHknLFxuICAgICAgc2NhbGU6ICdQcm9qZWN0IFNjYWxlJyxcbiAgICAgIG1hdHVyaXR5OiAnT3JnYW5pemF0aW9uYWwgTWF0dXJpdHknLFxuICAgIH07XG4gICAgcmV0dXJuIG5hbWVzW2RpbWVuc2lvbl0gfHwgZGltZW5zaW9uO1xuICB9XG5cbiAgZ2V0U2NvcmVJbXBhY3Qoc2NvcmUpIHtcbiAgICBpZiAoc2NvcmUgPD0gMi4wKSByZXR1cm4geyBsZXZlbDogJ2xvdycsIGRlc2NyaXB0aW9uOiAnc3VnZ2VzdHMgbWluaW1hbCBmb3JtYWxpdHknIH07XG4gICAgaWYgKHNjb3JlIDw9IDMuNSkgcmV0dXJuIHsgbGV2ZWw6ICdtZWRpdW0nLCBkZXNjcmlwdGlvbjogJ2luZGljYXRlcyBtb2RlcmF0ZSBmb3JtYWxpdHkgbmVlZGVkJyB9O1xuICAgIHJldHVybiB7IGxldmVsOiAnaGlnaCcsIGRlc2NyaXB0aW9uOiAncmVxdWlyZXMgaGlnaCBmb3JtYWxpdHkgYW5kIHJpZ29yJyB9O1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZWNvbW1lbmRhdGlvbnMtY29udGVudCcpO1xuICAgIGlmICghY29udGFpbmVyKSByZXR1cm47XG5cbiAgICBjb25zdCBhc3Nlc3NtZW50RGF0YSA9IHRoaXMuYXBwLmdldEFzc2Vzc21lbnREYXRhKCk7XG5cbiAgICBpZiAoIWFzc2Vzc21lbnREYXRhLnJlY29tbWVuZGF0aW9ucyB8fCBPYmplY3Qua2V5cyhhc3Nlc3NtZW50RGF0YS5yZWNvbW1lbmRhdGlvbnMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5yZW5kZXJOb1JlY29tbWVuZGF0aW9ucyhjb250YWluZXIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVyUmVjb21tZW5kYXRpb25zKGNvbnRhaW5lciwgYXNzZXNzbWVudERhdGEpO1xuICB9XG5cbiAgcmVuZGVyTm9SZWNvbW1lbmRhdGlvbnMoY29udGFpbmVyKSB7XG4gICAgY29udGFpbmVyLmlubmVySFRNTCA9IGBcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0ZXh0LWNlbnRlciBweS01XCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhcmRcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhcmQtYm9keVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJiaSBiaS1leGNsYW1hdGlvbi1jaXJjbGUgZGlzcGxheS0xIHRleHQtd2FybmluZyBtYi0zXCI+PC9pPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGgzPk5vIFJlY29tbWVuZGF0aW9ucyBBdmFpbGFibGU8L2gzPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XCJ0ZXh0LW11dGVkIG1iLTRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb21wbGV0ZSB0aGUgYXNzZXNzbWVudCBmaXJzdCB0byBnZW5lcmF0ZSBwZXJzb25hbGl6ZWQgcHJvY2VzcyB0YWlsb3JpbmcgcmVjb21tZW5kYXRpb25zLlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeVwiIG9uY2xpY2s9XCJ3aW5kb3cuc2VBcHAuc2hvd1ZpZXcoJ2Fzc2Vzc21lbnQnKVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiYmkgYmktY2xpcGJvYXJkLWNoZWNrXCI+PC9pPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0YXJ0IEFzc2Vzc21lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICBgO1xuICB9XG5cbiAgcmVuZGVyUmVjb21tZW5kYXRpb25zKGNvbnRhaW5lciwgYXNzZXNzbWVudERhdGEpIHtcbiAgICBjb25zdCByZWNvbW1lbmRhdGlvbnMgPSBhc3Nlc3NtZW50RGF0YS5yZWNvbW1lbmRhdGlvbnM7XG5cbiAgICAvLyBHcm91cCByZWNvbW1lbmRhdGlvbnMgYnkgY2F0ZWdvcnlcbiAgICBjb25zdCBncm91cGVkUmVjcyA9IHRoaXMuZ3JvdXBSZWNvbW1lbmRhdGlvbnNCeUNhdGVnb3J5KHJlY29tbWVuZGF0aW9ucyk7XG5cbiAgICAvLyBDYWxjdWxhdGUgc3VtbWFyeSBzdGF0aXN0aWNzXG4gICAgY29uc3Qgc3RhdHMgPSB0aGlzLmNhbGN1bGF0ZVN1bW1hcnlTdGF0cyhyZWNvbW1lbmRhdGlvbnMpO1xuXG4gICAgY29uc3QgaHRtbCA9IGBcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtYi00XCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhcmQgc2hhZG93LXNtXCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYXJkLWhlYWRlciBiZy1ncmFkaWVudC1wcmltYXJ5IHRleHQtd2hpdGVcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxoNCBjbGFzcz1cImNhcmQtdGl0bGUgbWItMFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiYmkgYmktbGlnaHRidWxiLWZpbGxcIj48L2k+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUHJvY2VzcyBUYWlsb3JpbmcgUmVjb21tZW5kYXRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2g0PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhcmQtYm9keVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInJvdyBtYi00XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC0zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzdGF0LWNhcmQgYm9yZGVyLXN0YXJ0LXByaW1hcnlcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwic3RhdC1udW1iZXIgdGV4dC1zdWNjZXNzXCI+JHtzdGF0cy5iYXNpY308L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInN0YXQtbGFiZWxcIj5CYXNpYyBMZXZlbDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC0zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzdGF0LWNhcmQgYm9yZGVyLXN0YXJ0LXdhcm5pbmdcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwic3RhdC1udW1iZXIgdGV4dC13YXJuaW5nXCI+JHtzdGF0cy5zdGFuZGFyZH08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInN0YXQtbGFiZWxcIj5TdGFuZGFyZCBMZXZlbDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC0zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzdGF0LWNhcmQgYm9yZGVyLXN0YXJ0LWRhbmdlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJzdGF0LW51bWJlciB0ZXh0LWRhbmdlclwiPiR7c3RhdHMuY29tcHJlaGVuc2l2ZX08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInN0YXQtbGFiZWxcIj5Db21wcmVoZW5zaXZlIExldmVsPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInN0YXQtY2FyZFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJzdGF0LW51bWJlclwiPiR7c3RhdHMudG90YWxFZmZvcnR9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJzdGF0LWxhYmVsXCI+VG90YWwgRWZmb3J0IFNjb3JlPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYWxlcnQgYWxlcnQtaW5mb1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiYmkgYmktaW5mby1jaXJjbGUgbWUtMlwiPjwvaT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Ryb25nPkltcGxlbWVudGF0aW9uIEd1aWRhbmNlOjwvc3Ryb25nPiBTdGFydCB3aXRoIGhpZ2gtcHJpb3JpdHkgcHJvY2Vzc2VzIGFuZCBncmFkdWFsbHkgaW1wbGVtZW50IG90aGVycy4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUGF5IHNwZWNpYWwgYXR0ZW50aW9uIHRvIGRlcGVuZGVuY3kgcmVsYXRpb25zaGlwcyBzaG93biBpbiB0aGUgdmlzdWFsaXphdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAke09iamVjdC5rZXlzKGdyb3VwZWRSZWNzKS5tYXAoY2F0ZWdvcnkgPT4gdGhpcy5yZW5kZXJDYXRlZ29yeVNlY3Rpb24oY2F0ZWdvcnksIGdyb3VwZWRSZWNzW2NhdGVnb3J5XSkpLmpvaW4oJycpfVxuICAgICAgICBgO1xuXG4gICAgY29udGFpbmVyLmlubmVySFRNTCA9IGh0bWw7XG4gICAgdGhpcy5hdHRhY2hSZWNvbW1lbmRhdGlvbkV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICBncm91cFJlY29tbWVuZGF0aW9uc0J5Q2F0ZWdvcnkocmVjb21tZW5kYXRpb25zKSB7XG4gICAgY29uc3QgZ3JvdXBlZCA9IHt9O1xuXG4gICAgT2JqZWN0LnZhbHVlcyhyZWNvbW1lbmRhdGlvbnMpLmZvckVhY2gocmVjID0+IHtcbiAgICAgIGNvbnN0IGNhdGVnb3J5ID0gcmVjLmNhdGVnb3J5IHx8ICdvdGhlcic7XG4gICAgICBpZiAoIWdyb3VwZWRbY2F0ZWdvcnldKSB7XG4gICAgICAgIGdyb3VwZWRbY2F0ZWdvcnldID0gW107XG4gICAgICB9XG4gICAgICBncm91cGVkW2NhdGVnb3J5XS5wdXNoKHJlYyk7XG4gICAgfSk7XG5cbiAgICAvLyBTb3J0IHByb2Nlc3NlcyB3aXRoaW4gZWFjaCBjYXRlZ29yeSBieSBuYW1lXG4gICAgT2JqZWN0LmtleXMoZ3JvdXBlZCkuZm9yRWFjaChjYXRlZ29yeSA9PiB7XG4gICAgICBncm91cGVkW2NhdGVnb3J5XS5zb3J0KChhLCBiKSA9PiBhLnByb2Nlc3NOYW1lLmxvY2FsZUNvbXBhcmUoYi5wcm9jZXNzTmFtZSkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGdyb3VwZWQ7XG4gIH1cblxuICByZW5kZXJDYXRlZ29yeVNlY3Rpb24oY2F0ZWdvcnksIHByb2Nlc3Nlcykge1xuICAgIGNvbnN0IGNhdGVnb3J5TmFtZSA9IHRoaXMucHJvY2Vzc0RhdGEucHJvY2Vzc0NhdGVnb3JpZXM/LltjYXRlZ29yeV0gfHwgY2F0ZWdvcnk7XG5cbiAgICByZXR1cm4gYFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1iLTRcIj5cbiAgICAgICAgICAgICAgICA8aDUgY2xhc3M9XCJtYi0zXCI+XG4gICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiYmkgYmktJHt0aGlzLmdldENhdGVnb3J5SWNvbihjYXRlZ29yeSl9XCI+PC9pPlxuICAgICAgICAgICAgICAgICAgICAke2NhdGVnb3J5TmFtZX1cbiAgICAgICAgICAgICAgICA8L2g1PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cbiAgICAgICAgICAgICAgICAgICAgJHtwcm9jZXNzZXMubWFwKHByb2Nlc3MgPT4gdGhpcy5yZW5kZXJQcm9jZXNzQ2FyZChwcm9jZXNzKSkuam9pbignJyl9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgYDtcbiAgfVxuXG4gIHJlbmRlclByb2Nlc3NDYXJkKHByb2Nlc3MpIHtcbiAgICBjb25zdCBsZXZlbENsYXNzID0gcHJvY2Vzcy5yZWNvbW1lbmRlZExldmVsO1xuICAgIGNvbnN0IGNvbmZpZGVuY2VQZXJjZW50ID0gTWF0aC5yb3VuZChwcm9jZXNzLmNvbmZpZGVuY2UgKiAxMDApO1xuXG4gICAgcmV0dXJuIGBcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbGctNiBtYi0zXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInByb2Nlc3MtY2FyZCBjYXJkICR7bGV2ZWxDbGFzc31cIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhcmQtYm9keVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImQtZmxleCBqdXN0aWZ5LWNvbnRlbnQtYmV0d2VlbiBhbGlnbi1pdGVtcy1zdGFydCBtYi0yXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGg2IGNsYXNzPVwicHJvY2Vzcy10aXRsZSBtYi0xXCI+JHtwcm9jZXNzLnByb2Nlc3NOYW1lfTwvaDY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJsZXZlbC1iYWRnZSBsZXZlbC0ke2xldmVsQ2xhc3N9XCI+JHtwcm9jZXNzLnJlY29tbWVuZGVkTGV2ZWx9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtYi0yXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwidGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFZmZvcnQ6IDxzdHJvbmc+JHtwcm9jZXNzLmVmZm9ydH08L3N0cm9uZz4gfCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29tcGxleGl0eTogPHN0cm9uZz4ke3Byb2Nlc3MuY29tcGxleGl0eX08L3N0cm9uZz4gfCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29uZmlkZW5jZTogPHN0cm9uZz4ke2NvbmZpZGVuY2VQZXJjZW50fSU8L3N0cm9uZz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NtYWxsPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtYi0zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cm9uZz5SYXRpb25hbGU6PC9zdHJvbmc+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHVsIGNsYXNzPVwibGlzdC11bnN0eWxlZCBtdC0xIG1iLTBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtwcm9jZXNzLnJhdGlvbmFsZS5tYXAocmVhc29uID0+IGA8bGkgY2xhc3M9XCJ0ZXh0LXNtYWxsIHRleHQtbXV0ZWRcIj7igKIgJHtyZWFzb259PC9saT5gKS5qb2luKCcnKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICR7cHJvY2Vzcy5jb25zdHJhaW50cy5sZW5ndGggPiAwID8gYFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtYi0zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJvbmc+Q29uc3RyYWludHMgQXBwbGllZDo8L3N0cm9uZz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHVsIGNsYXNzPVwibGlzdC11bnN0eWxlZCBtdC0xIG1iLTBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7cHJvY2Vzcy5jb25zdHJhaW50cy5tYXAoY29uc3RyYWludCA9PiBgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzPVwidGV4dC1zbWFsbCB0ZXh0LXdhcm5pbmdcIj7igKIgJHtjb25zdHJhaW50LnJlYXNvbn08L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYCkuam9pbignJyl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICBgIDogJyd9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICR7cHJvY2Vzcy5kZXBlbmRlbmNpZXMubGVuZ3RoID4gMCA/IGBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibWItM1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Ryb25nPkRlcGVuZGVuY2llczo8L3N0cm9uZz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHVsIGNsYXNzPVwiZGVwZW5kZW5jeS1saXN0XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAke3Byb2Nlc3MuZGVwZW5kZW5jaWVzLm1hcChkZXAgPT4gYFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cImRlcGVuZGVuY3ktaXRlbSAke2RlcC50eXBlID09PSAndmVydGljYWwnID8gJ2NyaXRpY2FsJyA6ICdpbXBvcnRhbnQnfVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c21hbGw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Ryb25nPiR7ZGVwLnRhcmdldE5hbWV9PC9zdHJvbmc+IHJlcXVpcmVzIDxlbT4ke2RlcC5yZXF1aXJlZExldmVsfTwvZW0+IGxldmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImJhZGdlIGJhZGdlLXNtIGJnLXNlY29uZGFyeSBtcy0xXCI+JHtkZXAudHlwZX08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGApLmpvaW4oJycpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgYCA6ICcnfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGV4dC1lbmRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXByaW1hcnkgYnRuLXNtXCIgb25jbGljaz1cIndpbmRvdy5zZUFwcC5zaG93UHJvY2Vzc0RldGFpbHMoJyR7cHJvY2Vzcy5wcm9jZXNzSWR9JylcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJiaSBiaS1pbmZvLWNpcmNsZVwiPjwvaT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGV0YWlsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIGA7XG4gIH1cblxuICBjYWxjdWxhdGVTdW1tYXJ5U3RhdHMocmVjb21tZW5kYXRpb25zKSB7XG4gICAgY29uc3Qgc3RhdHMgPSB7XG4gICAgICBiYXNpYzogMCxcbiAgICAgIHN0YW5kYXJkOiAwLFxuICAgICAgY29tcHJlaGVuc2l2ZTogMCxcbiAgICAgIHRvdGFsRWZmb3J0OiAwLFxuICAgICAgYXZlcmFnZUNvbmZpZGVuY2U6IDAsXG4gICAgfTtcblxuICAgIGNvbnN0IHJlY3MgPSBPYmplY3QudmFsdWVzKHJlY29tbWVuZGF0aW9ucyk7XG5cbiAgICByZWNzLmZvckVhY2gocmVjID0+IHtcbiAgICAgIHN0YXRzW3JlYy5yZWNvbW1lbmRlZExldmVsXSsrO1xuICAgICAgc3RhdHMudG90YWxFZmZvcnQgKz0gcmVjLmVmZm9ydCB8fCAwO1xuICAgIH0pO1xuXG4gICAgc3RhdHMuYXZlcmFnZUNvbmZpZGVuY2UgPSByZWNzLmxlbmd0aCA+IDBcbiAgICAgID8gcmVjcy5yZWR1Y2UoKHN1bSwgcmVjKSA9PiBzdW0gKyByZWMuY29uZmlkZW5jZSwgMCkgLyByZWNzLmxlbmd0aFxuICAgICAgOiAwO1xuXG4gICAgcmV0dXJuIHN0YXRzO1xuICB9XG5cbiAgZ2V0Q2F0ZWdvcnlJY29uKGNhdGVnb3J5KSB7XG4gICAgY29uc3QgaWNvbnMgPSB7XG4gICAgICAndGVjaG5pY2FsX21hbmFnZW1lbnQnOiAnZ2VhcicsXG4gICAgICAndGVjaG5pY2FsJzogJ2NwdScsXG4gICAgICAnb3RoZXInOiAnY2lyY2xlJyxcbiAgICB9O1xuICAgIHJldHVybiBpY29uc1tjYXRlZ29yeV0gfHwgJ2NpcmNsZSc7XG4gIH1cblxuICBhdHRhY2hSZWNvbW1lbmRhdGlvbkV2ZW50TGlzdGVuZXJzKCkge1xuICAgIC8vIEFkZCBhbnkgaW50ZXJhY3RpdmUgZXZlbnQgbGlzdGVuZXJzIGhlcmVcbiAgICAvLyBDdXJyZW50bHkgaGFuZGxlZCB0aHJvdWdoIG9uY2xpY2sgYXR0cmlidXRlcyBpbiB0aGUgSFRNTFxuICB9XG5cbiAgLy8gUHVibGljIG1ldGhvZHMgZm9yIGFwcCBpbnRlZ3JhdGlvblxuICBnZXRSZWNvbW1lbmRhdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVjb21tZW5kYXRpb25zO1xuICB9XG5cbiAgZ2V0UHJvY2Vzc1JlY29tbWVuZGF0aW9uKHByb2Nlc3NJZCkge1xuICAgIHJldHVybiB0aGlzLnJlY29tbWVuZGF0aW9uc1twcm9jZXNzSWRdO1xuICB9XG59XG5cbi8vIEV4cG9ydCBmb3IgZ2xvYmFsIGFjY2Vzc1xud2luZG93LlJlY29tbWVuZGF0aW9uRW5naW5lID0gUmVjb21tZW5kYXRpb25FbmdpbmU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./js/components/recommendations.js\n\n}");

/***/ }),

/***/ "./js/components/visualization.js":
/*!****************************************!*\
  !*** ./js/components/visualization.js ***!
  \****************************************/
/***/ (() => {

eval("{/**\n * Process Network Visualizer Component\n * Creates interactive D3.js network diagrams showing process relationships\n */\n\nclass ProcessNetworkVisualizer {\n  constructor(processData, dependencyData, app) {\n    this.processData = processData;\n    this.dependencyData = dependencyData;\n    this.app = app;\n    this.svg = null;\n    this.simulation = null;\n    this.nodes = [];\n    this.links = [];\n    this.width = 800;\n    this.height = 600;\n    this.zoom = null;\n    this.currentFilters = {\n      categories: new Set(['technical_management', 'technical']),\n      levels: new Set(['basic', 'standard', 'comprehensive']),\n      showDependencies: true,\n      showMetrics: true,\n      showRecommendations: true,\n      searchTerm: '',\n      layoutSettings: {\n        chargeStrength: -200,\n        linkStrength: 0.5,\n      },\n    };\n  }\n\n  render() {\n    this.setupContainer();\n    this.renderControls();\n    this.prepareData();\n    this.createVisualization();\n    this.setupEventListeners();\n  }\n\n  setupContainer() {\n    const container = document.getElementById('network-visualization');\n    if (!container) return;\n\n    // Clear existing content\n    container.innerHTML = '';\n\n    // Get container dimensions\n    const rect = container.getBoundingClientRect();\n    this.width = Math.max(800, rect.width - 20);\n    this.height = Math.max(600, rect.height - 20);\n  }\n\n  renderControls() {\n    const controlsContainer = document.getElementById('visualization-controls');\n    if (!controlsContainer) return;\n\n    const html = `\n            <div class=\"control-group\">\n                <label class=\"control-label\">Search Processes</label>\n                <div class=\"input-group input-group-sm\">\n                    <span class=\"input-group-text\">\n                        <i class=\"bi bi-search\"></i>\n                    </span>\n                    <input type=\"text\" class=\"form-control\" id=\"process-search\" \n                           placeholder=\"Type to search processes...\">\n                </div>\n            </div>\n\n            <div class=\"control-group\">\n                <label class=\"control-label\">Process Categories</label>\n                <div class=\"form-check form-check-sm\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"filter-technical-mgmt\" checked>\n                    <label class=\"form-check-label\" for=\"filter-technical-mgmt\">\n                        Technical Management\n                    </label>\n                </div>\n                <div class=\"form-check form-check-sm\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"filter-technical\" checked>\n                    <label class=\"form-check-label\" for=\"filter-technical\">\n                        Technical Processes\n                    </label>\n                </div>\n            </div>\n\n            <div class=\"control-group\">\n                <label class=\"control-label\">Tailoring Levels</label>\n                <div class=\"form-check form-check-sm\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"filter-basic\" checked>\n                    <label class=\"form-check-label\" for=\"filter-basic\">\n                        <span class=\"level-badge level-basic\">Basic</span>\n                    </label>\n                </div>\n                <div class=\"form-check form-check-sm\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"filter-standard\" checked>\n                    <label class=\"form-check-label\" for=\"filter-standard\">\n                        <span class=\"level-badge level-standard\">Standard</span>\n                    </label>\n                </div>\n                <div class=\"form-check form-check-sm\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"filter-comprehensive\" checked>\n                    <label class=\"form-check-label\" for=\"filter-comprehensive\">\n                        <span class=\"level-badge level-comprehensive\">Comprehensive</span>\n                    </label>\n                </div>\n            </div>\n\n            <div class=\"control-group\">\n                <label class=\"control-label\">Display Options</label>\n                <div class=\"form-check form-check-sm\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"show-dependencies\" checked>\n                    <label class=\"form-check-label\" for=\"show-dependencies\">\n                        Show Dependencies\n                    </label>\n                </div>\n                <div class=\"form-check form-check-sm\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"show-labels\" checked>\n                    <label class=\"form-check-label\" for=\"show-labels\">\n                        Show Labels\n                    </label>\n                </div>\n                <div class=\"form-check form-check-sm\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"show-metrics\" checked>\n                    <label class=\"form-check-label\" for=\"show-metrics\">\n                        Show Metrics\n                    </label>\n                </div>\n                <div class=\"form-check form-check-sm\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"show-recommendations\" checked>\n                    <label class=\"form-check-label\" for=\"show-recommendations\">\n                        Show Recommendations\n                    </label>\n                </div>\n            </div>\n\n            <div class=\"control-group\">\n                <label class=\"control-label\">Layout</label>\n                <select class=\"form-select form-select-sm\" id=\"layout-select\">\n                    <option value=\"force\">Force-Directed</option>\n                    <option value=\"circular\">Circular</option>\n                    <option value=\"hierarchical\">Hierarchical</option>\n                </select>\n            </div>\n\n            <div class=\"control-group\">\n                <label class=\"control-label\">Force Layout Settings</label>\n                <div class=\"input-group input-group-sm\">\n                    <span class=\"input-group-text\">Charge</span>\n                    <input type=\"range\" class=\"form-range\" id=\"charge-strength\" min=\"-1000\" max=\"-50\" value=\"-200\">\n                    <span class=\"input-group-text\" id=\"charge-value\">-200</span>\n                </div>\n                <div class=\"input-group input-group-sm\">\n                    <span class=\"input-group-text\">Link</span>\n                    <input type=\"range\" class=\"form-range\" id=\"link-strength\" min=\"0\" max=\"2\" step=\"0.1\" value=\"0.5\">\n                    <span class=\"input-group-text\" id=\"link-value\">0.5</span>\n                </div>\n            </div>\n\n            <div class=\"control-group\">\n                <button class=\"btn btn-outline-primary btn-sm w-100\" id=\"reset-filters-btn\">\n                    <i class=\"bi bi-arrow-clockwise\"></i>\n                    Reset Filters\n                </button>\n                <button class=\"btn btn-outline-secondary btn-sm w-100 mt-2\" id=\"export-network-btn\">\n                    <i class=\"bi bi-download\"></i>\n                    Export Network\n                </button>\n                <button class=\"btn btn-outline-info btn-sm w-100 mt-2\" id=\"help-network-btn\">\n                    <i class=\"bi bi-question-circle\"></i>\n                    Help & Tips\n                </button>\n            </div>\n        `;\n\n    controlsContainer.innerHTML = html;\n    this.attachControlEventListeners();\n  }\n\n  attachControlEventListeners() {\n    // Search functionality\n    const searchInput = document.getElementById('process-search');\n    if (searchInput) {\n      searchInput.addEventListener('input', (e) => {\n        this.currentFilters.searchTerm = e.target.value.toLowerCase();\n        this.updateVisualization();\n      });\n    }\n\n    // Category filters\n    ['technical-mgmt', 'technical'].forEach(category => {\n      const checkbox = document.getElementById(`filter-${category}`);\n      if (checkbox) {\n        checkbox.addEventListener('change', (e) => {\n          const categoryKey = category === 'technical-mgmt' ? 'technical_management' : 'technical';\n          if (e.target.checked) {\n            this.currentFilters.categories.add(categoryKey);\n          } else {\n            this.currentFilters.categories.delete(categoryKey);\n          }\n          this.updateVisualization();\n        });\n      }\n    });\n\n    // Level filters\n    ['basic', 'standard', 'comprehensive'].forEach(level => {\n      const checkbox = document.getElementById(`filter-${level}`);\n      if (checkbox) {\n        checkbox.addEventListener('change', (e) => {\n          if (e.target.checked) {\n            this.currentFilters.levels.add(level);\n          } else {\n            this.currentFilters.levels.delete(level);\n          }\n          this.updateVisualization();\n        });\n      }\n    });\n\n    // Display options\n    const showDepsCheckbox = document.getElementById('show-dependencies');\n    if (showDepsCheckbox) {\n      showDepsCheckbox.addEventListener('change', (e) => {\n        this.currentFilters.showDependencies = e.target.checked;\n        this.updateVisualization();\n      });\n    }\n\n    const showLabelsCheckbox = document.getElementById('show-labels');\n    if (showLabelsCheckbox) {\n      showLabelsCheckbox.addEventListener('change', (e) => {\n        this.toggleLabels(e.target.checked);\n      });\n    }\n\n    // Layout selection\n    const layoutSelect = document.getElementById('layout-select');\n    if (layoutSelect) {\n      layoutSelect.addEventListener('change', (e) => {\n        this.changeLayout(e.target.value);\n      });\n    }\n\n    // Force layout settings\n    const chargeSlider = document.getElementById('charge-strength');\n    const chargeValue = document.getElementById('charge-value');\n    if (chargeSlider && chargeValue) {\n      chargeSlider.addEventListener('input', (e) => {\n        const value = parseInt(e.target.value);\n        chargeValue.textContent = value;\n        this.currentFilters.layoutSettings.chargeStrength = value;\n        this.updateForceLayout();\n      });\n    }\n\n    const linkSlider = document.getElementById('link-strength');\n    const linkValue = document.getElementById('link-value');\n    if (linkSlider && linkValue) {\n      linkSlider.addEventListener('input', (e) => {\n        const value = parseFloat(e.target.value);\n        linkValue.textContent = value;\n        this.currentFilters.layoutSettings.linkStrength = value;\n        this.updateForceLayout();\n      });\n    }\n\n    // Display options\n    const showMetricsCheckbox = document.getElementById('show-metrics');\n    if (showMetricsCheckbox) {\n      showMetricsCheckbox.addEventListener('change', (e) => {\n        this.currentFilters.showMetrics = e.target.checked;\n        this.updateVisualization();\n      });\n    }\n\n    const showRecsCheckbox = document.getElementById('show-recommendations');\n    if (showRecsCheckbox) {\n      showRecsCheckbox.addEventListener('change', (e) => {\n        this.currentFilters.showRecommendations = e.target.checked;\n        this.updateVisualization();\n      });\n    }\n\n    // Export button\n    const exportBtn = document.getElementById('export-network-btn');\n    if (exportBtn) {\n      exportBtn.addEventListener('click', () => {\n        this.exportNetwork();\n      });\n    }\n\n    // Help button\n    const helpBtn = document.getElementById('help-network-btn');\n    if (helpBtn) {\n      helpBtn.addEventListener('click', () => {\n        this.showHelpModal();\n      });\n    }\n\n    // Reset filters\n    const resetBtn = document.getElementById('reset-filters-btn');\n    if (resetBtn) {\n      resetBtn.addEventListener('click', () => {\n        this.resetFilters();\n      });\n    }\n  }\n\n  updateForceLayout() {\n    if (this.simulation) {\n      this.simulation.force('charge', d3.forceManyBody().strength(this.currentFilters.layoutSettings.chargeStrength));\n      this.simulation.force('link', d3.forceLink(this.links).strength(this.currentFilters.layoutSettings.linkStrength));\n      this.simulation.alpha(0.3).restart();\n    }\n  }\n\n  exportNetwork() {\n    const svgElement = this.svg.node();\n    const serializer = new XMLSerializer();\n    const source = serializer.serializeToString(svgElement);\n\n    // Add namespace\n    const svgWithNamespace = source.replace('<svg', '<svg xmlns=\"http://www.w3.org/2000/svg\"');\n\n    // Create download link\n    const blob = new Blob([svgWithNamespace], { type: 'image/svg+xml' });\n    const url = URL.createObjectURL(blob);\n\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = 'se-process-network.svg';\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n  }\n\n  showHelpModal() {\n    const modalHtml = `\n            <div class=\"modal fade\" id=\"network-help-modal\" tabindex=\"-1\">\n                <div class=\"modal-dialog modal-lg\">\n                    <div class=\"modal-content\">\n                        <div class=\"modal-header\">\n                            <h5 class=\"modal-title\">Network Visualization Help</h5>\n                            <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\"></button>\n                        </div>\n                        <div class=\"modal-body\">\n                            <h6>Interactive Features</h6>\n                            <ul>\n                                <li><strong>Drag nodes</strong> to reposition them</li>\n                                <li><strong>Click nodes</strong> to view process details</li>\n                                <li><strong>Mouse wheel</strong> to zoom in/out</li>\n                                <li><strong>Drag background</strong> to pan the view</li>\n                            </ul>\n                            \n                            <h6>Filtering Options</h6>\n                            <ul>\n                                <li><strong>Search</strong>: Filter processes by name</li>\n                                <li><strong>Categories</strong>: Show/hide process categories</li>\n                                <li><strong>Levels</strong>: Filter by tailoring levels</li>\n                                <li><strong>Dependencies</strong>: Toggle dependency visibility</li>\n                            </ul>\n                            \n                            <h6>Layout Controls</h6>\n                            <ul>\n                                <li><strong>Force-Directed</strong>: Dynamic physics-based layout</li>\n                                <li><strong>Circular</strong>: Organized circular arrangement</li>\n                                <li><strong>Hierarchical</strong>: Tree-like structure</li>\n                                <li><strong>Charge/Link</strong>: Adjust node repulsion and link strength</li>\n                            </ul>\n                        </div>\n                        <div class=\"modal-footer\">\n                            <button type=\"button\" class=\"btn btn-secondary\" data-bs-dismiss=\"modal\">Close</button>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        `;\n\n    // Remove existing modal if any\n    const existingModal = document.getElementById('network-help-modal');\n    if (existingModal) {\n      existingModal.remove();\n    }\n\n    // Add modal to DOM\n    document.body.insertAdjacentHTML('beforeend', modalHtml);\n\n    // Show modal\n    const modal = new bootstrap.Modal(document.getElementById('network-help-modal'));\n    modal.show();\n  }\n\n  prepareData() {\n    const processes = this.processData.processes || [];\n    const dependencies = this.dependencyData.dependencies || [];\n    const recommendations = this.app.getAssessmentData().recommendations;\n\n    // Create nodes\n    this.nodes = processes.map(process => {\n      const recommendation = recommendations?.[process.id];\n      const recommendedLevel = recommendation?.recommendedLevel || 'basic';\n\n      return {\n        id: process.id,\n        name: process.name,\n        category: process.category,\n        description: process.description,\n        recommendedLevel: recommendedLevel,\n        effort: recommendation?.effort || 1,\n        complexity: recommendation?.complexity || 1,\n        confidence: recommendation?.confidence || 0.8,\n        x: Math.random() * this.width,\n        y: Math.random() * this.height,\n      };\n    });\n\n    // Create links from dependencies\n    this.links = dependencies.map(dep => ({\n      source: dep.source,\n      target: dep.target,\n      type: dep.type || 'horizontal',\n      sourceLevel: dep.sourceLevel,\n      targetLevel: dep.targetLevel,\n      strength: dep.type === 'vertical' ? 0.8 : 0.4,\n    }));\n  }\n\n  createVisualization() {\n    const container = document.getElementById('network-visualization');\n    if (!container) return;\n\n    // Create SVG container with responsive design\n    this.svg = d3.select(container)\n      .append('svg')\n      .attr('width', '100%')\n      .attr('height', '100%')\n      .attr('viewBox', [0, 0, this.width, this.height])\n      .attr('preserveAspectRatio', 'xMidYMid meet')\n      .attr('class', 'network-svg')\n      .style('background', '#f8f9fa');\n\n    // Add zoom behavior with smooth transitions\n    this.zoom = d3.zoom()\n      .scaleExtent([0.1, 8])\n      .translateExtent([[0, 0], [this.width, this.height]])\n      .on('zoom', (event) => {\n        this.svg.select('.zoom-container').attr('transform', event.transform);\n      });\n\n    this.svg.call(this.zoom)\n      .call(this.zoom.transform, d3.zoomIdentity);\n\n    // Create container for zoomable content\n    const zoomContainer = this.svg.append('g').attr('class', 'zoom-container');\n\n    // Add sophisticated arrow markers for different link types\n    const defs = this.svg.append('defs');\n\n    const markerTypes = [\n      { id: 'dependency', color: '#dc3545', width: 4 },\n      { id: 'information', color: '#0d6efd', width: 3 },\n      { id: 'sequential', color: '#198754', width: 2 },\n    ];\n\n    markerTypes.forEach(type => {\n      defs.append('marker')\n        .attr('id', `arrow-${type.id}`)\n        .attr('viewBox', '0 -5 10 10')\n        .attr('refX', 18)\n        .attr('refY', 0)\n        .attr('markerWidth', 8)\n        .attr('markerHeight', 8)\n        .attr('orient', 'auto')\n        .append('path')\n        .attr('d', 'M0,-5L10,0L0,5')\n        .attr('fill', type.color)\n        .attr('stroke', type.color)\n        .attr('stroke-width', type.width);\n    });\n\n    // Create enhanced force simulation with custom parameters\n    this.simulation = d3.forceSimulation(this.nodes)\n      .force('link', d3.forceLink(this.links)\n        .id(d => d.id)\n        .strength(this.currentFilters.layoutSettings.linkStrength)\n        .distance(100))\n      .force('charge', d3.forceManyBody().strength(this.currentFilters.layoutSettings.chargeStrength))\n      .force('center', d3.forceCenter(this.width / 2, this.height / 2))\n      .force('collision', d3.forceCollide().radius(45))\n      .force('x', d3.forceX(this.width / 2).strength(0.05))\n      .force('y', d3.forceY(this.height / 2).strength(0.05));\n\n    // Draw links with enhanced styling\n    this.linkElements = zoomContainer.append('g')\n      .attr('class', 'links')\n      .selectAll('line')\n      .data(this.links)\n      .enter()\n      .append('line')\n      .attr('class', d => `network-link link-${d.type}`)\n      .attr('marker-end', d => `url(#arrow-${d.type})`)\n      .attr('stroke-width', d => {\n        const strengths = { dependency: 3, information: 2, sequential: 1.5 };\n        return strengths[d.type] || 1.5;\n      })\n      .attr('stroke-opacity', 0.8)\n      .attr('stroke-linecap', 'round');\n\n    // Draw nodes with enhanced styling and interactivity\n    this.nodeElements = zoomContainer.append('g')\n      .attr('class', 'nodes')\n      .selectAll('circle')\n      .data(this.nodes)\n      .enter()\n      .append('circle')\n      .attr('class', d => `network-node node-${d.category} level-${d.recommendedLevel}`)\n      .attr('r', d => {\n        // Scale node size based on importance/complexity\n        const baseSize = 20;\n        const complexityMultiplier = d.complexity ? d.complexity / 10 : 1;\n        return baseSize * complexityMultiplier;\n      })\n      .attr('fill', d => this.getNodeColor(d))\n      .attr('stroke', '#fff')\n      .attr('stroke-width', 2)\n      .attr('cursor', 'pointer')\n      .call(d3.drag()\n        .on('start', (event, d) => this.dragStarted(event, d))\n        .on('drag', (event, d) => this.dragged(event, d))\n        .on('end', (event, d) => this.dragEnded(event, d)),\n      )\n      .on('mouseover', (event, d) => this.showTooltip(event, d))\n      .on('mouseout', () => this.hideTooltip())\n      .on('click', (event, d) => this.nodeClicked(event, d));\n\n    // Add dynamic labels with conditional visibility\n    this.labelElements = zoomContainer.append('g')\n      .attr('class', 'labels')\n      .selectAll('text')\n      .data(this.nodes)\n      .enter()\n      .append('text')\n      .attr('class', 'network-text')\n      .attr('text-anchor', 'middle')\n      .attr('dy', d => {\n        const baseOffset = 35;\n        const sizeOffset = (d.complexity ? d.complexity / 10 : 1) * 5;\n        return baseOffset + sizeOffset;\n      })\n      .attr('font-size', '12px')\n      .attr('font-weight', '600')\n      .attr('fill', '#2c3e50')\n      .attr('pointer-events', 'none')\n      .attr('paint-order', 'stroke')\n      .attr('stroke', '#ffffff')\n      .attr('stroke-width', 3)\n      .attr('stroke-linecap', 'round')\n      .attr('stroke-linejoin', 'round')\n      .text(d => this.getNodeLabel(d));\n\n    // Add metric badges if enabled\n    this.metricElements = zoomContainer.append('g')\n      .attr('class', 'metrics')\n      .selectAll('text')\n      .data(this.nodes)\n      .enter()\n      .append('text')\n      .attr('class', 'node-metric')\n      .attr('text-anchor', 'middle')\n      .attr('dy', d => {\n        const baseOffset = -25;\n        const sizeOffset = (d.complexity ? d.complexity / 10 : 1) * 5;\n        return baseOffset - sizeOffset;\n      })\n      .attr('font-size', '10px')\n      .attr('fill', '#6c757d')\n      .attr('pointer-events', 'none')\n      .text(d => {\n        if (!this.currentFilters.showMetrics) return '';\n        const metrics = [];\n        if (d.effort) metrics.push(`Effort: ${d.effort}`);\n        if (d.complexity) metrics.push(`Complexity: ${d.complexity}`);\n        return metrics.join(' | ');\n      });\n\n    // Create tooltip\n    this.tooltip = d3.select('body')\n      .append('div')\n      .attr('class', 'network-tooltip')\n      .style('opacity', 0);\n\n    // Update positions on simulation tick with smooth transitions\n    this.simulation.on('tick', () => this.ticked());\n\n    // Initial update\n    this.updateVisualization();\n  }\n\n  getNodeColor(node) {\n    const colors = {\n      basic: '#28a745',\n      standard: '#ffc107',\n      comprehensive: '#dc3545',\n    };\n    return colors[node.recommendedLevel] || '#6c757d';\n  }\n\n  getNodeLabel(node) {\n    // Truncate long names\n    const maxLength = 12;\n    if (node.name.length > maxLength) {\n      return `${node.name.substring(0, maxLength - 3) }...`;\n    }\n    return node.name;\n  }\n\n  updateVisualization() {\n    if (!this.nodeElements || !this.linkElements) return;\n\n    // Filter nodes\n    const visibleNodes = this.nodes.filter(node => this.isNodeVisible(node));\n    const visibleNodeIds = new Set(visibleNodes.map(n => n.id));\n\n    // Filter links\n    const visibleLinks = this.currentFilters.showDependencies\n      ? this.links.filter(link =>\n        visibleNodeIds.has(link.source.id || link.source) &&\n                visibleNodeIds.has(link.target.id || link.target),\n      )\n      : [];\n\n    // Update node visibility\n    this.nodeElements\n      .style('opacity', d => this.isNodeVisible(d) ? 1 : 0.1)\n      .style('pointer-events', d => this.isNodeVisible(d) ? 'all' : 'none');\n\n    // Update link visibility\n    this.linkElements\n      .style('opacity', d => {\n        const sourceVisible = visibleNodeIds.has(d.source.id || d.source);\n        const targetVisible = visibleNodeIds.has(d.target.id || d.target);\n        return (sourceVisible && targetVisible && this.currentFilters.showDependencies) ? 0.6 : 0;\n      });\n\n    // Update label visibility\n    this.labelElements\n      .style('opacity', d => this.isNodeVisible(d) ? 1 : 0.1);\n\n    // Update simulation\n    this.simulation.nodes(visibleNodes);\n    this.simulation.force('link').links(visibleLinks);\n    this.simulation.alpha(0.3).restart();\n  }\n\n  isNodeVisible(node) {\n    // Category filter\n    if (!this.currentFilters.categories.has(node.category)) {\n      return false;\n    }\n\n    // Level filter\n    if (!this.currentFilters.levels.has(node.recommendedLevel)) {\n      return false;\n    }\n\n    // Search filter\n    if (this.currentFilters.searchTerm &&\n            !node.name.toLowerCase().includes(this.currentFilters.searchTerm)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  ticked() {\n    if (this.linkElements) {\n      this.linkElements\n        .attr('x1', d => d.source.x)\n        .attr('y1', d => d.source.y)\n        .attr('x2', d => d.target.x)\n        .attr('y2', d => d.target.y);\n    }\n\n    if (this.nodeElements) {\n      this.nodeElements\n        .attr('cx', d => d.x)\n        .attr('cy', d => d.y);\n    }\n\n    if (this.labelElements) {\n      this.labelElements\n        .attr('x', d => d.x)\n        .attr('y', d => d.y);\n    }\n  }\n\n  dragStarted(event, d) {\n    if (!event.active) this.simulation.alphaTarget(0.3).restart();\n    d.fx = d.x;\n    d.fy = d.y;\n  }\n\n  dragged(event, d) {\n    d.fx = event.x;\n    d.fy = event.y;\n  }\n\n  dragEnded(event, d) {\n    if (!event.active) this.simulation.alphaTarget(0);\n    d.fx = null;\n    d.fy = null;\n  }\n\n  handleMouseOver(event, d) {\n    // Highlight connected nodes and links\n    this.highlightConnectedElements(d);\n\n    // Show enhanced tooltip\n    this.showEnhancedTooltip(event, d);\n\n    // Add hover effect\n    d3.select(event.currentTarget)\n      .attr('stroke-width', 3)\n      .attr('stroke', '#ffc107')\n      .attr('filter', 'url(#glow)');\n  }\n\n  handleMouseOut(event, d) {\n    // Remove highlights\n    this.clearHighlights();\n\n    // Hide tooltip\n    this.hideTooltip();\n\n    // Remove hover effect\n    d3.select(event.currentTarget)\n      .attr('stroke-width', 2)\n      .attr('stroke', '#fff')\n      .attr('filter', null);\n  }\n\n  highlightConnectedElements(node) {\n    // Highlight connected links\n    this.linkElements\n      .style('stroke-width', link =>\n        (link.source.id === node.id || link.target.id === node.id) ? 4 : 1.5,\n      )\n      .style('stroke-opacity', link =>\n        (link.source.id === node.id || link.target.id === node.id) ? 1 : 0.3,\n      );\n\n    // Highlight connected nodes\n    this.nodeElements\n      .style('opacity', otherNode => {\n        const isConnected = this.links.some(link =>\n          (link.source.id === node.id && link.target.id === otherNode.id) ||\n                    (link.source.id === otherNode.id && link.target.id === node.id),\n        );\n        return isConnected ? 1 : 0.3;\n      });\n  }\n\n  showEnhancedTooltip(event, d) {\n    const tooltipContent = `\n            <div class=\"tooltip-content\">\n                <h4>${d.name}</h4>\n                <p><strong>Category:</strong> ${d.category}</p>\n                <p><strong>Recommended Level:</strong> ${d.recommendedLevel}</p>\n                ${d.effort ? `<p><strong>Effort:</strong> ${d.effort}/10</p>` : ''}\n                ${d.complexity ? `<p><strong>Complexity:</strong> ${d.complexity}/10</p>` : ''}\n                ${d.confidence ? `<p><strong>Confidence:</strong> ${d.confidence}%</p>` : ''}\n                <p><strong>Connections:</strong> ${this.getConnectionCount(d)}</p>\n            </div>\n        `;\n\n    this.tooltip\n      .html(tooltipContent)\n      .style('left', `${event.pageX + 10 }px`)\n      .style('top', `${event.pageY - 28 }px`)\n      .style('opacity', 1)\n      .style('max-width', '300px');\n  }\n\n  getConnectionCount(node) {\n    return this.links.filter(link =>\n      link.source.id === node.id || link.target.id === node.id,\n    ).length;\n  }\n\n  addZoomControls() {\n    const controls = d3.select('#visualization-controls')\n      .append('div')\n      .attr('class', 'zoom-controls')\n      .style('position', 'absolute')\n      .style('top', '10px')\n      .style('right', '10px')\n      .style('z-index', '1000');\n\n    controls.append('button')\n      .attr('class', 'btn btn-sm btn-outline-primary me-2')\n      .html('<i class=\"fas fa-plus\"></i>')\n      .on('click', () => {\n        this.svg.transition().duration(300).call(\n          this.zoom.scaleBy, 1.5,\n        );\n      });\n\n    controls.append('button')\n      .attr('class', 'btn btn-sm btn-outline-primary me-2')\n      .html('<i class=\"fas fa-minus\"></i>')\n      .on('click', () => {\n        this.svg.transition().duration(300).call(\n          this.zoom.scaleBy, 0.75,\n        );\n      });\n\n    controls.append('button')\n      .attr('class', 'btn btn-sm btn-outline-secondary')\n      .html('<i class=\"fas fa-sync-alt\"></i>')\n      .on('click', () => {\n        this.svg.transition().duration(300).call(\n          this.zoom.transform, d3.zoomIdentity,\n        );\n      });\n  }\n\n  nodeClicked(event, d) {\n    event.stopPropagation();\n    // Use the main app's showProcessDetails method instead of local implementation\n    if (window.seApp && typeof window.seApp.showProcessDetails === 'function') {\n      window.seApp.showProcessDetails(d.id);\n    }\n  }\n\n  showTooltip(event, d) {\n    const tooltip = this.tooltip;\n\n    tooltip.style('opacity', 1)\n      .html(`\n                <strong>${d.name}</strong><br/>\n                Level: <span class=\"level-badge level-${d.recommendedLevel}\">${d.recommendedLevel}</span><br/>\n                Effort: ${d.effort}/5<br/>\n                Confidence: ${Math.round(d.confidence * 100)}%\n            `)\n      .style('left', `${event.pageX + 10 }px`)\n      .style('top', `${event.pageY - 10 }px`);\n  }\n\n  hideTooltip() {\n    this.tooltip.style('opacity', 0);\n  }\n\n  toggleLabels(show) {\n    if (this.labelElements) {\n      this.labelElements.style('opacity', show ? 1 : 0);\n    }\n  }\n\n  changeLayout(layout) {\n    if (!this.simulation) return;\n\n    switch (layout) {\n      case 'circular':\n        this.applyCircularLayout();\n        break;\n      case 'hierarchical':\n        this.applyHierarchicalLayout();\n        break;\n      default:\n        this.applyForceLayout();\n    }\n  }\n\n  applyCircularLayout() {\n    const centerX = this.width / 2;\n    const centerY = this.height / 2;\n    const radius = Math.min(this.width, this.height) / 3;\n\n    this.nodes.forEach((node, i) => {\n      const angle = (2 * Math.PI * i) / this.nodes.length;\n      node.fx = centerX + radius * Math.cos(angle);\n      node.fy = centerY + radius * Math.sin(angle);\n    });\n\n    this.simulation.alpha(0.3).restart();\n  }\n\n  applyHierarchicalLayout() {\n    const categories = ['technical_management', 'technical'];\n    const categoryHeight = this.height / categories.length;\n\n    categories.forEach((category, catIndex) => {\n      const categoryNodes = this.nodes.filter(n => n.category === category);\n      const nodeWidth = this.width / (categoryNodes.length + 1);\n\n      categoryNodes.forEach((node, nodeIndex) => {\n        node.fx = (nodeIndex + 1) * nodeWidth;\n        node.fy = (catIndex + 0.5) * categoryHeight;\n      });\n    });\n\n    this.simulation.alpha(0.3).restart();\n  }\n\n  applyForceLayout() {\n    this.nodes.forEach(node => {\n      node.fx = null;\n      node.fy = null;\n    });\n\n    this.simulation\n      .force('center', d3.forceCenter(this.width / 2, this.height / 2))\n      .alpha(0.3)\n      .restart();\n  }\n\n  resetFilters() {\n    this.currentFilters = {\n      categories: new Set(['technical_management', 'technical']),\n      levels: new Set(['basic', 'standard', 'comprehensive']),\n      showDependencies: true,\n      searchTerm: '',\n    };\n\n    // Reset UI controls\n    document.getElementById('process-search').value = '';\n    document.getElementById('filter-technical-mgmt').checked = true;\n    document.getElementById('filter-technical').checked = true;\n    document.getElementById('filter-basic').checked = true;\n    document.getElementById('filter-standard').checked = true;\n    document.getElementById('filter-comprehensive').checked = true;\n    document.getElementById('show-dependencies').checked = true;\n\n    this.updateVisualization();\n  }\n\n  zoomIn() {\n    this.svg.transition().call(this.zoom.scaleBy, 1.5);\n  }\n\n  zoomOut() {\n    this.svg.transition().call(this.zoom.scaleBy, 1 / 1.5);\n  }\n\n  resetView() {\n    this.svg.transition().call(this.zoom.transform, d3.zoomIdentity);\n  }\n\n  // Public methods\n  highlightProcess(processId) {\n    if (this.nodeElements) {\n      this.nodeElements\n        .style('stroke', d => d.id === processId ? '#ff6b6b' : '#fff')\n        .style('stroke-width', d => d.id === processId ? 4 : 2);\n    }\n  }\n\n  clearHighlights() {\n    if (this.nodeElements) {\n      this.nodeElements\n        .style('stroke', '#fff')\n        .style('stroke-width', 2);\n    }\n  }\n\n  setupEventListeners() {\n    // Setup zoom control event listeners\n    const zoomInBtn = document.getElementById('zoom-in-btn');\n    const zoomOutBtn = document.getElementById('zoom-out-btn');\n    const resetViewBtn = document.getElementById('reset-view-btn');\n\n    if (zoomInBtn) {\n      zoomInBtn.addEventListener('click', () => this.zoomIn());\n    }\n    if (zoomOutBtn) {\n      zoomOutBtn.addEventListener('click', () => this.zoomOut());\n    }\n    if (resetViewBtn) {\n      resetViewBtn.addEventListener('click', () => this.resetView());\n    }\n  }\n}\n\n// Export for global access\nwindow.ProcessNetworkVisualizer = ProcessNetworkVisualizer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9jb21wb25lbnRzL3Zpc3VhbGl6YXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EseURBQXlELFNBQVM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx5REFBeUQsTUFBTTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCx1QkFBdUI7QUFDdkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSw4Q0FBOEM7QUFDdEQsUUFBUSwrQ0FBK0M7QUFDdkQsUUFBUSw4Q0FBOEM7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RCw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFlBQVksUUFBUSxtQkFBbUI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFNBQVM7QUFDdkQsc0RBQXNELGFBQWE7QUFDbkU7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1Q0FBdUM7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QixnREFBZ0QsV0FBVztBQUMzRCx5REFBeUQsbUJBQW1CO0FBQzVFLGtCQUFrQiwwQ0FBMEMsU0FBUztBQUNyRSxrQkFBa0Isa0RBQWtELGFBQWE7QUFDakYsa0JBQWtCLGtEQUFrRCxhQUFhO0FBQ2pGLG1EQUFtRCwyQkFBMkI7QUFDOUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQyx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQyx3REFBd0QsbUJBQW1CLElBQUksbUJBQW1CO0FBQ2xHLDBCQUEwQixTQUFTO0FBQ25DLDhCQUE4QiwrQkFBK0I7QUFDN0Q7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDLHVCQUF1QixrQkFBa0I7QUFDekM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NlLXRhaWxvcmluZy1mcmFtZXdvcmsvLi9qcy9jb21wb25lbnRzL3Zpc3VhbGl6YXRpb24uanM/MWYzYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFByb2Nlc3MgTmV0d29yayBWaXN1YWxpemVyIENvbXBvbmVudFxuICogQ3JlYXRlcyBpbnRlcmFjdGl2ZSBEMy5qcyBuZXR3b3JrIGRpYWdyYW1zIHNob3dpbmcgcHJvY2VzcyByZWxhdGlvbnNoaXBzXG4gKi9cblxuY2xhc3MgUHJvY2Vzc05ldHdvcmtWaXN1YWxpemVyIHtcbiAgY29uc3RydWN0b3IocHJvY2Vzc0RhdGEsIGRlcGVuZGVuY3lEYXRhLCBhcHApIHtcbiAgICB0aGlzLnByb2Nlc3NEYXRhID0gcHJvY2Vzc0RhdGE7XG4gICAgdGhpcy5kZXBlbmRlbmN5RGF0YSA9IGRlcGVuZGVuY3lEYXRhO1xuICAgIHRoaXMuYXBwID0gYXBwO1xuICAgIHRoaXMuc3ZnID0gbnVsbDtcbiAgICB0aGlzLnNpbXVsYXRpb24gPSBudWxsO1xuICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICB0aGlzLmxpbmtzID0gW107XG4gICAgdGhpcy53aWR0aCA9IDgwMDtcbiAgICB0aGlzLmhlaWdodCA9IDYwMDtcbiAgICB0aGlzLnpvb20gPSBudWxsO1xuICAgIHRoaXMuY3VycmVudEZpbHRlcnMgPSB7XG4gICAgICBjYXRlZ29yaWVzOiBuZXcgU2V0KFsndGVjaG5pY2FsX21hbmFnZW1lbnQnLCAndGVjaG5pY2FsJ10pLFxuICAgICAgbGV2ZWxzOiBuZXcgU2V0KFsnYmFzaWMnLCAnc3RhbmRhcmQnLCAnY29tcHJlaGVuc2l2ZSddKSxcbiAgICAgIHNob3dEZXBlbmRlbmNpZXM6IHRydWUsXG4gICAgICBzaG93TWV0cmljczogdHJ1ZSxcbiAgICAgIHNob3dSZWNvbW1lbmRhdGlvbnM6IHRydWUsXG4gICAgICBzZWFyY2hUZXJtOiAnJyxcbiAgICAgIGxheW91dFNldHRpbmdzOiB7XG4gICAgICAgIGNoYXJnZVN0cmVuZ3RoOiAtMjAwLFxuICAgICAgICBsaW5rU3RyZW5ndGg6IDAuNSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLnNldHVwQ29udGFpbmVyKCk7XG4gICAgdGhpcy5yZW5kZXJDb250cm9scygpO1xuICAgIHRoaXMucHJlcGFyZURhdGEoKTtcbiAgICB0aGlzLmNyZWF0ZVZpc3VhbGl6YXRpb24oKTtcbiAgICB0aGlzLnNldHVwRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIHNldHVwQ29udGFpbmVyKCkge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCduZXR3b3JrLXZpc3VhbGl6YXRpb24nKTtcbiAgICBpZiAoIWNvbnRhaW5lcikgcmV0dXJuO1xuXG4gICAgLy8gQ2xlYXIgZXhpc3RpbmcgY29udGVudFxuICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcblxuICAgIC8vIEdldCBjb250YWluZXIgZGltZW5zaW9uc1xuICAgIGNvbnN0IHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdGhpcy53aWR0aCA9IE1hdGgubWF4KDgwMCwgcmVjdC53aWR0aCAtIDIwKTtcbiAgICB0aGlzLmhlaWdodCA9IE1hdGgubWF4KDYwMCwgcmVjdC5oZWlnaHQgLSAyMCk7XG4gIH1cblxuICByZW5kZXJDb250cm9scygpIHtcbiAgICBjb25zdCBjb250cm9sc0NvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd2aXN1YWxpemF0aW9uLWNvbnRyb2xzJyk7XG4gICAgaWYgKCFjb250cm9sc0NvbnRhaW5lcikgcmV0dXJuO1xuXG4gICAgY29uc3QgaHRtbCA9IGBcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250cm9sLWdyb3VwXCI+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiY29udHJvbC1sYWJlbFwiPlNlYXJjaCBQcm9jZXNzZXM8L2xhYmVsPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cCBpbnB1dC1ncm91cC1zbVwiPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImlucHV0LWdyb3VwLXRleHRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiYmkgYmktc2VhcmNoXCI+PC9pPlxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJwcm9jZXNzLXNlYXJjaFwiIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJUeXBlIHRvIHNlYXJjaCBwcm9jZXNzZXMuLi5cIj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udHJvbC1ncm91cFwiPlxuICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImNvbnRyb2wtbGFiZWxcIj5Qcm9jZXNzIENhdGVnb3JpZXM8L2xhYmVsPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWNoZWNrIGZvcm0tY2hlY2stc21cIj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiZm9ybS1jaGVjay1pbnB1dFwiIHR5cGU9XCJjaGVja2JveFwiIGlkPVwiZmlsdGVyLXRlY2huaWNhbC1tZ210XCIgY2hlY2tlZD5cbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiZm9ybS1jaGVjay1sYWJlbFwiIGZvcj1cImZpbHRlci10ZWNobmljYWwtbWdtdFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgVGVjaG5pY2FsIE1hbmFnZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1jaGVjayBmb3JtLWNoZWNrLXNtXCI+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImZvcm0tY2hlY2staW5wdXRcIiB0eXBlPVwiY2hlY2tib3hcIiBpZD1cImZpbHRlci10ZWNobmljYWxcIiBjaGVja2VkPlxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJmb3JtLWNoZWNrLWxhYmVsXCIgZm9yPVwiZmlsdGVyLXRlY2huaWNhbFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgVGVjaG5pY2FsIFByb2Nlc3Nlc1xuICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250cm9sLWdyb3VwXCI+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiY29udHJvbC1sYWJlbFwiPlRhaWxvcmluZyBMZXZlbHM8L2xhYmVsPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWNoZWNrIGZvcm0tY2hlY2stc21cIj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiZm9ybS1jaGVjay1pbnB1dFwiIHR5cGU9XCJjaGVja2JveFwiIGlkPVwiZmlsdGVyLWJhc2ljXCIgY2hlY2tlZD5cbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiZm9ybS1jaGVjay1sYWJlbFwiIGZvcj1cImZpbHRlci1iYXNpY1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJsZXZlbC1iYWRnZSBsZXZlbC1iYXNpY1wiPkJhc2ljPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWNoZWNrIGZvcm0tY2hlY2stc21cIj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiZm9ybS1jaGVjay1pbnB1dFwiIHR5cGU9XCJjaGVja2JveFwiIGlkPVwiZmlsdGVyLXN0YW5kYXJkXCIgY2hlY2tlZD5cbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiZm9ybS1jaGVjay1sYWJlbFwiIGZvcj1cImZpbHRlci1zdGFuZGFyZFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJsZXZlbC1iYWRnZSBsZXZlbC1zdGFuZGFyZFwiPlN0YW5kYXJkPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWNoZWNrIGZvcm0tY2hlY2stc21cIj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiZm9ybS1jaGVjay1pbnB1dFwiIHR5cGU9XCJjaGVja2JveFwiIGlkPVwiZmlsdGVyLWNvbXByZWhlbnNpdmVcIiBjaGVja2VkPlxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJmb3JtLWNoZWNrLWxhYmVsXCIgZm9yPVwiZmlsdGVyLWNvbXByZWhlbnNpdmVcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwibGV2ZWwtYmFkZ2UgbGV2ZWwtY29tcHJlaGVuc2l2ZVwiPkNvbXByZWhlbnNpdmU8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRyb2wtZ3JvdXBcIj5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJjb250cm9sLWxhYmVsXCI+RGlzcGxheSBPcHRpb25zPC9sYWJlbD5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1jaGVjayBmb3JtLWNoZWNrLXNtXCI+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImZvcm0tY2hlY2staW5wdXRcIiB0eXBlPVwiY2hlY2tib3hcIiBpZD1cInNob3ctZGVwZW5kZW5jaWVzXCIgY2hlY2tlZD5cbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiZm9ybS1jaGVjay1sYWJlbFwiIGZvcj1cInNob3ctZGVwZW5kZW5jaWVzXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICBTaG93IERlcGVuZGVuY2llc1xuICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWNoZWNrIGZvcm0tY2hlY2stc21cIj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiZm9ybS1jaGVjay1pbnB1dFwiIHR5cGU9XCJjaGVja2JveFwiIGlkPVwic2hvdy1sYWJlbHNcIiBjaGVja2VkPlxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJmb3JtLWNoZWNrLWxhYmVsXCIgZm9yPVwic2hvdy1sYWJlbHNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFNob3cgTGFiZWxzXG4gICAgICAgICAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tY2hlY2sgZm9ybS1jaGVjay1zbVwiPlxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJmb3JtLWNoZWNrLWlucHV0XCIgdHlwZT1cImNoZWNrYm94XCIgaWQ9XCJzaG93LW1ldHJpY3NcIiBjaGVja2VkPlxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJmb3JtLWNoZWNrLWxhYmVsXCIgZm9yPVwic2hvdy1tZXRyaWNzXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICBTaG93IE1ldHJpY3NcbiAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1jaGVjayBmb3JtLWNoZWNrLXNtXCI+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImZvcm0tY2hlY2staW5wdXRcIiB0eXBlPVwiY2hlY2tib3hcIiBpZD1cInNob3ctcmVjb21tZW5kYXRpb25zXCIgY2hlY2tlZD5cbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiZm9ybS1jaGVjay1sYWJlbFwiIGZvcj1cInNob3ctcmVjb21tZW5kYXRpb25zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICBTaG93IFJlY29tbWVuZGF0aW9uc1xuICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250cm9sLWdyb3VwXCI+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiY29udHJvbC1sYWJlbFwiPkxheW91dDwvbGFiZWw+XG4gICAgICAgICAgICAgICAgPHNlbGVjdCBjbGFzcz1cImZvcm0tc2VsZWN0IGZvcm0tc2VsZWN0LXNtXCIgaWQ9XCJsYXlvdXQtc2VsZWN0XCI+XG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJmb3JjZVwiPkZvcmNlLURpcmVjdGVkPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJjaXJjdWxhclwiPkNpcmN1bGFyPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJoaWVyYXJjaGljYWxcIj5IaWVyYXJjaGljYWw8L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udHJvbC1ncm91cFwiPlxuICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImNvbnRyb2wtbGFiZWxcIj5Gb3JjZSBMYXlvdXQgU2V0dGluZ3M8L2xhYmVsPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cCBpbnB1dC1ncm91cC1zbVwiPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImlucHV0LWdyb3VwLXRleHRcIj5DaGFyZ2U8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwicmFuZ2VcIiBjbGFzcz1cImZvcm0tcmFuZ2VcIiBpZD1cImNoYXJnZS1zdHJlbmd0aFwiIG1pbj1cIi0xMDAwXCIgbWF4PVwiLTUwXCIgdmFsdWU9XCItMjAwXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtdGV4dFwiIGlkPVwiY2hhcmdlLXZhbHVlXCI+LTIwMDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAgaW5wdXQtZ3JvdXAtc21cIj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC10ZXh0XCI+TGluazwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJyYW5nZVwiIGNsYXNzPVwiZm9ybS1yYW5nZVwiIGlkPVwibGluay1zdHJlbmd0aFwiIG1pbj1cIjBcIiBtYXg9XCIyXCIgc3RlcD1cIjAuMVwiIHZhbHVlPVwiMC41XCI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtdGV4dFwiIGlkPVwibGluay12YWx1ZVwiPjAuNTwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udHJvbC1ncm91cFwiPlxuICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtcHJpbWFyeSBidG4tc20gdy0xMDBcIiBpZD1cInJlc2V0LWZpbHRlcnMtYnRuXCI+XG4gICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiYmkgYmktYXJyb3ctY2xvY2t3aXNlXCI+PC9pPlxuICAgICAgICAgICAgICAgICAgICBSZXNldCBGaWx0ZXJzXG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgYnRuLXNtIHctMTAwIG10LTJcIiBpZD1cImV4cG9ydC1uZXR3b3JrLWJ0blwiPlxuICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImJpIGJpLWRvd25sb2FkXCI+PC9pPlxuICAgICAgICAgICAgICAgICAgICBFeHBvcnQgTmV0d29ya1xuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtaW5mbyBidG4tc20gdy0xMDAgbXQtMlwiIGlkPVwiaGVscC1uZXR3b3JrLWJ0blwiPlxuICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImJpIGJpLXF1ZXN0aW9uLWNpcmNsZVwiPjwvaT5cbiAgICAgICAgICAgICAgICAgICAgSGVscCAmIFRpcHNcbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICBgO1xuXG4gICAgY29udHJvbHNDb250YWluZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgICB0aGlzLmF0dGFjaENvbnRyb2xFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgYXR0YWNoQ29udHJvbEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIC8vIFNlYXJjaCBmdW5jdGlvbmFsaXR5XG4gICAgY29uc3Qgc2VhcmNoSW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJvY2Vzcy1zZWFyY2gnKTtcbiAgICBpZiAoc2VhcmNoSW5wdXQpIHtcbiAgICAgIHNlYXJjaElucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKGUpID0+IHtcbiAgICAgICAgdGhpcy5jdXJyZW50RmlsdGVycy5zZWFyY2hUZXJtID0gZS50YXJnZXQudmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdGhpcy51cGRhdGVWaXN1YWxpemF0aW9uKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBDYXRlZ29yeSBmaWx0ZXJzXG4gICAgWyd0ZWNobmljYWwtbWdtdCcsICd0ZWNobmljYWwnXS5mb3JFYWNoKGNhdGVnb3J5ID0+IHtcbiAgICAgIGNvbnN0IGNoZWNrYm94ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYGZpbHRlci0ke2NhdGVnb3J5fWApO1xuICAgICAgaWYgKGNoZWNrYm94KSB7XG4gICAgICAgIGNoZWNrYm94LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIChlKSA9PiB7XG4gICAgICAgICAgY29uc3QgY2F0ZWdvcnlLZXkgPSBjYXRlZ29yeSA9PT0gJ3RlY2huaWNhbC1tZ210JyA/ICd0ZWNobmljYWxfbWFuYWdlbWVudCcgOiAndGVjaG5pY2FsJztcbiAgICAgICAgICBpZiAoZS50YXJnZXQuY2hlY2tlZCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RmlsdGVycy5jYXRlZ29yaWVzLmFkZChjYXRlZ29yeUtleSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEZpbHRlcnMuY2F0ZWdvcmllcy5kZWxldGUoY2F0ZWdvcnlLZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnVwZGF0ZVZpc3VhbGl6YXRpb24oKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBMZXZlbCBmaWx0ZXJzXG4gICAgWydiYXNpYycsICdzdGFuZGFyZCcsICdjb21wcmVoZW5zaXZlJ10uZm9yRWFjaChsZXZlbCA9PiB7XG4gICAgICBjb25zdCBjaGVja2JveCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBmaWx0ZXItJHtsZXZlbH1gKTtcbiAgICAgIGlmIChjaGVja2JveCkge1xuICAgICAgICBjaGVja2JveC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoZSkgPT4ge1xuICAgICAgICAgIGlmIChlLnRhcmdldC5jaGVja2VkKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRGaWx0ZXJzLmxldmVscy5hZGQobGV2ZWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRGaWx0ZXJzLmxldmVscy5kZWxldGUobGV2ZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnVwZGF0ZVZpc3VhbGl6YXRpb24oKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBEaXNwbGF5IG9wdGlvbnNcbiAgICBjb25zdCBzaG93RGVwc0NoZWNrYm94ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Nob3ctZGVwZW5kZW5jaWVzJyk7XG4gICAgaWYgKHNob3dEZXBzQ2hlY2tib3gpIHtcbiAgICAgIHNob3dEZXBzQ2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGUpID0+IHtcbiAgICAgICAgdGhpcy5jdXJyZW50RmlsdGVycy5zaG93RGVwZW5kZW5jaWVzID0gZS50YXJnZXQuY2hlY2tlZDtcbiAgICAgICAgdGhpcy51cGRhdGVWaXN1YWxpemF0aW9uKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBzaG93TGFiZWxzQ2hlY2tib3ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2hvdy1sYWJlbHMnKTtcbiAgICBpZiAoc2hvd0xhYmVsc0NoZWNrYm94KSB7XG4gICAgICBzaG93TGFiZWxzQ2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGUpID0+IHtcbiAgICAgICAgdGhpcy50b2dnbGVMYWJlbHMoZS50YXJnZXQuY2hlY2tlZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBMYXlvdXQgc2VsZWN0aW9uXG4gICAgY29uc3QgbGF5b3V0U2VsZWN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xheW91dC1zZWxlY3QnKTtcbiAgICBpZiAobGF5b3V0U2VsZWN0KSB7XG4gICAgICBsYXlvdXRTZWxlY3QuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGUpID0+IHtcbiAgICAgICAgdGhpcy5jaGFuZ2VMYXlvdXQoZS50YXJnZXQudmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRm9yY2UgbGF5b3V0IHNldHRpbmdzXG4gICAgY29uc3QgY2hhcmdlU2xpZGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NoYXJnZS1zdHJlbmd0aCcpO1xuICAgIGNvbnN0IGNoYXJnZVZhbHVlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NoYXJnZS12YWx1ZScpO1xuICAgIGlmIChjaGFyZ2VTbGlkZXIgJiYgY2hhcmdlVmFsdWUpIHtcbiAgICAgIGNoYXJnZVNsaWRlci5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIChlKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcGFyc2VJbnQoZS50YXJnZXQudmFsdWUpO1xuICAgICAgICBjaGFyZ2VWYWx1ZS50ZXh0Q29udGVudCA9IHZhbHVlO1xuICAgICAgICB0aGlzLmN1cnJlbnRGaWx0ZXJzLmxheW91dFNldHRpbmdzLmNoYXJnZVN0cmVuZ3RoID0gdmFsdWU7XG4gICAgICAgIHRoaXMudXBkYXRlRm9yY2VMYXlvdXQoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGxpbmtTbGlkZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGluay1zdHJlbmd0aCcpO1xuICAgIGNvbnN0IGxpbmtWYWx1ZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsaW5rLXZhbHVlJyk7XG4gICAgaWYgKGxpbmtTbGlkZXIgJiYgbGlua1ZhbHVlKSB7XG4gICAgICBsaW5rU2xpZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKGUpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJzZUZsb2F0KGUudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgbGlua1ZhbHVlLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY3VycmVudEZpbHRlcnMubGF5b3V0U2V0dGluZ3MubGlua1N0cmVuZ3RoID0gdmFsdWU7XG4gICAgICAgIHRoaXMudXBkYXRlRm9yY2VMYXlvdXQoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIERpc3BsYXkgb3B0aW9uc1xuICAgIGNvbnN0IHNob3dNZXRyaWNzQ2hlY2tib3ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2hvdy1tZXRyaWNzJyk7XG4gICAgaWYgKHNob3dNZXRyaWNzQ2hlY2tib3gpIHtcbiAgICAgIHNob3dNZXRyaWNzQ2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGUpID0+IHtcbiAgICAgICAgdGhpcy5jdXJyZW50RmlsdGVycy5zaG93TWV0cmljcyA9IGUudGFyZ2V0LmNoZWNrZWQ7XG4gICAgICAgIHRoaXMudXBkYXRlVmlzdWFsaXphdGlvbigpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2hvd1JlY3NDaGVja2JveCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaG93LXJlY29tbWVuZGF0aW9ucycpO1xuICAgIGlmIChzaG93UmVjc0NoZWNrYm94KSB7XG4gICAgICBzaG93UmVjc0NoZWNrYm94LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIChlKSA9PiB7XG4gICAgICAgIHRoaXMuY3VycmVudEZpbHRlcnMuc2hvd1JlY29tbWVuZGF0aW9ucyA9IGUudGFyZ2V0LmNoZWNrZWQ7XG4gICAgICAgIHRoaXMudXBkYXRlVmlzdWFsaXphdGlvbigpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRXhwb3J0IGJ1dHRvblxuICAgIGNvbnN0IGV4cG9ydEJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdleHBvcnQtbmV0d29yay1idG4nKTtcbiAgICBpZiAoZXhwb3J0QnRuKSB7XG4gICAgICBleHBvcnRCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuZXhwb3J0TmV0d29yaygpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gSGVscCBidXR0b25cbiAgICBjb25zdCBoZWxwQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2hlbHAtbmV0d29yay1idG4nKTtcbiAgICBpZiAoaGVscEJ0bikge1xuICAgICAgaGVscEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgdGhpcy5zaG93SGVscE1vZGFsKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBmaWx0ZXJzXG4gICAgY29uc3QgcmVzZXRCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVzZXQtZmlsdGVycy1idG4nKTtcbiAgICBpZiAocmVzZXRCdG4pIHtcbiAgICAgIHJlc2V0QnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICB0aGlzLnJlc2V0RmlsdGVycygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlRm9yY2VMYXlvdXQoKSB7XG4gICAgaWYgKHRoaXMuc2ltdWxhdGlvbikge1xuICAgICAgdGhpcy5zaW11bGF0aW9uLmZvcmNlKCdjaGFyZ2UnLCBkMy5mb3JjZU1hbnlCb2R5KCkuc3RyZW5ndGgodGhpcy5jdXJyZW50RmlsdGVycy5sYXlvdXRTZXR0aW5ncy5jaGFyZ2VTdHJlbmd0aCkpO1xuICAgICAgdGhpcy5zaW11bGF0aW9uLmZvcmNlKCdsaW5rJywgZDMuZm9yY2VMaW5rKHRoaXMubGlua3MpLnN0cmVuZ3RoKHRoaXMuY3VycmVudEZpbHRlcnMubGF5b3V0U2V0dGluZ3MubGlua1N0cmVuZ3RoKSk7XG4gICAgICB0aGlzLnNpbXVsYXRpb24uYWxwaGEoMC4zKS5yZXN0YXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgZXhwb3J0TmV0d29yaygpIHtcbiAgICBjb25zdCBzdmdFbGVtZW50ID0gdGhpcy5zdmcubm9kZSgpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSBuZXcgWE1MU2VyaWFsaXplcigpO1xuICAgIGNvbnN0IHNvdXJjZSA9IHNlcmlhbGl6ZXIuc2VyaWFsaXplVG9TdHJpbmcoc3ZnRWxlbWVudCk7XG5cbiAgICAvLyBBZGQgbmFtZXNwYWNlXG4gICAgY29uc3Qgc3ZnV2l0aE5hbWVzcGFjZSA9IHNvdXJjZS5yZXBsYWNlKCc8c3ZnJywgJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiJyk7XG5cbiAgICAvLyBDcmVhdGUgZG93bmxvYWQgbGlua1xuICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbc3ZnV2l0aE5hbWVzcGFjZV0sIHsgdHlwZTogJ2ltYWdlL3N2Zyt4bWwnIH0pO1xuICAgIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cbiAgICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIGEuaHJlZiA9IHVybDtcbiAgICBhLmRvd25sb2FkID0gJ3NlLXByb2Nlc3MtbmV0d29yay5zdmcnO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYSk7XG4gICAgYS5jbGljaygpO1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoYSk7XG4gICAgVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xuICB9XG5cbiAgc2hvd0hlbHBNb2RhbCgpIHtcbiAgICBjb25zdCBtb2RhbEh0bWwgPSBgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWwgZmFkZVwiIGlkPVwibmV0d29yay1oZWxwLW1vZGFsXCIgdGFiaW5kZXg9XCItMVwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1kaWFsb2cgbW9kYWwtbGdcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1oZWFkZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDUgY2xhc3M9XCJtb2RhbC10aXRsZVwiPk5ldHdvcmsgVmlzdWFsaXphdGlvbiBIZWxwPC9oNT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0bi1jbG9zZVwiIGRhdGEtYnMtZGlzbWlzcz1cIm1vZGFsXCI+PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1ib2R5XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGg2PkludGVyYWN0aXZlIEZlYXR1cmVzPC9oNj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT48c3Ryb25nPkRyYWcgbm9kZXM8L3N0cm9uZz4gdG8gcmVwb3NpdGlvbiB0aGVtPC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPjxzdHJvbmc+Q2xpY2sgbm9kZXM8L3N0cm9uZz4gdG8gdmlldyBwcm9jZXNzIGRldGFpbHM8L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+PHN0cm9uZz5Nb3VzZSB3aGVlbDwvc3Ryb25nPiB0byB6b29tIGluL291dDwvbGk+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT48c3Ryb25nPkRyYWcgYmFja2dyb3VuZDwvc3Ryb25nPiB0byBwYW4gdGhlIHZpZXc8L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGg2PkZpbHRlcmluZyBPcHRpb25zPC9oNj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT48c3Ryb25nPlNlYXJjaDwvc3Ryb25nPjogRmlsdGVyIHByb2Nlc3NlcyBieSBuYW1lPC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPjxzdHJvbmc+Q2F0ZWdvcmllczwvc3Ryb25nPjogU2hvdy9oaWRlIHByb2Nlc3MgY2F0ZWdvcmllczwvbGk+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT48c3Ryb25nPkxldmVsczwvc3Ryb25nPjogRmlsdGVyIGJ5IHRhaWxvcmluZyBsZXZlbHM8L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+PHN0cm9uZz5EZXBlbmRlbmNpZXM8L3N0cm9uZz46IFRvZ2dsZSBkZXBlbmRlbmN5IHZpc2liaWxpdHk8L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGg2PkxheW91dCBDb250cm9sczwvaDY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+PHN0cm9uZz5Gb3JjZS1EaXJlY3RlZDwvc3Ryb25nPjogRHluYW1pYyBwaHlzaWNzLWJhc2VkIGxheW91dDwvbGk+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT48c3Ryb25nPkNpcmN1bGFyPC9zdHJvbmc+OiBPcmdhbml6ZWQgY2lyY3VsYXIgYXJyYW5nZW1lbnQ8L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+PHN0cm9uZz5IaWVyYXJjaGljYWw8L3N0cm9uZz46IFRyZWUtbGlrZSBzdHJ1Y3R1cmU8L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+PHN0cm9uZz5DaGFyZ2UvTGluazwvc3Ryb25nPjogQWRqdXN0IG5vZGUgcmVwdWxzaW9uIGFuZCBsaW5rIHN0cmVuZ3RoPC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtZm9vdGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXNlY29uZGFyeVwiIGRhdGEtYnMtZGlzbWlzcz1cIm1vZGFsXCI+Q2xvc2U8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICBgO1xuXG4gICAgLy8gUmVtb3ZlIGV4aXN0aW5nIG1vZGFsIGlmIGFueVxuICAgIGNvbnN0IGV4aXN0aW5nTW9kYWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbmV0d29yay1oZWxwLW1vZGFsJyk7XG4gICAgaWYgKGV4aXN0aW5nTW9kYWwpIHtcbiAgICAgIGV4aXN0aW5nTW9kYWwucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1vZGFsIHRvIERPTVxuICAgIGRvY3VtZW50LmJvZHkuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCBtb2RhbEh0bWwpO1xuXG4gICAgLy8gU2hvdyBtb2RhbFxuICAgIGNvbnN0IG1vZGFsID0gbmV3IGJvb3RzdHJhcC5Nb2RhbChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbmV0d29yay1oZWxwLW1vZGFsJykpO1xuICAgIG1vZGFsLnNob3coKTtcbiAgfVxuXG4gIHByZXBhcmVEYXRhKCkge1xuICAgIGNvbnN0IHByb2Nlc3NlcyA9IHRoaXMucHJvY2Vzc0RhdGEucHJvY2Vzc2VzIHx8IFtdO1xuICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IHRoaXMuZGVwZW5kZW5jeURhdGEuZGVwZW5kZW5jaWVzIHx8IFtdO1xuICAgIGNvbnN0IHJlY29tbWVuZGF0aW9ucyA9IHRoaXMuYXBwLmdldEFzc2Vzc21lbnREYXRhKCkucmVjb21tZW5kYXRpb25zO1xuXG4gICAgLy8gQ3JlYXRlIG5vZGVzXG4gICAgdGhpcy5ub2RlcyA9IHByb2Nlc3Nlcy5tYXAocHJvY2VzcyA9PiB7XG4gICAgICBjb25zdCByZWNvbW1lbmRhdGlvbiA9IHJlY29tbWVuZGF0aW9ucz8uW3Byb2Nlc3MuaWRdO1xuICAgICAgY29uc3QgcmVjb21tZW5kZWRMZXZlbCA9IHJlY29tbWVuZGF0aW9uPy5yZWNvbW1lbmRlZExldmVsIHx8ICdiYXNpYyc7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBwcm9jZXNzLmlkLFxuICAgICAgICBuYW1lOiBwcm9jZXNzLm5hbWUsXG4gICAgICAgIGNhdGVnb3J5OiBwcm9jZXNzLmNhdGVnb3J5LFxuICAgICAgICBkZXNjcmlwdGlvbjogcHJvY2Vzcy5kZXNjcmlwdGlvbixcbiAgICAgICAgcmVjb21tZW5kZWRMZXZlbDogcmVjb21tZW5kZWRMZXZlbCxcbiAgICAgICAgZWZmb3J0OiByZWNvbW1lbmRhdGlvbj8uZWZmb3J0IHx8IDEsXG4gICAgICAgIGNvbXBsZXhpdHk6IHJlY29tbWVuZGF0aW9uPy5jb21wbGV4aXR5IHx8IDEsXG4gICAgICAgIGNvbmZpZGVuY2U6IHJlY29tbWVuZGF0aW9uPy5jb25maWRlbmNlIHx8IDAuOCxcbiAgICAgICAgeDogTWF0aC5yYW5kb20oKSAqIHRoaXMud2lkdGgsXG4gICAgICAgIHk6IE1hdGgucmFuZG9tKCkgKiB0aGlzLmhlaWdodCxcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBDcmVhdGUgbGlua3MgZnJvbSBkZXBlbmRlbmNpZXNcbiAgICB0aGlzLmxpbmtzID0gZGVwZW5kZW5jaWVzLm1hcChkZXAgPT4gKHtcbiAgICAgIHNvdXJjZTogZGVwLnNvdXJjZSxcbiAgICAgIHRhcmdldDogZGVwLnRhcmdldCxcbiAgICAgIHR5cGU6IGRlcC50eXBlIHx8ICdob3Jpem9udGFsJyxcbiAgICAgIHNvdXJjZUxldmVsOiBkZXAuc291cmNlTGV2ZWwsXG4gICAgICB0YXJnZXRMZXZlbDogZGVwLnRhcmdldExldmVsLFxuICAgICAgc3RyZW5ndGg6IGRlcC50eXBlID09PSAndmVydGljYWwnID8gMC44IDogMC40LFxuICAgIH0pKTtcbiAgfVxuXG4gIGNyZWF0ZVZpc3VhbGl6YXRpb24oKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25ldHdvcmstdmlzdWFsaXphdGlvbicpO1xuICAgIGlmICghY29udGFpbmVyKSByZXR1cm47XG5cbiAgICAvLyBDcmVhdGUgU1ZHIGNvbnRhaW5lciB3aXRoIHJlc3BvbnNpdmUgZGVzaWduXG4gICAgdGhpcy5zdmcgPSBkMy5zZWxlY3QoY29udGFpbmVyKVxuICAgICAgLmFwcGVuZCgnc3ZnJylcbiAgICAgIC5hdHRyKCd3aWR0aCcsICcxMDAlJylcbiAgICAgIC5hdHRyKCdoZWlnaHQnLCAnMTAwJScpXG4gICAgICAuYXR0cigndmlld0JveCcsIFswLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodF0pXG4gICAgICAuYXR0cigncHJlc2VydmVBc3BlY3RSYXRpbycsICd4TWlkWU1pZCBtZWV0JylcbiAgICAgIC5hdHRyKCdjbGFzcycsICduZXR3b3JrLXN2ZycpXG4gICAgICAuc3R5bGUoJ2JhY2tncm91bmQnLCAnI2Y4ZjlmYScpO1xuXG4gICAgLy8gQWRkIHpvb20gYmVoYXZpb3Igd2l0aCBzbW9vdGggdHJhbnNpdGlvbnNcbiAgICB0aGlzLnpvb20gPSBkMy56b29tKClcbiAgICAgIC5zY2FsZUV4dGVudChbMC4xLCA4XSlcbiAgICAgIC50cmFuc2xhdGVFeHRlbnQoW1swLCAwXSwgW3RoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XV0pXG4gICAgICAub24oJ3pvb20nLCAoZXZlbnQpID0+IHtcbiAgICAgICAgdGhpcy5zdmcuc2VsZWN0KCcuem9vbS1jb250YWluZXInKS5hdHRyKCd0cmFuc2Zvcm0nLCBldmVudC50cmFuc2Zvcm0pO1xuICAgICAgfSk7XG5cbiAgICB0aGlzLnN2Zy5jYWxsKHRoaXMuem9vbSlcbiAgICAgIC5jYWxsKHRoaXMuem9vbS50cmFuc2Zvcm0sIGQzLnpvb21JZGVudGl0eSk7XG5cbiAgICAvLyBDcmVhdGUgY29udGFpbmVyIGZvciB6b29tYWJsZSBjb250ZW50XG4gICAgY29uc3Qgem9vbUNvbnRhaW5lciA9IHRoaXMuc3ZnLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ3pvb20tY29udGFpbmVyJyk7XG5cbiAgICAvLyBBZGQgc29waGlzdGljYXRlZCBhcnJvdyBtYXJrZXJzIGZvciBkaWZmZXJlbnQgbGluayB0eXBlc1xuICAgIGNvbnN0IGRlZnMgPSB0aGlzLnN2Zy5hcHBlbmQoJ2RlZnMnKTtcblxuICAgIGNvbnN0IG1hcmtlclR5cGVzID0gW1xuICAgICAgeyBpZDogJ2RlcGVuZGVuY3knLCBjb2xvcjogJyNkYzM1NDUnLCB3aWR0aDogNCB9LFxuICAgICAgeyBpZDogJ2luZm9ybWF0aW9uJywgY29sb3I6ICcjMGQ2ZWZkJywgd2lkdGg6IDMgfSxcbiAgICAgIHsgaWQ6ICdzZXF1ZW50aWFsJywgY29sb3I6ICcjMTk4NzU0Jywgd2lkdGg6IDIgfSxcbiAgICBdO1xuXG4gICAgbWFya2VyVHlwZXMuZm9yRWFjaCh0eXBlID0+IHtcbiAgICAgIGRlZnMuYXBwZW5kKCdtYXJrZXInKVxuICAgICAgICAuYXR0cignaWQnLCBgYXJyb3ctJHt0eXBlLmlkfWApXG4gICAgICAgIC5hdHRyKCd2aWV3Qm94JywgJzAgLTUgMTAgMTAnKVxuICAgICAgICAuYXR0cigncmVmWCcsIDE4KVxuICAgICAgICAuYXR0cigncmVmWScsIDApXG4gICAgICAgIC5hdHRyKCdtYXJrZXJXaWR0aCcsIDgpXG4gICAgICAgIC5hdHRyKCdtYXJrZXJIZWlnaHQnLCA4KVxuICAgICAgICAuYXR0cignb3JpZW50JywgJ2F1dG8nKVxuICAgICAgICAuYXBwZW5kKCdwYXRoJylcbiAgICAgICAgLmF0dHIoJ2QnLCAnTTAsLTVMMTAsMEwwLDUnKVxuICAgICAgICAuYXR0cignZmlsbCcsIHR5cGUuY29sb3IpXG4gICAgICAgIC5hdHRyKCdzdHJva2UnLCB0eXBlLmNvbG9yKVxuICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgdHlwZS53aWR0aCk7XG4gICAgfSk7XG5cbiAgICAvLyBDcmVhdGUgZW5oYW5jZWQgZm9yY2Ugc2ltdWxhdGlvbiB3aXRoIGN1c3RvbSBwYXJhbWV0ZXJzXG4gICAgdGhpcy5zaW11bGF0aW9uID0gZDMuZm9yY2VTaW11bGF0aW9uKHRoaXMubm9kZXMpXG4gICAgICAuZm9yY2UoJ2xpbmsnLCBkMy5mb3JjZUxpbmsodGhpcy5saW5rcylcbiAgICAgICAgLmlkKGQgPT4gZC5pZClcbiAgICAgICAgLnN0cmVuZ3RoKHRoaXMuY3VycmVudEZpbHRlcnMubGF5b3V0U2V0dGluZ3MubGlua1N0cmVuZ3RoKVxuICAgICAgICAuZGlzdGFuY2UoMTAwKSlcbiAgICAgIC5mb3JjZSgnY2hhcmdlJywgZDMuZm9yY2VNYW55Qm9keSgpLnN0cmVuZ3RoKHRoaXMuY3VycmVudEZpbHRlcnMubGF5b3V0U2V0dGluZ3MuY2hhcmdlU3RyZW5ndGgpKVxuICAgICAgLmZvcmNlKCdjZW50ZXInLCBkMy5mb3JjZUNlbnRlcih0aGlzLndpZHRoIC8gMiwgdGhpcy5oZWlnaHQgLyAyKSlcbiAgICAgIC5mb3JjZSgnY29sbGlzaW9uJywgZDMuZm9yY2VDb2xsaWRlKCkucmFkaXVzKDQ1KSlcbiAgICAgIC5mb3JjZSgneCcsIGQzLmZvcmNlWCh0aGlzLndpZHRoIC8gMikuc3RyZW5ndGgoMC4wNSkpXG4gICAgICAuZm9yY2UoJ3knLCBkMy5mb3JjZVkodGhpcy5oZWlnaHQgLyAyKS5zdHJlbmd0aCgwLjA1KSk7XG5cbiAgICAvLyBEcmF3IGxpbmtzIHdpdGggZW5oYW5jZWQgc3R5bGluZ1xuICAgIHRoaXMubGlua0VsZW1lbnRzID0gem9vbUNvbnRhaW5lci5hcHBlbmQoJ2cnKVxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xpbmtzJylcbiAgICAgIC5zZWxlY3RBbGwoJ2xpbmUnKVxuICAgICAgLmRhdGEodGhpcy5saW5rcylcbiAgICAgIC5lbnRlcigpXG4gICAgICAuYXBwZW5kKCdsaW5lJylcbiAgICAgIC5hdHRyKCdjbGFzcycsIGQgPT4gYG5ldHdvcmstbGluayBsaW5rLSR7ZC50eXBlfWApXG4gICAgICAuYXR0cignbWFya2VyLWVuZCcsIGQgPT4gYHVybCgjYXJyb3ctJHtkLnR5cGV9KWApXG4gICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgZCA9PiB7XG4gICAgICAgIGNvbnN0IHN0cmVuZ3RocyA9IHsgZGVwZW5kZW5jeTogMywgaW5mb3JtYXRpb246IDIsIHNlcXVlbnRpYWw6IDEuNSB9O1xuICAgICAgICByZXR1cm4gc3RyZW5ndGhzW2QudHlwZV0gfHwgMS41O1xuICAgICAgfSlcbiAgICAgIC5hdHRyKCdzdHJva2Utb3BhY2l0eScsIDAuOClcbiAgICAgIC5hdHRyKCdzdHJva2UtbGluZWNhcCcsICdyb3VuZCcpO1xuXG4gICAgLy8gRHJhdyBub2RlcyB3aXRoIGVuaGFuY2VkIHN0eWxpbmcgYW5kIGludGVyYWN0aXZpdHlcbiAgICB0aGlzLm5vZGVFbGVtZW50cyA9IHpvb21Db250YWluZXIuYXBwZW5kKCdnJylcbiAgICAgIC5hdHRyKCdjbGFzcycsICdub2RlcycpXG4gICAgICAuc2VsZWN0QWxsKCdjaXJjbGUnKVxuICAgICAgLmRhdGEodGhpcy5ub2RlcylcbiAgICAgIC5lbnRlcigpXG4gICAgICAuYXBwZW5kKCdjaXJjbGUnKVxuICAgICAgLmF0dHIoJ2NsYXNzJywgZCA9PiBgbmV0d29yay1ub2RlIG5vZGUtJHtkLmNhdGVnb3J5fSBsZXZlbC0ke2QucmVjb21tZW5kZWRMZXZlbH1gKVxuICAgICAgLmF0dHIoJ3InLCBkID0+IHtcbiAgICAgICAgLy8gU2NhbGUgbm9kZSBzaXplIGJhc2VkIG9uIGltcG9ydGFuY2UvY29tcGxleGl0eVxuICAgICAgICBjb25zdCBiYXNlU2l6ZSA9IDIwO1xuICAgICAgICBjb25zdCBjb21wbGV4aXR5TXVsdGlwbGllciA9IGQuY29tcGxleGl0eSA/IGQuY29tcGxleGl0eSAvIDEwIDogMTtcbiAgICAgICAgcmV0dXJuIGJhc2VTaXplICogY29tcGxleGl0eU11bHRpcGxpZXI7XG4gICAgICB9KVxuICAgICAgLmF0dHIoJ2ZpbGwnLCBkID0+IHRoaXMuZ2V0Tm9kZUNvbG9yKGQpKVxuICAgICAgLmF0dHIoJ3N0cm9rZScsICcjZmZmJylcbiAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAyKVxuICAgICAgLmF0dHIoJ2N1cnNvcicsICdwb2ludGVyJylcbiAgICAgIC5jYWxsKGQzLmRyYWcoKVxuICAgICAgICAub24oJ3N0YXJ0JywgKGV2ZW50LCBkKSA9PiB0aGlzLmRyYWdTdGFydGVkKGV2ZW50LCBkKSlcbiAgICAgICAgLm9uKCdkcmFnJywgKGV2ZW50LCBkKSA9PiB0aGlzLmRyYWdnZWQoZXZlbnQsIGQpKVxuICAgICAgICAub24oJ2VuZCcsIChldmVudCwgZCkgPT4gdGhpcy5kcmFnRW5kZWQoZXZlbnQsIGQpKSxcbiAgICAgIClcbiAgICAgIC5vbignbW91c2VvdmVyJywgKGV2ZW50LCBkKSA9PiB0aGlzLnNob3dUb29sdGlwKGV2ZW50LCBkKSlcbiAgICAgIC5vbignbW91c2VvdXQnLCAoKSA9PiB0aGlzLmhpZGVUb29sdGlwKCkpXG4gICAgICAub24oJ2NsaWNrJywgKGV2ZW50LCBkKSA9PiB0aGlzLm5vZGVDbGlja2VkKGV2ZW50LCBkKSk7XG5cbiAgICAvLyBBZGQgZHluYW1pYyBsYWJlbHMgd2l0aCBjb25kaXRpb25hbCB2aXNpYmlsaXR5XG4gICAgdGhpcy5sYWJlbEVsZW1lbnRzID0gem9vbUNvbnRhaW5lci5hcHBlbmQoJ2cnKVxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xhYmVscycpXG4gICAgICAuc2VsZWN0QWxsKCd0ZXh0JylcbiAgICAgIC5kYXRhKHRoaXMubm9kZXMpXG4gICAgICAuZW50ZXIoKVxuICAgICAgLmFwcGVuZCgndGV4dCcpXG4gICAgICAuYXR0cignY2xhc3MnLCAnbmV0d29yay10ZXh0JylcbiAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxuICAgICAgLmF0dHIoJ2R5JywgZCA9PiB7XG4gICAgICAgIGNvbnN0IGJhc2VPZmZzZXQgPSAzNTtcbiAgICAgICAgY29uc3Qgc2l6ZU9mZnNldCA9IChkLmNvbXBsZXhpdHkgPyBkLmNvbXBsZXhpdHkgLyAxMCA6IDEpICogNTtcbiAgICAgICAgcmV0dXJuIGJhc2VPZmZzZXQgKyBzaXplT2Zmc2V0O1xuICAgICAgfSlcbiAgICAgIC5hdHRyKCdmb250LXNpemUnLCAnMTJweCcpXG4gICAgICAuYXR0cignZm9udC13ZWlnaHQnLCAnNjAwJylcbiAgICAgIC5hdHRyKCdmaWxsJywgJyMyYzNlNTAnKVxuICAgICAgLmF0dHIoJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKVxuICAgICAgLmF0dHIoJ3BhaW50LW9yZGVyJywgJ3N0cm9rZScpXG4gICAgICAuYXR0cignc3Ryb2tlJywgJyNmZmZmZmYnKVxuICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDMpXG4gICAgICAuYXR0cignc3Ryb2tlLWxpbmVjYXAnLCAncm91bmQnKVxuICAgICAgLmF0dHIoJ3N0cm9rZS1saW5lam9pbicsICdyb3VuZCcpXG4gICAgICAudGV4dChkID0+IHRoaXMuZ2V0Tm9kZUxhYmVsKGQpKTtcblxuICAgIC8vIEFkZCBtZXRyaWMgYmFkZ2VzIGlmIGVuYWJsZWRcbiAgICB0aGlzLm1ldHJpY0VsZW1lbnRzID0gem9vbUNvbnRhaW5lci5hcHBlbmQoJ2cnKVxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ21ldHJpY3MnKVxuICAgICAgLnNlbGVjdEFsbCgndGV4dCcpXG4gICAgICAuZGF0YSh0aGlzLm5vZGVzKVxuICAgICAgLmVudGVyKClcbiAgICAgIC5hcHBlbmQoJ3RleHQnKVxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ25vZGUtbWV0cmljJylcbiAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxuICAgICAgLmF0dHIoJ2R5JywgZCA9PiB7XG4gICAgICAgIGNvbnN0IGJhc2VPZmZzZXQgPSAtMjU7XG4gICAgICAgIGNvbnN0IHNpemVPZmZzZXQgPSAoZC5jb21wbGV4aXR5ID8gZC5jb21wbGV4aXR5IC8gMTAgOiAxKSAqIDU7XG4gICAgICAgIHJldHVybiBiYXNlT2Zmc2V0IC0gc2l6ZU9mZnNldDtcbiAgICAgIH0pXG4gICAgICAuYXR0cignZm9udC1zaXplJywgJzEwcHgnKVxuICAgICAgLmF0dHIoJ2ZpbGwnLCAnIzZjNzU3ZCcpXG4gICAgICAuYXR0cigncG9pbnRlci1ldmVudHMnLCAnbm9uZScpXG4gICAgICAudGV4dChkID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnRGaWx0ZXJzLnNob3dNZXRyaWNzKSByZXR1cm4gJyc7XG4gICAgICAgIGNvbnN0IG1ldHJpY3MgPSBbXTtcbiAgICAgICAgaWYgKGQuZWZmb3J0KSBtZXRyaWNzLnB1c2goYEVmZm9ydDogJHtkLmVmZm9ydH1gKTtcbiAgICAgICAgaWYgKGQuY29tcGxleGl0eSkgbWV0cmljcy5wdXNoKGBDb21wbGV4aXR5OiAke2QuY29tcGxleGl0eX1gKTtcbiAgICAgICAgcmV0dXJuIG1ldHJpY3Muam9pbignIHwgJyk7XG4gICAgICB9KTtcblxuICAgIC8vIENyZWF0ZSB0b29sdGlwXG4gICAgdGhpcy50b29sdGlwID0gZDMuc2VsZWN0KCdib2R5JylcbiAgICAgIC5hcHBlbmQoJ2RpdicpXG4gICAgICAuYXR0cignY2xhc3MnLCAnbmV0d29yay10b29sdGlwJylcbiAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDApO1xuXG4gICAgLy8gVXBkYXRlIHBvc2l0aW9ucyBvbiBzaW11bGF0aW9uIHRpY2sgd2l0aCBzbW9vdGggdHJhbnNpdGlvbnNcbiAgICB0aGlzLnNpbXVsYXRpb24ub24oJ3RpY2snLCAoKSA9PiB0aGlzLnRpY2tlZCgpKTtcblxuICAgIC8vIEluaXRpYWwgdXBkYXRlXG4gICAgdGhpcy51cGRhdGVWaXN1YWxpemF0aW9uKCk7XG4gIH1cblxuICBnZXROb2RlQ29sb3Iobm9kZSkge1xuICAgIGNvbnN0IGNvbG9ycyA9IHtcbiAgICAgIGJhc2ljOiAnIzI4YTc0NScsXG4gICAgICBzdGFuZGFyZDogJyNmZmMxMDcnLFxuICAgICAgY29tcHJlaGVuc2l2ZTogJyNkYzM1NDUnLFxuICAgIH07XG4gICAgcmV0dXJuIGNvbG9yc1tub2RlLnJlY29tbWVuZGVkTGV2ZWxdIHx8ICcjNmM3NTdkJztcbiAgfVxuXG4gIGdldE5vZGVMYWJlbChub2RlKSB7XG4gICAgLy8gVHJ1bmNhdGUgbG9uZyBuYW1lc1xuICAgIGNvbnN0IG1heExlbmd0aCA9IDEyO1xuICAgIGlmIChub2RlLm5hbWUubGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYCR7bm9kZS5uYW1lLnN1YnN0cmluZygwLCBtYXhMZW5ndGggLSAzKSB9Li4uYDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUubmFtZTtcbiAgfVxuXG4gIHVwZGF0ZVZpc3VhbGl6YXRpb24oKSB7XG4gICAgaWYgKCF0aGlzLm5vZGVFbGVtZW50cyB8fCAhdGhpcy5saW5rRWxlbWVudHMpIHJldHVybjtcblxuICAgIC8vIEZpbHRlciBub2Rlc1xuICAgIGNvbnN0IHZpc2libGVOb2RlcyA9IHRoaXMubm9kZXMuZmlsdGVyKG5vZGUgPT4gdGhpcy5pc05vZGVWaXNpYmxlKG5vZGUpKTtcbiAgICBjb25zdCB2aXNpYmxlTm9kZUlkcyA9IG5ldyBTZXQodmlzaWJsZU5vZGVzLm1hcChuID0+IG4uaWQpKTtcblxuICAgIC8vIEZpbHRlciBsaW5rc1xuICAgIGNvbnN0IHZpc2libGVMaW5rcyA9IHRoaXMuY3VycmVudEZpbHRlcnMuc2hvd0RlcGVuZGVuY2llc1xuICAgICAgPyB0aGlzLmxpbmtzLmZpbHRlcihsaW5rID0+XG4gICAgICAgIHZpc2libGVOb2RlSWRzLmhhcyhsaW5rLnNvdXJjZS5pZCB8fCBsaW5rLnNvdXJjZSkgJiZcbiAgICAgICAgICAgICAgICB2aXNpYmxlTm9kZUlkcy5oYXMobGluay50YXJnZXQuaWQgfHwgbGluay50YXJnZXQpLFxuICAgICAgKVxuICAgICAgOiBbXTtcblxuICAgIC8vIFVwZGF0ZSBub2RlIHZpc2liaWxpdHlcbiAgICB0aGlzLm5vZGVFbGVtZW50c1xuICAgICAgLnN0eWxlKCdvcGFjaXR5JywgZCA9PiB0aGlzLmlzTm9kZVZpc2libGUoZCkgPyAxIDogMC4xKVxuICAgICAgLnN0eWxlKCdwb2ludGVyLWV2ZW50cycsIGQgPT4gdGhpcy5pc05vZGVWaXNpYmxlKGQpID8gJ2FsbCcgOiAnbm9uZScpO1xuXG4gICAgLy8gVXBkYXRlIGxpbmsgdmlzaWJpbGl0eVxuICAgIHRoaXMubGlua0VsZW1lbnRzXG4gICAgICAuc3R5bGUoJ29wYWNpdHknLCBkID0+IHtcbiAgICAgICAgY29uc3Qgc291cmNlVmlzaWJsZSA9IHZpc2libGVOb2RlSWRzLmhhcyhkLnNvdXJjZS5pZCB8fCBkLnNvdXJjZSk7XG4gICAgICAgIGNvbnN0IHRhcmdldFZpc2libGUgPSB2aXNpYmxlTm9kZUlkcy5oYXMoZC50YXJnZXQuaWQgfHwgZC50YXJnZXQpO1xuICAgICAgICByZXR1cm4gKHNvdXJjZVZpc2libGUgJiYgdGFyZ2V0VmlzaWJsZSAmJiB0aGlzLmN1cnJlbnRGaWx0ZXJzLnNob3dEZXBlbmRlbmNpZXMpID8gMC42IDogMDtcbiAgICAgIH0pO1xuXG4gICAgLy8gVXBkYXRlIGxhYmVsIHZpc2liaWxpdHlcbiAgICB0aGlzLmxhYmVsRWxlbWVudHNcbiAgICAgIC5zdHlsZSgnb3BhY2l0eScsIGQgPT4gdGhpcy5pc05vZGVWaXNpYmxlKGQpID8gMSA6IDAuMSk7XG5cbiAgICAvLyBVcGRhdGUgc2ltdWxhdGlvblxuICAgIHRoaXMuc2ltdWxhdGlvbi5ub2Rlcyh2aXNpYmxlTm9kZXMpO1xuICAgIHRoaXMuc2ltdWxhdGlvbi5mb3JjZSgnbGluaycpLmxpbmtzKHZpc2libGVMaW5rcyk7XG4gICAgdGhpcy5zaW11bGF0aW9uLmFscGhhKDAuMykucmVzdGFydCgpO1xuICB9XG5cbiAgaXNOb2RlVmlzaWJsZShub2RlKSB7XG4gICAgLy8gQ2F0ZWdvcnkgZmlsdGVyXG4gICAgaWYgKCF0aGlzLmN1cnJlbnRGaWx0ZXJzLmNhdGVnb3JpZXMuaGFzKG5vZGUuY2F0ZWdvcnkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gTGV2ZWwgZmlsdGVyXG4gICAgaWYgKCF0aGlzLmN1cnJlbnRGaWx0ZXJzLmxldmVscy5oYXMobm9kZS5yZWNvbW1lbmRlZExldmVsKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFNlYXJjaCBmaWx0ZXJcbiAgICBpZiAodGhpcy5jdXJyZW50RmlsdGVycy5zZWFyY2hUZXJtICYmXG4gICAgICAgICAgICAhbm9kZS5uYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXModGhpcy5jdXJyZW50RmlsdGVycy5zZWFyY2hUZXJtKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdGlja2VkKCkge1xuICAgIGlmICh0aGlzLmxpbmtFbGVtZW50cykge1xuICAgICAgdGhpcy5saW5rRWxlbWVudHNcbiAgICAgICAgLmF0dHIoJ3gxJywgZCA9PiBkLnNvdXJjZS54KVxuICAgICAgICAuYXR0cigneTEnLCBkID0+IGQuc291cmNlLnkpXG4gICAgICAgIC5hdHRyKCd4MicsIGQgPT4gZC50YXJnZXQueClcbiAgICAgICAgLmF0dHIoJ3kyJywgZCA9PiBkLnRhcmdldC55KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5ub2RlRWxlbWVudHMpIHtcbiAgICAgIHRoaXMubm9kZUVsZW1lbnRzXG4gICAgICAgIC5hdHRyKCdjeCcsIGQgPT4gZC54KVxuICAgICAgICAuYXR0cignY3knLCBkID0+IGQueSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGFiZWxFbGVtZW50cykge1xuICAgICAgdGhpcy5sYWJlbEVsZW1lbnRzXG4gICAgICAgIC5hdHRyKCd4JywgZCA9PiBkLngpXG4gICAgICAgIC5hdHRyKCd5JywgZCA9PiBkLnkpO1xuICAgIH1cbiAgfVxuXG4gIGRyYWdTdGFydGVkKGV2ZW50LCBkKSB7XG4gICAgaWYgKCFldmVudC5hY3RpdmUpIHRoaXMuc2ltdWxhdGlvbi5hbHBoYVRhcmdldCgwLjMpLnJlc3RhcnQoKTtcbiAgICBkLmZ4ID0gZC54O1xuICAgIGQuZnkgPSBkLnk7XG4gIH1cblxuICBkcmFnZ2VkKGV2ZW50LCBkKSB7XG4gICAgZC5meCA9IGV2ZW50Lng7XG4gICAgZC5meSA9IGV2ZW50Lnk7XG4gIH1cblxuICBkcmFnRW5kZWQoZXZlbnQsIGQpIHtcbiAgICBpZiAoIWV2ZW50LmFjdGl2ZSkgdGhpcy5zaW11bGF0aW9uLmFscGhhVGFyZ2V0KDApO1xuICAgIGQuZnggPSBudWxsO1xuICAgIGQuZnkgPSBudWxsO1xuICB9XG5cbiAgaGFuZGxlTW91c2VPdmVyKGV2ZW50LCBkKSB7XG4gICAgLy8gSGlnaGxpZ2h0IGNvbm5lY3RlZCBub2RlcyBhbmQgbGlua3NcbiAgICB0aGlzLmhpZ2hsaWdodENvbm5lY3RlZEVsZW1lbnRzKGQpO1xuXG4gICAgLy8gU2hvdyBlbmhhbmNlZCB0b29sdGlwXG4gICAgdGhpcy5zaG93RW5oYW5jZWRUb29sdGlwKGV2ZW50LCBkKTtcblxuICAgIC8vIEFkZCBob3ZlciBlZmZlY3RcbiAgICBkMy5zZWxlY3QoZXZlbnQuY3VycmVudFRhcmdldClcbiAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAzKVxuICAgICAgLmF0dHIoJ3N0cm9rZScsICcjZmZjMTA3JylcbiAgICAgIC5hdHRyKCdmaWx0ZXInLCAndXJsKCNnbG93KScpO1xuICB9XG5cbiAgaGFuZGxlTW91c2VPdXQoZXZlbnQsIGQpIHtcbiAgICAvLyBSZW1vdmUgaGlnaGxpZ2h0c1xuICAgIHRoaXMuY2xlYXJIaWdobGlnaHRzKCk7XG5cbiAgICAvLyBIaWRlIHRvb2x0aXBcbiAgICB0aGlzLmhpZGVUb29sdGlwKCk7XG5cbiAgICAvLyBSZW1vdmUgaG92ZXIgZWZmZWN0XG4gICAgZDMuc2VsZWN0KGV2ZW50LmN1cnJlbnRUYXJnZXQpXG4gICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMilcbiAgICAgIC5hdHRyKCdzdHJva2UnLCAnI2ZmZicpXG4gICAgICAuYXR0cignZmlsdGVyJywgbnVsbCk7XG4gIH1cblxuICBoaWdobGlnaHRDb25uZWN0ZWRFbGVtZW50cyhub2RlKSB7XG4gICAgLy8gSGlnaGxpZ2h0IGNvbm5lY3RlZCBsaW5rc1xuICAgIHRoaXMubGlua0VsZW1lbnRzXG4gICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIGxpbmsgPT5cbiAgICAgICAgKGxpbmsuc291cmNlLmlkID09PSBub2RlLmlkIHx8IGxpbmsudGFyZ2V0LmlkID09PSBub2RlLmlkKSA/IDQgOiAxLjUsXG4gICAgICApXG4gICAgICAuc3R5bGUoJ3N0cm9rZS1vcGFjaXR5JywgbGluayA9PlxuICAgICAgICAobGluay5zb3VyY2UuaWQgPT09IG5vZGUuaWQgfHwgbGluay50YXJnZXQuaWQgPT09IG5vZGUuaWQpID8gMSA6IDAuMyxcbiAgICAgICk7XG5cbiAgICAvLyBIaWdobGlnaHQgY29ubmVjdGVkIG5vZGVzXG4gICAgdGhpcy5ub2RlRWxlbWVudHNcbiAgICAgIC5zdHlsZSgnb3BhY2l0eScsIG90aGVyTm9kZSA9PiB7XG4gICAgICAgIGNvbnN0IGlzQ29ubmVjdGVkID0gdGhpcy5saW5rcy5zb21lKGxpbmsgPT5cbiAgICAgICAgICAobGluay5zb3VyY2UuaWQgPT09IG5vZGUuaWQgJiYgbGluay50YXJnZXQuaWQgPT09IG90aGVyTm9kZS5pZCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGxpbmsuc291cmNlLmlkID09PSBvdGhlck5vZGUuaWQgJiYgbGluay50YXJnZXQuaWQgPT09IG5vZGUuaWQpLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gaXNDb25uZWN0ZWQgPyAxIDogMC4zO1xuICAgICAgfSk7XG4gIH1cblxuICBzaG93RW5oYW5jZWRUb29sdGlwKGV2ZW50LCBkKSB7XG4gICAgY29uc3QgdG9vbHRpcENvbnRlbnQgPSBgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidG9vbHRpcC1jb250ZW50XCI+XG4gICAgICAgICAgICAgICAgPGg0PiR7ZC5uYW1lfTwvaDQ+XG4gICAgICAgICAgICAgICAgPHA+PHN0cm9uZz5DYXRlZ29yeTo8L3N0cm9uZz4gJHtkLmNhdGVnb3J5fTwvcD5cbiAgICAgICAgICAgICAgICA8cD48c3Ryb25nPlJlY29tbWVuZGVkIExldmVsOjwvc3Ryb25nPiAke2QucmVjb21tZW5kZWRMZXZlbH08L3A+XG4gICAgICAgICAgICAgICAgJHtkLmVmZm9ydCA/IGA8cD48c3Ryb25nPkVmZm9ydDo8L3N0cm9uZz4gJHtkLmVmZm9ydH0vMTA8L3A+YCA6ICcnfVxuICAgICAgICAgICAgICAgICR7ZC5jb21wbGV4aXR5ID8gYDxwPjxzdHJvbmc+Q29tcGxleGl0eTo8L3N0cm9uZz4gJHtkLmNvbXBsZXhpdHl9LzEwPC9wPmAgOiAnJ31cbiAgICAgICAgICAgICAgICAke2QuY29uZmlkZW5jZSA/IGA8cD48c3Ryb25nPkNvbmZpZGVuY2U6PC9zdHJvbmc+ICR7ZC5jb25maWRlbmNlfSU8L3A+YCA6ICcnfVxuICAgICAgICAgICAgICAgIDxwPjxzdHJvbmc+Q29ubmVjdGlvbnM6PC9zdHJvbmc+ICR7dGhpcy5nZXRDb25uZWN0aW9uQ291bnQoZCl9PC9wPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIGA7XG5cbiAgICB0aGlzLnRvb2x0aXBcbiAgICAgIC5odG1sKHRvb2x0aXBDb250ZW50KVxuICAgICAgLnN0eWxlKCdsZWZ0JywgYCR7ZXZlbnQucGFnZVggKyAxMCB9cHhgKVxuICAgICAgLnN0eWxlKCd0b3AnLCBgJHtldmVudC5wYWdlWSAtIDI4IH1weGApXG4gICAgICAuc3R5bGUoJ29wYWNpdHknLCAxKVxuICAgICAgLnN0eWxlKCdtYXgtd2lkdGgnLCAnMzAwcHgnKTtcbiAgfVxuXG4gIGdldENvbm5lY3Rpb25Db3VudChub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMubGlua3MuZmlsdGVyKGxpbmsgPT5cbiAgICAgIGxpbmsuc291cmNlLmlkID09PSBub2RlLmlkIHx8IGxpbmsudGFyZ2V0LmlkID09PSBub2RlLmlkLFxuICAgICkubGVuZ3RoO1xuICB9XG5cbiAgYWRkWm9vbUNvbnRyb2xzKCkge1xuICAgIGNvbnN0IGNvbnRyb2xzID0gZDMuc2VsZWN0KCcjdmlzdWFsaXphdGlvbi1jb250cm9scycpXG4gICAgICAuYXBwZW5kKCdkaXYnKVxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ3pvb20tY29udHJvbHMnKVxuICAgICAgLnN0eWxlKCdwb3NpdGlvbicsICdhYnNvbHV0ZScpXG4gICAgICAuc3R5bGUoJ3RvcCcsICcxMHB4JylcbiAgICAgIC5zdHlsZSgncmlnaHQnLCAnMTBweCcpXG4gICAgICAuc3R5bGUoJ3otaW5kZXgnLCAnMTAwMCcpO1xuXG4gICAgY29udHJvbHMuYXBwZW5kKCdidXR0b24nKVxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ2J0biBidG4tc20gYnRuLW91dGxpbmUtcHJpbWFyeSBtZS0yJylcbiAgICAgIC5odG1sKCc8aSBjbGFzcz1cImZhcyBmYS1wbHVzXCI+PC9pPicpXG4gICAgICAub24oJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICB0aGlzLnN2Zy50cmFuc2l0aW9uKCkuZHVyYXRpb24oMzAwKS5jYWxsKFxuICAgICAgICAgIHRoaXMuem9vbS5zY2FsZUJ5LCAxLjUsXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgIGNvbnRyb2xzLmFwcGVuZCgnYnV0dG9uJylcbiAgICAgIC5hdHRyKCdjbGFzcycsICdidG4gYnRuLXNtIGJ0bi1vdXRsaW5lLXByaW1hcnkgbWUtMicpXG4gICAgICAuaHRtbCgnPGkgY2xhc3M9XCJmYXMgZmEtbWludXNcIj48L2k+JylcbiAgICAgIC5vbignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuc3ZnLnRyYW5zaXRpb24oKS5kdXJhdGlvbigzMDApLmNhbGwoXG4gICAgICAgICAgdGhpcy56b29tLnNjYWxlQnksIDAuNzUsXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgIGNvbnRyb2xzLmFwcGVuZCgnYnV0dG9uJylcbiAgICAgIC5hdHRyKCdjbGFzcycsICdidG4gYnRuLXNtIGJ0bi1vdXRsaW5lLXNlY29uZGFyeScpXG4gICAgICAuaHRtbCgnPGkgY2xhc3M9XCJmYXMgZmEtc3luYy1hbHRcIj48L2k+JylcbiAgICAgIC5vbignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuc3ZnLnRyYW5zaXRpb24oKS5kdXJhdGlvbigzMDApLmNhbGwoXG4gICAgICAgICAgdGhpcy56b29tLnRyYW5zZm9ybSwgZDMuem9vbUlkZW50aXR5LFxuICAgICAgICApO1xuICAgICAgfSk7XG4gIH1cblxuICBub2RlQ2xpY2tlZChldmVudCwgZCkge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIC8vIFVzZSB0aGUgbWFpbiBhcHAncyBzaG93UHJvY2Vzc0RldGFpbHMgbWV0aG9kIGluc3RlYWQgb2YgbG9jYWwgaW1wbGVtZW50YXRpb25cbiAgICBpZiAod2luZG93LnNlQXBwICYmIHR5cGVvZiB3aW5kb3cuc2VBcHAuc2hvd1Byb2Nlc3NEZXRhaWxzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3aW5kb3cuc2VBcHAuc2hvd1Byb2Nlc3NEZXRhaWxzKGQuaWQpO1xuICAgIH1cbiAgfVxuXG4gIHNob3dUb29sdGlwKGV2ZW50LCBkKSB7XG4gICAgY29uc3QgdG9vbHRpcCA9IHRoaXMudG9vbHRpcDtcblxuICAgIHRvb2x0aXAuc3R5bGUoJ29wYWNpdHknLCAxKVxuICAgICAgLmh0bWwoYFxuICAgICAgICAgICAgICAgIDxzdHJvbmc+JHtkLm5hbWV9PC9zdHJvbmc+PGJyLz5cbiAgICAgICAgICAgICAgICBMZXZlbDogPHNwYW4gY2xhc3M9XCJsZXZlbC1iYWRnZSBsZXZlbC0ke2QucmVjb21tZW5kZWRMZXZlbH1cIj4ke2QucmVjb21tZW5kZWRMZXZlbH08L3NwYW4+PGJyLz5cbiAgICAgICAgICAgICAgICBFZmZvcnQ6ICR7ZC5lZmZvcnR9LzU8YnIvPlxuICAgICAgICAgICAgICAgIENvbmZpZGVuY2U6ICR7TWF0aC5yb3VuZChkLmNvbmZpZGVuY2UgKiAxMDApfSVcbiAgICAgICAgICAgIGApXG4gICAgICAuc3R5bGUoJ2xlZnQnLCBgJHtldmVudC5wYWdlWCArIDEwIH1weGApXG4gICAgICAuc3R5bGUoJ3RvcCcsIGAke2V2ZW50LnBhZ2VZIC0gMTAgfXB4YCk7XG4gIH1cblxuICBoaWRlVG9vbHRpcCgpIHtcbiAgICB0aGlzLnRvb2x0aXAuc3R5bGUoJ29wYWNpdHknLCAwKTtcbiAgfVxuXG4gIHRvZ2dsZUxhYmVscyhzaG93KSB7XG4gICAgaWYgKHRoaXMubGFiZWxFbGVtZW50cykge1xuICAgICAgdGhpcy5sYWJlbEVsZW1lbnRzLnN0eWxlKCdvcGFjaXR5Jywgc2hvdyA/IDEgOiAwKTtcbiAgICB9XG4gIH1cblxuICBjaGFuZ2VMYXlvdXQobGF5b3V0KSB7XG4gICAgaWYgKCF0aGlzLnNpbXVsYXRpb24pIHJldHVybjtcblxuICAgIHN3aXRjaCAobGF5b3V0KSB7XG4gICAgICBjYXNlICdjaXJjdWxhcic6XG4gICAgICAgIHRoaXMuYXBwbHlDaXJjdWxhckxheW91dCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2hpZXJhcmNoaWNhbCc6XG4gICAgICAgIHRoaXMuYXBwbHlIaWVyYXJjaGljYWxMYXlvdXQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmFwcGx5Rm9yY2VMYXlvdXQoKTtcbiAgICB9XG4gIH1cblxuICBhcHBseUNpcmN1bGFyTGF5b3V0KCkge1xuICAgIGNvbnN0IGNlbnRlclggPSB0aGlzLndpZHRoIC8gMjtcbiAgICBjb25zdCBjZW50ZXJZID0gdGhpcy5oZWlnaHQgLyAyO1xuICAgIGNvbnN0IHJhZGl1cyA9IE1hdGgubWluKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KSAvIDM7XG5cbiAgICB0aGlzLm5vZGVzLmZvckVhY2goKG5vZGUsIGkpID0+IHtcbiAgICAgIGNvbnN0IGFuZ2xlID0gKDIgKiBNYXRoLlBJICogaSkgLyB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICAgIG5vZGUuZnggPSBjZW50ZXJYICsgcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgbm9kZS5meSA9IGNlbnRlclkgKyByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnNpbXVsYXRpb24uYWxwaGEoMC4zKS5yZXN0YXJ0KCk7XG4gIH1cblxuICBhcHBseUhpZXJhcmNoaWNhbExheW91dCgpIHtcbiAgICBjb25zdCBjYXRlZ29yaWVzID0gWyd0ZWNobmljYWxfbWFuYWdlbWVudCcsICd0ZWNobmljYWwnXTtcbiAgICBjb25zdCBjYXRlZ29yeUhlaWdodCA9IHRoaXMuaGVpZ2h0IC8gY2F0ZWdvcmllcy5sZW5ndGg7XG5cbiAgICBjYXRlZ29yaWVzLmZvckVhY2goKGNhdGVnb3J5LCBjYXRJbmRleCkgPT4ge1xuICAgICAgY29uc3QgY2F0ZWdvcnlOb2RlcyA9IHRoaXMubm9kZXMuZmlsdGVyKG4gPT4gbi5jYXRlZ29yeSA9PT0gY2F0ZWdvcnkpO1xuICAgICAgY29uc3Qgbm9kZVdpZHRoID0gdGhpcy53aWR0aCAvIChjYXRlZ29yeU5vZGVzLmxlbmd0aCArIDEpO1xuXG4gICAgICBjYXRlZ29yeU5vZGVzLmZvckVhY2goKG5vZGUsIG5vZGVJbmRleCkgPT4ge1xuICAgICAgICBub2RlLmZ4ID0gKG5vZGVJbmRleCArIDEpICogbm9kZVdpZHRoO1xuICAgICAgICBub2RlLmZ5ID0gKGNhdEluZGV4ICsgMC41KSAqIGNhdGVnb3J5SGVpZ2h0O1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnNpbXVsYXRpb24uYWxwaGEoMC4zKS5yZXN0YXJ0KCk7XG4gIH1cblxuICBhcHBseUZvcmNlTGF5b3V0KCkge1xuICAgIHRoaXMubm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgIG5vZGUuZnggPSBudWxsO1xuICAgICAgbm9kZS5meSA9IG51bGw7XG4gICAgfSk7XG5cbiAgICB0aGlzLnNpbXVsYXRpb25cbiAgICAgIC5mb3JjZSgnY2VudGVyJywgZDMuZm9yY2VDZW50ZXIodGhpcy53aWR0aCAvIDIsIHRoaXMuaGVpZ2h0IC8gMikpXG4gICAgICAuYWxwaGEoMC4zKVxuICAgICAgLnJlc3RhcnQoKTtcbiAgfVxuXG4gIHJlc2V0RmlsdGVycygpIHtcbiAgICB0aGlzLmN1cnJlbnRGaWx0ZXJzID0ge1xuICAgICAgY2F0ZWdvcmllczogbmV3IFNldChbJ3RlY2huaWNhbF9tYW5hZ2VtZW50JywgJ3RlY2huaWNhbCddKSxcbiAgICAgIGxldmVsczogbmV3IFNldChbJ2Jhc2ljJywgJ3N0YW5kYXJkJywgJ2NvbXByZWhlbnNpdmUnXSksXG4gICAgICBzaG93RGVwZW5kZW5jaWVzOiB0cnVlLFxuICAgICAgc2VhcmNoVGVybTogJycsXG4gICAgfTtcblxuICAgIC8vIFJlc2V0IFVJIGNvbnRyb2xzXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Byb2Nlc3Mtc2VhcmNoJykudmFsdWUgPSAnJztcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmlsdGVyLXRlY2huaWNhbC1tZ210JykuY2hlY2tlZCA9IHRydWU7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZpbHRlci10ZWNobmljYWwnKS5jaGVja2VkID0gdHJ1ZTtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmlsdGVyLWJhc2ljJykuY2hlY2tlZCA9IHRydWU7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZpbHRlci1zdGFuZGFyZCcpLmNoZWNrZWQgPSB0cnVlO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmaWx0ZXItY29tcHJlaGVuc2l2ZScpLmNoZWNrZWQgPSB0cnVlO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaG93LWRlcGVuZGVuY2llcycpLmNoZWNrZWQgPSB0cnVlO1xuXG4gICAgdGhpcy51cGRhdGVWaXN1YWxpemF0aW9uKCk7XG4gIH1cblxuICB6b29tSW4oKSB7XG4gICAgdGhpcy5zdmcudHJhbnNpdGlvbigpLmNhbGwodGhpcy56b29tLnNjYWxlQnksIDEuNSk7XG4gIH1cblxuICB6b29tT3V0KCkge1xuICAgIHRoaXMuc3ZnLnRyYW5zaXRpb24oKS5jYWxsKHRoaXMuem9vbS5zY2FsZUJ5LCAxIC8gMS41KTtcbiAgfVxuXG4gIHJlc2V0VmlldygpIHtcbiAgICB0aGlzLnN2Zy50cmFuc2l0aW9uKCkuY2FsbCh0aGlzLnpvb20udHJhbnNmb3JtLCBkMy56b29tSWRlbnRpdHkpO1xuICB9XG5cbiAgLy8gUHVibGljIG1ldGhvZHNcbiAgaGlnaGxpZ2h0UHJvY2Vzcyhwcm9jZXNzSWQpIHtcbiAgICBpZiAodGhpcy5ub2RlRWxlbWVudHMpIHtcbiAgICAgIHRoaXMubm9kZUVsZW1lbnRzXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZCA9PiBkLmlkID09PSBwcm9jZXNzSWQgPyAnI2ZmNmI2YicgOiAnI2ZmZicpXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgZCA9PiBkLmlkID09PSBwcm9jZXNzSWQgPyA0IDogMik7XG4gICAgfVxuICB9XG5cbiAgY2xlYXJIaWdobGlnaHRzKCkge1xuICAgIGlmICh0aGlzLm5vZGVFbGVtZW50cykge1xuICAgICAgdGhpcy5ub2RlRWxlbWVudHNcbiAgICAgICAgLnN0eWxlKCdzdHJva2UnLCAnI2ZmZicpXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgMik7XG4gICAgfVxuICB9XG5cbiAgc2V0dXBFdmVudExpc3RlbmVycygpIHtcbiAgICAvLyBTZXR1cCB6b29tIGNvbnRyb2wgZXZlbnQgbGlzdGVuZXJzXG4gICAgY29uc3Qgem9vbUluQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3pvb20taW4tYnRuJyk7XG4gICAgY29uc3Qgem9vbU91dEJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd6b29tLW91dC1idG4nKTtcbiAgICBjb25zdCByZXNldFZpZXdCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVzZXQtdmlldy1idG4nKTtcblxuICAgIGlmICh6b29tSW5CdG4pIHtcbiAgICAgIHpvb21JbkJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHRoaXMuem9vbUluKCkpO1xuICAgIH1cbiAgICBpZiAoem9vbU91dEJ0bikge1xuICAgICAgem9vbU91dEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHRoaXMuem9vbU91dCgpKTtcbiAgICB9XG4gICAgaWYgKHJlc2V0Vmlld0J0bikge1xuICAgICAgcmVzZXRWaWV3QnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy5yZXNldFZpZXcoKSk7XG4gICAgfVxuICB9XG59XG5cbi8vIEV4cG9ydCBmb3IgZ2xvYmFsIGFjY2Vzc1xud2luZG93LlByb2Nlc3NOZXR3b3JrVmlzdWFsaXplciA9IFByb2Nlc3NOZXR3b3JrVmlzdWFsaXplcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./js/components/visualization.js\n\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: __webpack_require__ };
/******/ 		__webpack_require__.i.forEach(function(handler) { handler(execOptions); });
/******/ 		module = execOptions.module;
/******/ 		execOptions.factory.call(module.exports, module, module.exports, execOptions.require);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/******/ 	// expose the module execution interceptor
/******/ 	__webpack_require__.i = [];
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript update chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.hu = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + "." + __webpack_require__.h() + ".hot-update.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get update manifest filename */
/******/ 	(() => {
/******/ 		__webpack_require__.hmrF = () => ("main." + __webpack_require__.h() + ".hot-update.json");
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/getFullHash */
/******/ 	(() => {
/******/ 		__webpack_require__.h = () => ("214e852875ac4a9ef06a")
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "se-tailoring-framework:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hot module replacement */
/******/ 	(() => {
/******/ 		var currentModuleData = {};
/******/ 		var installedModules = __webpack_require__.c;
/******/ 		
/******/ 		// module and require creation
/******/ 		var currentChildModule;
/******/ 		var currentParents = [];
/******/ 		
/******/ 		// status
/******/ 		var registeredStatusHandlers = [];
/******/ 		var currentStatus = "idle";
/******/ 		
/******/ 		// while downloading
/******/ 		var blockingPromises = 0;
/******/ 		var blockingPromisesWaiting = [];
/******/ 		
/******/ 		// The update info
/******/ 		var currentUpdateApplyHandlers;
/******/ 		var queuedInvalidatedModules;
/******/ 		
/******/ 		__webpack_require__.hmrD = currentModuleData;
/******/ 		
/******/ 		__webpack_require__.i.push(function (options) {
/******/ 			var module = options.module;
/******/ 			var require = createRequire(options.require, options.id);
/******/ 			module.hot = createModuleHotObject(options.id, module);
/******/ 			module.parents = currentParents;
/******/ 			module.children = [];
/******/ 			currentParents = [];
/******/ 			options.require = require;
/******/ 		});
/******/ 		
/******/ 		__webpack_require__.hmrC = {};
/******/ 		__webpack_require__.hmrI = {};
/******/ 		
/******/ 		function createRequire(require, moduleId) {
/******/ 			var me = installedModules[moduleId];
/******/ 			if (!me) return require;
/******/ 			var fn = function (request) {
/******/ 				if (me.hot.active) {
/******/ 					if (installedModules[request]) {
/******/ 						var parents = installedModules[request].parents;
/******/ 						if (parents.indexOf(moduleId) === -1) {
/******/ 							parents.push(moduleId);
/******/ 						}
/******/ 					} else {
/******/ 						currentParents = [moduleId];
/******/ 						currentChildModule = request;
/******/ 					}
/******/ 					if (me.children.indexOf(request) === -1) {
/******/ 						me.children.push(request);
/******/ 					}
/******/ 				} else {
/******/ 					console.warn(
/******/ 						"[HMR] unexpected require(" +
/******/ 							request +
/******/ 							") from disposed module " +
/******/ 							moduleId
/******/ 					);
/******/ 					currentParents = [];
/******/ 				}
/******/ 				return require(request);
/******/ 			};
/******/ 			var createPropertyDescriptor = function (name) {
/******/ 				return {
/******/ 					configurable: true,
/******/ 					enumerable: true,
/******/ 					get: function () {
/******/ 						return require[name];
/******/ 					},
/******/ 					set: function (value) {
/******/ 						require[name] = value;
/******/ 					}
/******/ 				};
/******/ 			};
/******/ 			for (var name in require) {
/******/ 				if (Object.prototype.hasOwnProperty.call(require, name) && name !== "e") {
/******/ 					Object.defineProperty(fn, name, createPropertyDescriptor(name));
/******/ 				}
/******/ 			}
/******/ 			fn.e = function (chunkId, fetchPriority) {
/******/ 				return trackBlockingPromise(require.e(chunkId, fetchPriority));
/******/ 			};
/******/ 			return fn;
/******/ 		}
/******/ 		
/******/ 		function createModuleHotObject(moduleId, me) {
/******/ 			var _main = currentChildModule !== moduleId;
/******/ 			var hot = {
/******/ 				// private stuff
/******/ 				_acceptedDependencies: {},
/******/ 				_acceptedErrorHandlers: {},
/******/ 				_declinedDependencies: {},
/******/ 				_selfAccepted: false,
/******/ 				_selfDeclined: false,
/******/ 				_selfInvalidated: false,
/******/ 				_disposeHandlers: [],
/******/ 				_main: _main,
/******/ 				_requireSelf: function () {
/******/ 					currentParents = me.parents.slice();
/******/ 					currentChildModule = _main ? undefined : moduleId;
/******/ 					__webpack_require__(moduleId);
/******/ 				},
/******/ 		
/******/ 				// Module API
/******/ 				active: true,
/******/ 				accept: function (dep, callback, errorHandler) {
/******/ 					if (dep === undefined) hot._selfAccepted = true;
/******/ 					else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 					else if (typeof dep === "object" && dep !== null) {
/******/ 						for (var i = 0; i < dep.length; i++) {
/******/ 							hot._acceptedDependencies[dep[i]] = callback || function () {};
/******/ 							hot._acceptedErrorHandlers[dep[i]] = errorHandler;
/******/ 						}
/******/ 					} else {
/******/ 						hot._acceptedDependencies[dep] = callback || function () {};
/******/ 						hot._acceptedErrorHandlers[dep] = errorHandler;
/******/ 					}
/******/ 				},
/******/ 				decline: function (dep) {
/******/ 					if (dep === undefined) hot._selfDeclined = true;
/******/ 					else if (typeof dep === "object" && dep !== null)
/******/ 						for (var i = 0; i < dep.length; i++)
/******/ 							hot._declinedDependencies[dep[i]] = true;
/******/ 					else hot._declinedDependencies[dep] = true;
/******/ 				},
/******/ 				dispose: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				addDisposeHandler: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				removeDisposeHandler: function (callback) {
/******/ 					var idx = hot._disposeHandlers.indexOf(callback);
/******/ 					if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 				},
/******/ 				invalidate: function () {
/******/ 					this._selfInvalidated = true;
/******/ 					switch (currentStatus) {
/******/ 						case "idle":
/******/ 							currentUpdateApplyHandlers = [];
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							setStatus("ready");
/******/ 							break;
/******/ 						case "ready":
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							break;
/******/ 						case "prepare":
/******/ 						case "check":
/******/ 						case "dispose":
/******/ 						case "apply":
/******/ 							(queuedInvalidatedModules = queuedInvalidatedModules || []).push(
/******/ 								moduleId
/******/ 							);
/******/ 							break;
/******/ 						default:
/******/ 							// ignore requests in error states
/******/ 							break;
/******/ 					}
/******/ 				},
/******/ 		
/******/ 				// Management API
/******/ 				check: hotCheck,
/******/ 				apply: hotApply,
/******/ 				status: function (l) {
/******/ 					if (!l) return currentStatus;
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				addStatusHandler: function (l) {
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				removeStatusHandler: function (l) {
/******/ 					var idx = registeredStatusHandlers.indexOf(l);
/******/ 					if (idx >= 0) registeredStatusHandlers.splice(idx, 1);
/******/ 				},
/******/ 		
/******/ 				// inherit from previous dispose call
/******/ 				data: currentModuleData[moduleId]
/******/ 			};
/******/ 			currentChildModule = undefined;
/******/ 			return hot;
/******/ 		}
/******/ 		
/******/ 		function setStatus(newStatus) {
/******/ 			currentStatus = newStatus;
/******/ 			var results = [];
/******/ 		
/******/ 			for (var i = 0; i < registeredStatusHandlers.length; i++)
/******/ 				results[i] = registeredStatusHandlers[i].call(null, newStatus);
/******/ 		
/******/ 			return Promise.all(results).then(function () {});
/******/ 		}
/******/ 		
/******/ 		function unblock() {
/******/ 			if (--blockingPromises === 0) {
/******/ 				setStatus("ready").then(function () {
/******/ 					if (blockingPromises === 0) {
/******/ 						var list = blockingPromisesWaiting;
/******/ 						blockingPromisesWaiting = [];
/******/ 						for (var i = 0; i < list.length; i++) {
/******/ 							list[i]();
/******/ 						}
/******/ 					}
/******/ 				});
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function trackBlockingPromise(promise) {
/******/ 			switch (currentStatus) {
/******/ 				case "ready":
/******/ 					setStatus("prepare");
/******/ 				/* fallthrough */
/******/ 				case "prepare":
/******/ 					blockingPromises++;
/******/ 					promise.then(unblock, unblock);
/******/ 					return promise;
/******/ 				default:
/******/ 					return promise;
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function waitForBlockingPromises(fn) {
/******/ 			if (blockingPromises === 0) return fn();
/******/ 			return new Promise(function (resolve) {
/******/ 				blockingPromisesWaiting.push(function () {
/******/ 					resolve(fn());
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function hotCheck(applyOnUpdate) {
/******/ 			if (currentStatus !== "idle") {
/******/ 				throw new Error("check() is only allowed in idle status");
/******/ 			}
/******/ 			return setStatus("check")
/******/ 				.then(__webpack_require__.hmrM)
/******/ 				.then(function (update) {
/******/ 					if (!update) {
/******/ 						return setStatus(applyInvalidatedModules() ? "ready" : "idle").then(
/******/ 							function () {
/******/ 								return null;
/******/ 							}
/******/ 						);
/******/ 					}
/******/ 		
/******/ 					return setStatus("prepare").then(function () {
/******/ 						var updatedModules = [];
/******/ 						currentUpdateApplyHandlers = [];
/******/ 		
/******/ 						return Promise.all(
/******/ 							Object.keys(__webpack_require__.hmrC).reduce(function (
/******/ 								promises,
/******/ 								key
/******/ 							) {
/******/ 								__webpack_require__.hmrC[key](
/******/ 									update.c,
/******/ 									update.r,
/******/ 									update.m,
/******/ 									promises,
/******/ 									currentUpdateApplyHandlers,
/******/ 									updatedModules
/******/ 								);
/******/ 								return promises;
/******/ 							}, [])
/******/ 						).then(function () {
/******/ 							return waitForBlockingPromises(function () {
/******/ 								if (applyOnUpdate) {
/******/ 									return internalApply(applyOnUpdate);
/******/ 								}
/******/ 								return setStatus("ready").then(function () {
/******/ 									return updatedModules;
/******/ 								});
/******/ 							});
/******/ 						});
/******/ 					});
/******/ 				});
/******/ 		}
/******/ 		
/******/ 		function hotApply(options) {
/******/ 			if (currentStatus !== "ready") {
/******/ 				return Promise.resolve().then(function () {
/******/ 					throw new Error(
/******/ 						"apply() is only allowed in ready status (state: " +
/******/ 							currentStatus +
/******/ 							")"
/******/ 					);
/******/ 				});
/******/ 			}
/******/ 			return internalApply(options);
/******/ 		}
/******/ 		
/******/ 		function internalApply(options) {
/******/ 			options = options || {};
/******/ 		
/******/ 			applyInvalidatedModules();
/******/ 		
/******/ 			var results = currentUpdateApplyHandlers.map(function (handler) {
/******/ 				return handler(options);
/******/ 			});
/******/ 			currentUpdateApplyHandlers = undefined;
/******/ 		
/******/ 			var errors = results
/******/ 				.map(function (r) {
/******/ 					return r.error;
/******/ 				})
/******/ 				.filter(Boolean);
/******/ 		
/******/ 			if (errors.length > 0) {
/******/ 				return setStatus("abort").then(function () {
/******/ 					throw errors[0];
/******/ 				});
/******/ 			}
/******/ 		
/******/ 			// Now in "dispose" phase
/******/ 			var disposePromise = setStatus("dispose");
/******/ 		
/******/ 			results.forEach(function (result) {
/******/ 				if (result.dispose) result.dispose();
/******/ 			});
/******/ 		
/******/ 			// Now in "apply" phase
/******/ 			var applyPromise = setStatus("apply");
/******/ 		
/******/ 			var error;
/******/ 			var reportError = function (err) {
/******/ 				if (!error) error = err;
/******/ 			};
/******/ 		
/******/ 			var outdatedModules = [];
/******/ 		
/******/ 			var onAccepted = function () {
/******/ 				return Promise.all([disposePromise, applyPromise]).then(function () {
/******/ 					// handle errors in accept handlers and self accepted module load
/******/ 					if (error) {
/******/ 						return setStatus("fail").then(function () {
/******/ 							throw error;
/******/ 						});
/******/ 					}
/******/ 		
/******/ 					if (queuedInvalidatedModules) {
/******/ 						return internalApply(options).then(function (list) {
/******/ 							outdatedModules.forEach(function (moduleId) {
/******/ 								if (list.indexOf(moduleId) < 0) list.push(moduleId);
/******/ 							});
/******/ 							return list;
/******/ 						});
/******/ 					}
/******/ 		
/******/ 					return setStatus("idle").then(function () {
/******/ 						return outdatedModules;
/******/ 					});
/******/ 				});
/******/ 			};
/******/ 		
/******/ 			return Promise.all(
/******/ 				results
/******/ 					.filter(function (result) {
/******/ 						return result.apply;
/******/ 					})
/******/ 					.map(function (result) {
/******/ 						return result.apply(reportError);
/******/ 					})
/******/ 			)
/******/ 				.then(function (applyResults) {
/******/ 					applyResults.forEach(function (modules) {
/******/ 						if (modules) {
/******/ 							for (var i = 0; i < modules.length; i++) {
/******/ 								outdatedModules.push(modules[i]);
/******/ 							}
/******/ 						}
/******/ 					});
/******/ 				})
/******/ 				.then(onAccepted);
/******/ 		}
/******/ 		
/******/ 		function applyInvalidatedModules() {
/******/ 			if (queuedInvalidatedModules) {
/******/ 				if (!currentUpdateApplyHandlers) currentUpdateApplyHandlers = [];
/******/ 				Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 					queuedInvalidatedModules.forEach(function (moduleId) {
/******/ 						__webpack_require__.hmrI[key](
/******/ 							moduleId,
/******/ 							currentUpdateApplyHandlers
/******/ 						);
/******/ 					});
/******/ 				});
/******/ 				queuedInvalidatedModules = undefined;
/******/ 				return true;
/******/ 			}
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/^blob:/, "").replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = __webpack_require__.hmrS_jsonp = __webpack_require__.hmrS_jsonp || {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		var currentUpdatedModulesList;
/******/ 		var waitingUpdateResolves = {};
/******/ 		function loadUpdateChunk(chunkId, updatedModulesList) {
/******/ 			currentUpdatedModulesList = updatedModulesList;
/******/ 			return new Promise((resolve, reject) => {
/******/ 				waitingUpdateResolves[chunkId] = resolve;
/******/ 				// start update chunk loading
/******/ 				var url = __webpack_require__.p + __webpack_require__.hu(chunkId);
/******/ 				// create error before stack unwound to get useful stacktrace later
/******/ 				var error = new Error();
/******/ 				var loadingEnded = (event) => {
/******/ 					if(waitingUpdateResolves[chunkId]) {
/******/ 						waitingUpdateResolves[chunkId] = undefined
/******/ 						var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 						var realSrc = event && event.target && event.target.src;
/******/ 						error.message = 'Loading hot update chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 						error.name = 'ChunkLoadError';
/******/ 						error.type = errorType;
/******/ 						error.request = realSrc;
/******/ 						reject(error);
/******/ 					}
/******/ 				};
/******/ 				__webpack_require__.l(url, loadingEnded);
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		self["webpackHotUpdatese_tailoring_framework"] = (chunkId, moreModules, runtime) => {
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					currentUpdate[moduleId] = moreModules[moduleId];
/******/ 					if(currentUpdatedModulesList) currentUpdatedModulesList.push(moduleId);
/******/ 				}
/******/ 			}
/******/ 			if(runtime) currentUpdateRuntime.push(runtime);
/******/ 			if(waitingUpdateResolves[chunkId]) {
/******/ 				waitingUpdateResolves[chunkId]();
/******/ 				waitingUpdateResolves[chunkId] = undefined;
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var currentUpdateChunks;
/******/ 		var currentUpdate;
/******/ 		var currentUpdateRemovedChunks;
/******/ 		var currentUpdateRuntime;
/******/ 		function applyHandler(options) {
/******/ 			if (__webpack_require__.f) delete __webpack_require__.f.jsonpHmr;
/******/ 			currentUpdateChunks = undefined;
/******/ 			function getAffectedModuleEffects(updateModuleId) {
/******/ 				var outdatedModules = [updateModuleId];
/******/ 				var outdatedDependencies = {};
/******/ 		
/******/ 				var queue = outdatedModules.map(function (id) {
/******/ 					return {
/******/ 						chain: [id],
/******/ 						id: id
/******/ 					};
/******/ 				});
/******/ 				while (queue.length > 0) {
/******/ 					var queueItem = queue.pop();
/******/ 					var moduleId = queueItem.id;
/******/ 					var chain = queueItem.chain;
/******/ 					var module = __webpack_require__.c[moduleId];
/******/ 					if (
/******/ 						!module ||
/******/ 						(module.hot._selfAccepted && !module.hot._selfInvalidated)
/******/ 					)
/******/ 						continue;
/******/ 					if (module.hot._selfDeclined) {
/******/ 						return {
/******/ 							type: "self-declined",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					if (module.hot._main) {
/******/ 						return {
/******/ 							type: "unaccepted",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					for (var i = 0; i < module.parents.length; i++) {
/******/ 						var parentId = module.parents[i];
/******/ 						var parent = __webpack_require__.c[parentId];
/******/ 						if (!parent) continue;
/******/ 						if (parent.hot._declinedDependencies[moduleId]) {
/******/ 							return {
/******/ 								type: "declined",
/******/ 								chain: chain.concat([parentId]),
/******/ 								moduleId: moduleId,
/******/ 								parentId: parentId
/******/ 							};
/******/ 						}
/******/ 						if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 						if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 							if (!outdatedDependencies[parentId])
/******/ 								outdatedDependencies[parentId] = [];
/******/ 							addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 							continue;
/******/ 						}
/******/ 						delete outdatedDependencies[parentId];
/******/ 						outdatedModules.push(parentId);
/******/ 						queue.push({
/******/ 							chain: chain.concat([parentId]),
/******/ 							id: parentId
/******/ 						});
/******/ 					}
/******/ 				}
/******/ 		
/******/ 				return {
/******/ 					type: "accepted",
/******/ 					moduleId: updateModuleId,
/******/ 					outdatedModules: outdatedModules,
/******/ 					outdatedDependencies: outdatedDependencies
/******/ 				};
/******/ 			}
/******/ 		
/******/ 			function addAllToSet(a, b) {
/******/ 				for (var i = 0; i < b.length; i++) {
/******/ 					var item = b[i];
/******/ 					if (a.indexOf(item) === -1) a.push(item);
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			// at begin all updates modules are outdated
/******/ 			// the "outdated" status can propagate to parents if they don't accept the children
/******/ 			var outdatedDependencies = {};
/******/ 			var outdatedModules = [];
/******/ 			var appliedUpdate = {};
/******/ 		
/******/ 			var warnUnexpectedRequire = function warnUnexpectedRequire(module) {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" + module.id + ") to disposed module"
/******/ 				);
/******/ 			};
/******/ 		
/******/ 			for (var moduleId in currentUpdate) {
/******/ 				if (__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 					var newModuleFactory = currentUpdate[moduleId];
/******/ 					var result = newModuleFactory
/******/ 						? getAffectedModuleEffects(moduleId)
/******/ 						: {
/******/ 								type: "disposed",
/******/ 								moduleId: moduleId
/******/ 							};
/******/ 					/** @type {Error|false} */
/******/ 					var abortError = false;
/******/ 					var doApply = false;
/******/ 					var doDispose = false;
/******/ 					var chainInfo = "";
/******/ 					if (result.chain) {
/******/ 						chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 					}
/******/ 					switch (result.type) {
/******/ 						case "self-declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of self decline: " +
/******/ 										result.moduleId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of declined dependency: " +
/******/ 										result.moduleId +
/******/ 										" in " +
/******/ 										result.parentId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "unaccepted":
/******/ 							if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 							if (!options.ignoreUnaccepted)
/******/ 								abortError = new Error(
/******/ 									"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "accepted":
/******/ 							if (options.onAccepted) options.onAccepted(result);
/******/ 							doApply = true;
/******/ 							break;
/******/ 						case "disposed":
/******/ 							if (options.onDisposed) options.onDisposed(result);
/******/ 							doDispose = true;
/******/ 							break;
/******/ 						default:
/******/ 							throw new Error("Unexception type " + result.type);
/******/ 					}
/******/ 					if (abortError) {
/******/ 						return {
/******/ 							error: abortError
/******/ 						};
/******/ 					}
/******/ 					if (doApply) {
/******/ 						appliedUpdate[moduleId] = newModuleFactory;
/******/ 						addAllToSet(outdatedModules, result.outdatedModules);
/******/ 						for (moduleId in result.outdatedDependencies) {
/******/ 							if (__webpack_require__.o(result.outdatedDependencies, moduleId)) {
/******/ 								if (!outdatedDependencies[moduleId])
/******/ 									outdatedDependencies[moduleId] = [];
/******/ 								addAllToSet(
/******/ 									outdatedDependencies[moduleId],
/******/ 									result.outdatedDependencies[moduleId]
/******/ 								);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 					if (doDispose) {
/******/ 						addAllToSet(outdatedModules, [result.moduleId]);
/******/ 						appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 			currentUpdate = undefined;
/******/ 		
/******/ 			// Store self accepted outdated modules to require them later by the module system
/******/ 			var outdatedSelfAcceptedModules = [];
/******/ 			for (var j = 0; j < outdatedModules.length; j++) {
/******/ 				var outdatedModuleId = outdatedModules[j];
/******/ 				var module = __webpack_require__.c[outdatedModuleId];
/******/ 				if (
/******/ 					module &&
/******/ 					(module.hot._selfAccepted || module.hot._main) &&
/******/ 					// removed self-accepted modules should not be required
/******/ 					appliedUpdate[outdatedModuleId] !== warnUnexpectedRequire &&
/******/ 					// when called invalidate self-accepting is not possible
/******/ 					!module.hot._selfInvalidated
/******/ 				) {
/******/ 					outdatedSelfAcceptedModules.push({
/******/ 						module: outdatedModuleId,
/******/ 						require: module.hot._requireSelf,
/******/ 						errorHandler: module.hot._selfAccepted
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			var moduleOutdatedDependencies;
/******/ 		
/******/ 			return {
/******/ 				dispose: function () {
/******/ 					currentUpdateRemovedChunks.forEach(function (chunkId) {
/******/ 						delete installedChunks[chunkId];
/******/ 					});
/******/ 					currentUpdateRemovedChunks = undefined;
/******/ 		
/******/ 					var idx;
/******/ 					var queue = outdatedModules.slice();
/******/ 					while (queue.length > 0) {
/******/ 						var moduleId = queue.pop();
/******/ 						var module = __webpack_require__.c[moduleId];
/******/ 						if (!module) continue;
/******/ 		
/******/ 						var data = {};
/******/ 		
/******/ 						// Call dispose handlers
/******/ 						var disposeHandlers = module.hot._disposeHandlers;
/******/ 						for (j = 0; j < disposeHandlers.length; j++) {
/******/ 							disposeHandlers[j].call(null, data);
/******/ 						}
/******/ 						__webpack_require__.hmrD[moduleId] = data;
/******/ 		
/******/ 						// disable module (this disables requires from this module)
/******/ 						module.hot.active = false;
/******/ 		
/******/ 						// remove module from cache
/******/ 						delete __webpack_require__.c[moduleId];
/******/ 		
/******/ 						// when disposing there is no need to call dispose handler
/******/ 						delete outdatedDependencies[moduleId];
/******/ 		
/******/ 						// remove "parents" references from all children
/******/ 						for (j = 0; j < module.children.length; j++) {
/******/ 							var child = __webpack_require__.c[module.children[j]];
/******/ 							if (!child) continue;
/******/ 							idx = child.parents.indexOf(moduleId);
/******/ 							if (idx >= 0) {
/******/ 								child.parents.splice(idx, 1);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// remove outdated dependency from module children
/******/ 					var dependency;
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									dependency = moduleOutdatedDependencies[j];
/******/ 									idx = module.children.indexOf(dependency);
/******/ 									if (idx >= 0) module.children.splice(idx, 1);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				},
/******/ 				apply: function (reportError) {
/******/ 					var acceptPromises = [];
/******/ 					// insert new code
/******/ 					for (var updateModuleId in appliedUpdate) {
/******/ 						if (__webpack_require__.o(appliedUpdate, updateModuleId)) {
/******/ 							__webpack_require__.m[updateModuleId] = appliedUpdate[updateModuleId];
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// run new runtime modules
/******/ 					for (var i = 0; i < currentUpdateRuntime.length; i++) {
/******/ 						currentUpdateRuntime[i](__webpack_require__);
/******/ 					}
/******/ 		
/******/ 					// call accept handlers
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							var module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								var callbacks = [];
/******/ 								var errorHandlers = [];
/******/ 								var dependenciesForCallbacks = [];
/******/ 								for (var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									var dependency = moduleOutdatedDependencies[j];
/******/ 									var acceptCallback =
/******/ 										module.hot._acceptedDependencies[dependency];
/******/ 									var errorHandler =
/******/ 										module.hot._acceptedErrorHandlers[dependency];
/******/ 									if (acceptCallback) {
/******/ 										if (callbacks.indexOf(acceptCallback) !== -1) continue;
/******/ 										callbacks.push(acceptCallback);
/******/ 										errorHandlers.push(errorHandler);
/******/ 										dependenciesForCallbacks.push(dependency);
/******/ 									}
/******/ 								}
/******/ 								for (var k = 0; k < callbacks.length; k++) {
/******/ 									var result;
/******/ 									try {
/******/ 										result = callbacks[k].call(null, moduleOutdatedDependencies);
/******/ 									} catch (err) {
/******/ 										if (typeof errorHandlers[k] === "function") {
/******/ 											try {
/******/ 												errorHandlers[k](err, {
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k]
/******/ 												});
/******/ 											} catch (err2) {
/******/ 												if (options.onErrored) {
/******/ 													options.onErrored({
/******/ 														type: "accept-error-handler-errored",
/******/ 														moduleId: outdatedModuleId,
/******/ 														dependencyId: dependenciesForCallbacks[k],
/******/ 														error: err2,
/******/ 														originalError: err
/******/ 													});
/******/ 												}
/******/ 												if (!options.ignoreErrored) {
/******/ 													reportError(err2);
/******/ 													reportError(err);
/******/ 												}
/******/ 											}
/******/ 										} else {
/******/ 											if (options.onErrored) {
/******/ 												options.onErrored({
/******/ 													type: "accept-errored",
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k],
/******/ 													error: err
/******/ 												});
/******/ 											}
/******/ 											if (!options.ignoreErrored) {
/******/ 												reportError(err);
/******/ 											}
/******/ 										}
/******/ 									}
/******/ 									if (result && typeof result.then === "function") {
/******/ 										acceptPromises.push(result);
/******/ 									}
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					var onAccepted = function () {
/******/ 						// Load self accepted modules
/******/ 						for (var o = 0; o < outdatedSelfAcceptedModules.length; o++) {
/******/ 							var item = outdatedSelfAcceptedModules[o];
/******/ 							var moduleId = item.module;
/******/ 							try {
/******/ 								item.require(moduleId);
/******/ 							} catch (err) {
/******/ 								if (typeof item.errorHandler === "function") {
/******/ 									try {
/******/ 										item.errorHandler(err, {
/******/ 											moduleId: moduleId,
/******/ 											module: __webpack_require__.c[moduleId]
/******/ 										});
/******/ 									} catch (err1) {
/******/ 										if (options.onErrored) {
/******/ 											options.onErrored({
/******/ 												type: "self-accept-error-handler-errored",
/******/ 												moduleId: moduleId,
/******/ 												error: err1,
/******/ 												originalError: err
/******/ 											});
/******/ 										}
/******/ 										if (!options.ignoreErrored) {
/******/ 											reportError(err1);
/******/ 											reportError(err);
/******/ 										}
/******/ 									}
/******/ 								} else {
/******/ 									if (options.onErrored) {
/******/ 										options.onErrored({
/******/ 											type: "self-accept-errored",
/******/ 											moduleId: moduleId,
/******/ 											error: err
/******/ 										});
/******/ 									}
/******/ 									if (!options.ignoreErrored) {
/******/ 										reportError(err);
/******/ 									}
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					};
/******/ 		
/******/ 					return Promise.all(acceptPromises)
/******/ 						.then(onAccepted)
/******/ 						.then(function () {
/******/ 							return outdatedModules;
/******/ 						});
/******/ 				}
/******/ 			};
/******/ 		}
/******/ 		__webpack_require__.hmrI.jsonp = function (moduleId, applyHandlers) {
/******/ 			if (!currentUpdate) {
/******/ 				currentUpdate = {};
/******/ 				currentUpdateRuntime = [];
/******/ 				currentUpdateRemovedChunks = [];
/******/ 				applyHandlers.push(applyHandler);
/******/ 			}
/******/ 			if (!__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 				currentUpdate[moduleId] = __webpack_require__.m[moduleId];
/******/ 			}
/******/ 		};
/******/ 		__webpack_require__.hmrC.jsonp = function (
/******/ 			chunkIds,
/******/ 			removedChunks,
/******/ 			removedModules,
/******/ 			promises,
/******/ 			applyHandlers,
/******/ 			updatedModulesList
/******/ 		) {
/******/ 			applyHandlers.push(applyHandler);
/******/ 			currentUpdateChunks = {};
/******/ 			currentUpdateRemovedChunks = removedChunks;
/******/ 			currentUpdate = removedModules.reduce(function (obj, key) {
/******/ 				obj[key] = false;
/******/ 				return obj;
/******/ 			}, {});
/******/ 			currentUpdateRuntime = [];
/******/ 			chunkIds.forEach(function (chunkId) {
/******/ 				if (
/******/ 					__webpack_require__.o(installedChunks, chunkId) &&
/******/ 					installedChunks[chunkId] !== undefined
/******/ 				) {
/******/ 					promises.push(loadUpdateChunk(chunkId, updatedModulesList));
/******/ 					currentUpdateChunks[chunkId] = true;
/******/ 				} else {
/******/ 					currentUpdateChunks[chunkId] = false;
/******/ 				}
/******/ 			});
/******/ 			if (__webpack_require__.f) {
/******/ 				__webpack_require__.f.jsonpHmr = function (chunkId, promises) {
/******/ 					if (
/******/ 						currentUpdateChunks &&
/******/ 						__webpack_require__.o(currentUpdateChunks, chunkId) &&
/******/ 						!currentUpdateChunks[chunkId]
/******/ 					) {
/******/ 						promises.push(loadUpdateChunk(chunkId));
/******/ 						currentUpdateChunks[chunkId] = true;
/******/ 					}
/******/ 				};
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.hmrM = () => {
/******/ 			if (typeof fetch === "undefined") throw new Error("No browser support: need fetch API");
/******/ 			return fetch(__webpack_require__.p + __webpack_require__.hmrF()).then((response) => {
/******/ 				if(response.status === 404) return; // no update available
/******/ 				if(!response.ok) throw new Error("Failed to fetch update manifest " + response.statusText);
/******/ 				return response.json();
/******/ 			});
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkse_tailoring_framework"] = self["webpackChunkse_tailoring_framework"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	__webpack_require__.O(undefined, ["vendors"], () => (__webpack_require__("./node_modules/webpack-dev-server/client/index.js?protocol=ws%3A&hostname=0.0.0.0&port=3000&pathname=%2Fws&logging=info&overlay=true&reconnect=10&hot=true&live-reload=true")))
/******/ 	__webpack_require__.O(undefined, ["vendors"], () => (__webpack_require__("./node_modules/webpack/hot/dev-server.js")))
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["vendors"], () => (__webpack_require__("./js/app.js")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;
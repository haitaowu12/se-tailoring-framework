"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdatese_tailoring_framework"]("main",{

/***/ "./js/app.js":
/*!*******************!*\
  !*** ./js/app.js ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _components_assessment_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/assessment.js */ \"./js/components/assessment.js\");\n/* harmony import */ var _components_assessment_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_components_assessment_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_visualization_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/visualization.js */ \"./js/components/visualization.js\");\n/* harmony import */ var _components_visualization_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_components_visualization_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_recommendations_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/recommendations.js */ \"./js/components/recommendations.js\");\n/* harmony import */ var _components_recommendations_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_components_recommendations_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _components_export_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/export.js */ \"./js/components/export.js\");\n/* harmony import */ var _components_export_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_components_export_js__WEBPACK_IMPORTED_MODULE_3__);\n/**\n * Main Application Controller for SE Process Tailoring Framework\n * Handles navigation, data loading, and view management\n */\n\n// Import component modules\n\n\n\n\n\nclass SEFrameworkApp {\n  constructor() {\n    this.currentView = \"welcome\";\n    this.assessmentData = {};\n    this.processData = {};\n    this.questionData = {};\n    this.dependencyData = {};\n    this.recommendations = {};\n    this.assessmentEngine = null;\n    this.visualizer = null;\n    this.recommendationEngine = null;\n    this.exportManager = null;\n\n    // Assessment state\n    this.assessmentResponses = {};\n    this.assessmentScores = {\n      complexity: 0,\n      safety: 0,\n      scale: 0,\n      maturity: 0,\n      overall: 0,\n    };\n\n    this.init();\n  }\n\n  async init() {\n    try {\n      console.log(\"=== SE Framework App Initialization Started ===\");\n      this.showLoading();\n\n      // Check if required components are loaded\n      console.log(\"Step 1: Checking component availability:\", {\n        AssessmentEngine: typeof AssessmentEngine,\n        ProcessNetworkVisualizer: typeof ProcessNetworkVisualizer,\n        RecommendationEngine: typeof RecommendationEngine,\n        ExportManager: typeof ExportManager,\n      });\n\n      console.log(\"Step 2: Loading data...\");\n      await this.loadData();\n      console.log(\"Step 3: Data loaded successfully\");\n\n      console.log(\"Step 4: Setting up event listeners...\");\n      this.setupEventListeners();\n      console.log(\"Step 5: Event listeners setup complete\");\n\n      console.log(\"Step 6: Rendering welcome view...\");\n      this.renderWelcomeView();\n      console.log(\"Step 7: Welcome view rendered\");\n\n      console.log(\"Step 8: About to hide loading overlay...\");\n      this.hideLoading();\n      console.log(\"Step 9: Loading overlay hidden\");\n\n      console.log(\"=== App Initialized Successfully ===\");\n    } catch (error) {\n      console.error(\"=== App Initialization Failed ===\", error);\n      console.error(\"Error details:\", error.stack);\n      this.showError(\n        `Failed to load application data: ${error.message}. Please refresh the page.`,\n      );\n      this.hideLoading();\n    }\n  }\n\n  async loadData() {\n    try {\n      console.log(\"Starting data loading...\");\n\n      // Load data files sequentially for better error handling\n      const processesResponse = await fetch(\"data/processes.json\");\n      console.log(\"Processes response status:\", processesResponse.status);\n      if (!processesResponse.ok) {\n        throw new Error(\"Failed to load processes data\");\n      }\n      const processes = await processesResponse.json();\n\n      const questionsResponse = await fetch(\"data/questions.json\");\n      console.log(\"Questions response status:\", questionsResponse.status);\n      if (!questionsResponse.ok) {\n        throw new Error(\"Failed to load questions data\");\n      }\n      const questions = await questionsResponse.json();\n\n      const dependenciesResponse = await fetch(\"data/dependencies.json\");\n      console.log(\"Dependencies response status:\", dependenciesResponse.status);\n      if (!dependenciesResponse.ok) {\n        throw new Error(\"Failed to load dependencies data\");\n      }\n      const dependencies = await dependenciesResponse.json();\n\n      console.log(\"Data loaded successfully:\", {\n        processes: processes.processes ? processes.processes.length : 0,\n        questions: questions.assessmentCategories\n          ? questions.assessmentCategories.length\n          : 0,\n        dependencies: dependencies.dependencies\n          ? dependencies.dependencies.length\n          : 0,\n      });\n\n      this.processData = processes;\n      this.questionData = questions;\n      this.dependencyData = dependencies;\n\n      console.log(\"Step 2.5: Checking component classes...\");\n      // Check if component classes are available\n      const componentCheck = {\n        AssessmentEngine: typeof AssessmentEngine,\n        ProcessNetworkVisualizer: typeof ProcessNetworkVisualizer,\n        RecommendationEngine: typeof RecommendationEngine,\n        ExportManager: typeof ExportManager,\n      };\n      console.log(\"Component availability:\", componentCheck);\n\n      if (typeof AssessmentEngine === \"undefined\") {\n        throw new Error(\"AssessmentEngine class not loaded\");\n      }\n      if (typeof ProcessNetworkVisualizer === \"undefined\") {\n        throw new Error(\"ProcessNetworkVisualizer class not loaded\");\n      }\n      if (typeof RecommendationEngine === \"undefined\") {\n        throw new Error(\"RecommendationEngine class not loaded\");\n      }\n      if (typeof ExportManager === \"undefined\") {\n        throw new Error(\"ExportManager class not loaded\");\n      }\n\n      console.log(\"Step 2.6: Initializing components...\");\n      // Initialize components\n      this.assessmentEngine = new AssessmentEngine(this.questionData, this);\n      console.log(\"AssessmentEngine created\");\n\n      this.visualizer = new ProcessNetworkVisualizer(\n        this.processData,\n        this.dependencyData,\n        this,\n      );\n      console.log(\"ProcessNetworkVisualizer created\");\n\n      this.recommendationEngine = new RecommendationEngine(\n        this.processData,\n        this.dependencyData,\n        this,\n      );\n      console.log(\"RecommendationEngine created\");\n\n      this.exportManager = new ExportManager(this);\n      console.log(\"ExportManager created\");\n\n      console.log(\"Step 2.7: All components initialized successfully\");\n    } catch (error) {\n      console.error(\"Error loading data:\", error);\n      throw error;\n    }\n  }\n\n  setupEventListeners() {\n    try {\n      // Navigation\n      const brandLink = document.getElementById(\"brand-link\");\n      if (brandLink) {\n        brandLink.addEventListener(\"click\", (e) => {\n          e.preventDefault();\n          this.showView(\"welcome\");\n        });\n      }\n\n      const navWelcome = document.getElementById(\"nav-welcome\");\n      if (navWelcome) {\n        navWelcome.addEventListener(\"click\", (e) => {\n          e.preventDefault();\n          this.showView(\"welcome\");\n        });\n      }\n\n      const navAssessment = document.getElementById(\"nav-assessment\");\n      if (navAssessment) {\n        navAssessment.addEventListener(\"click\", (e) => {\n          e.preventDefault();\n          this.showView(\"assessment\");\n        });\n      }\n\n      const navVisualization = document.getElementById(\"nav-visualization\");\n      if (navVisualization) {\n        navVisualization.addEventListener(\"click\", (e) => {\n          e.preventDefault();\n          this.showView(\"visualization\");\n        });\n      }\n\n      const navRecommendations = document.getElementById(\"nav-recommendations\");\n      if (navRecommendations) {\n        navRecommendations.addEventListener(\"click\", (e) => {\n          e.preventDefault();\n          this.showView(\"recommendations\");\n        });\n      }\n\n      const navExport = document.getElementById(\"nav-export\");\n      if (navExport) {\n        navExport.addEventListener(\"click\", (e) => {\n          e.preventDefault();\n          this.showView(\"export\");\n        });\n      }\n\n      // Start assessment button\n      const startAssessmentBtn = document.getElementById(\n        \"start-assessment-btn\",\n      );\n      if (startAssessmentBtn) {\n        startAssessmentBtn.addEventListener(\"click\", () => {\n          this.showView(\"assessment\");\n        });\n      }\n    } catch (error) {\n      console.error(\"Error setting up event listeners:\", error);\n    }\n\n    // Keyboard navigation\n    document.addEventListener(\"keydown\", (e) => {\n      if (e.ctrlKey || e.metaKey) {\n        switch (e.key) {\n          case \"1\":\n            e.preventDefault();\n            this.showView(\"welcome\");\n            break;\n          case \"2\":\n            e.preventDefault();\n            this.showView(\"assessment\");\n            break;\n          case \"3\":\n            e.preventDefault();\n            this.showView(\"visualization\");\n            break;\n          case \"4\":\n            e.preventDefault();\n            this.showView(\"recommendations\");\n            break;\n          case \"5\":\n            e.preventDefault();\n            this.showView(\"export\");\n            break;\n        }\n      }\n    });\n  }\n\n  showView(viewName) {\n    console.log(`=== showView called with: ${viewName} ===`);\n    try {\n      console.log(`Step 1: Hiding all views...`);\n      // Hide all views\n      const allViews = document.querySelectorAll(\".view-container\");\n      console.log(`Found ${allViews.length} view containers`);\n      allViews.forEach((view) => {\n        view.style.display = \"none\";\n      });\n\n      console.log(`Step 2: Updating navigation...`);\n      // Update navigation\n      const allNavLinks = document.querySelectorAll(\".nav-link\");\n      console.log(`Found ${allNavLinks.length} nav links`);\n      allNavLinks.forEach((link) => {\n        link.classList.remove(\"active\");\n      });\n\n      console.log(`Step 3: Showing target view: ${viewName}-view`);\n      // Show selected view\n      const targetView = document.getElementById(`${viewName}-view`);\n      console.log(`Target view element:`, targetView);\n\n      if (targetView) {\n        targetView.style.display = \"block\";\n        console.log(`Step 3a: Target view displayed`);\n\n        // Activate corresponding nav link\n        const navLink = document.getElementById(`nav-${viewName}`);\n        console.log(`Nav link element:`, navLink);\n        if (navLink) {\n          navLink.classList.add(\"active\");\n          console.log(`Step 3b: Nav link activated`);\n        }\n\n        this.currentView = viewName;\n        console.log(`Step 3c: Current view set to ${viewName}`);\n\n        console.log(`Step 4: Initializing view-specific content...`);\n        // Initialize view-specific content\n        switch (viewName) {\n          case \"assessment\":\n            this.renderAssessmentView();\n            break;\n          case \"visualization\":\n            this.renderVisualizationView();\n            break;\n          case \"recommendations\":\n            this.renderRecommendationsView();\n            break;\n          case \"export\":\n            this.renderExportView();\n            break;\n        }\n        console.log(`Step 4a: View-specific content initialized`);\n\n        console.log(`Step 5: Updating progress indicator...`);\n        // Update progress indicator\n        this.updateProgressIndicator();\n        console.log(`Step 5a: Progress indicator updated`);\n\n        // Scroll to top\n        window.scrollTo(0, 0);\n        console.log(`Step 6: Scrolled to top`);\n\n        console.log(`=== View ${viewName} shown successfully ===`);\n      } else {\n        console.error(`View ${viewName} not found`);\n        console.error(\n          `Available views:`,\n          Array.from(document.querySelectorAll('[id$=\"-view\"]')).map(\n            (el) => el.id,\n          ),\n        );\n      }\n    } catch (error) {\n      console.error(`Error showing view ${viewName}:`, error);\n      console.error(`Error stack:`, error.stack);\n    }\n  }\n\n  renderWelcomeView() {\n    console.log(\"Rendering welcome view...\");\n    try {\n      // Welcome view is static HTML, just ensure it's visible\n      this.showView(\"welcome\");\n      console.log(\"Welcome view rendered successfully\");\n    } catch (error) {\n      console.error(\"Error rendering welcome view:\", error);\n      // Fallback: manually show welcome view\n      const welcomeView = document.getElementById(\"welcome-view\");\n      if (welcomeView) {\n        welcomeView.style.display = \"block\";\n      }\n    }\n  }\n\n  renderAssessmentView() {\n    if (this.assessmentEngine) {\n      this.assessmentEngine.render();\n      this.showProgressIndicator();\n    }\n  }\n\n  renderVisualizationView() {\n    if (this.visualizer) {\n      // Small delay to ensure container is visible before rendering\n      setTimeout(() => {\n        this.visualizer.render();\n      }, 100);\n    }\n  }\n\n  renderRecommendationsView() {\n    if (this.recommendationEngine) {\n      this.recommendationEngine.render();\n    }\n  }\n\n  renderExportView() {\n    if (this.exportManager) {\n      this.exportManager.render();\n    }\n  }\n\n  updateProgressIndicator() {\n    const progressContainer = document.getElementById(\"progress-container\");\n    const progressBar = document.getElementById(\"overall-progress\");\n    const progressText = document.getElementById(\"progress-text\");\n\n    if (this.currentView === \"welcome\") {\n      progressContainer.style.display = \"none\";\n      return;\n    }\n\n    // Calculate overall progress\n    let progress = 0;\n    switch (this.currentView) {\n      case \"assessment\":\n        progress = this.getAssessmentProgress();\n        break;\n      case \"visualization\":\n        progress = this.hasCompletedAssessment() ? 75 : 25;\n        break;\n      case \"recommendations\":\n        progress = this.hasCompletedAssessment() ? 90 : 50;\n        break;\n      case \"export\":\n        progress = 100;\n        break;\n    }\n\n    progressContainer.style.display = \"block\";\n    progressBar.style.width = `${progress}%`;\n    progressText.textContent = `${Math.round(progress)}%`;\n  }\n\n  showProgressIndicator() {\n    document.getElementById(\"progress-container\").style.display = \"block\";\n  }\n\n  hideProgressIndicator() {\n    document.getElementById(\"progress-container\").style.display = \"none\";\n  }\n\n  getAssessmentProgress() {\n    if (!this.assessmentEngine) return 0;\n\n    const totalQuestions = this.getTotalQuestions();\n    const answeredQuestions = Object.keys(this.assessmentResponses).length;\n\n    return totalQuestions > 0\n      ? Math.min((answeredQuestions / totalQuestions) * 60, 60)\n      : 0;\n  }\n\n  getTotalQuestions() {\n    if (!this.questionData.assessmentCategories) return 0;\n\n    return this.questionData.assessmentCategories.reduce((total, category) => {\n      return total + (category.questions ? category.questions.length : 0);\n    }, 0);\n  }\n\n  hasCompletedAssessment() {\n    const totalQuestions = this.getTotalQuestions();\n    const answeredQuestions = Object.keys(this.assessmentResponses).length;\n    return answeredQuestions >= totalQuestions && totalQuestions > 0;\n  }\n\n  updateAssessmentResponse(questionId, response) {\n    this.assessmentResponses[questionId] = response;\n    this.calculateScores();\n    this.updateProgressIndicator();\n\n    // Auto-save to localStorage\n    this.saveAssessmentState();\n  }\n\n  calculateScores() {\n    if (!this.questionData.assessmentCategories) return;\n\n    const dimensionScores = {\n      complexity: [],\n      safety: [],\n      scale: [],\n      maturity: [],\n    };\n\n    // Calculate dimension scores based on responses\n    this.questionData.assessmentCategories.forEach((category) => {\n      category.questions.forEach((question) => {\n        const response = this.assessmentResponses[question.id];\n        if (response && response.score !== undefined) {\n          const dimension = question.dimension;\n          if (dimensionScores[dimension]) {\n            dimensionScores[dimension].push({\n              score: response.score,\n              weight: question.weight || 1,\n            });\n          }\n        }\n      });\n    });\n\n    // Calculate weighted averages for each dimension\n    Object.keys(dimensionScores).forEach((dimension) => {\n      const scores = dimensionScores[dimension];\n      if (scores.length > 0) {\n        const weightedSum = scores.reduce(\n          (sum, item) => sum + item.score * item.weight,\n          0,\n        );\n        const totalWeight = scores.reduce((sum, item) => sum + item.weight, 0);\n        this.assessmentScores[dimension] =\n          totalWeight > 0 ? weightedSum / totalWeight : 0;\n      }\n    });\n\n    // Calculate overall score (weighted average of dimensions)\n    const dimensionWeights = {\n      complexity: 0.3,\n      safety: 0.25,\n      scale: 0.25,\n      maturity: 0.2,\n    };\n\n    let overallScore = 0;\n    let totalWeight = 0;\n\n    Object.keys(dimensionWeights).forEach((dimension) => {\n      if (this.assessmentScores[dimension] > 0) {\n        overallScore +=\n          this.assessmentScores[dimension] * dimensionWeights[dimension];\n        totalWeight += dimensionWeights[dimension];\n      }\n    });\n\n    this.assessmentScores.overall =\n      totalWeight > 0 ? overallScore / totalWeight : 0;\n\n    // Generate recommendations if assessment is complete\n    if (this.hasCompletedAssessment() && this.recommendationEngine) {\n      this.recommendations = this.recommendationEngine.generateRecommendations(\n        this.assessmentScores,\n      );\n    }\n  }\n\n  saveAssessmentState() {\n    const state = {\n      responses: this.assessmentResponses,\n      scores: this.assessmentScores,\n      recommendations: this.recommendations,\n      timestamp: Date.now(),\n    };\n    localStorage.setItem(\"se-tailoring-assessment\", JSON.stringify(state));\n  }\n\n  loadAssessmentState() {\n    try {\n      const saved = localStorage.getItem(\"se-tailoring-assessment\");\n      if (saved) {\n        const state = JSON.parse(saved);\n\n        // Only load if saved within last 24 hours\n        const dayOld = 24 * 60 * 60 * 1000;\n        if (Date.now() - state.timestamp < dayOld) {\n          this.assessmentResponses = state.responses || {};\n          this.assessmentScores = state.scores || {};\n          this.recommendations = state.recommendations || {};\n          return true;\n        }\n      }\n    } catch (error) {\n      // Failed to load saved assessment state\n    }\n    return false;\n  }\n\n  clearAssessmentState() {\n    this.assessmentResponses = {};\n    this.assessmentScores = {\n      complexity: 0,\n      safety: 0,\n      scale: 0,\n      maturity: 0,\n      overall: 0,\n    };\n    this.recommendations = {};\n    localStorage.removeItem(\"se-tailoring-assessment\");\n    this.updateProgressIndicator();\n  }\n\n  showLoading() {\n    document.getElementById(\"loading-overlay\").style.display = \"flex\";\n  }\n\n  hideLoading() {\n    console.log(\"=== Hiding loading overlay ===\");\n    const loadingOverlay = document.getElementById(\"loading-overlay\");\n    console.log(\"Loading overlay element:\", loadingOverlay);\n\n    if (loadingOverlay) {\n      console.log(\"Current display style:\", loadingOverlay.style.display);\n      console.log(\n        \"Current computed style:\",\n        window.getComputedStyle(loadingOverlay).display,\n      );\n\n      // Try multiple approaches to hide it\n      loadingOverlay.style.display = \"none\";\n      loadingOverlay.style.visibility = \"hidden\";\n      loadingOverlay.style.opacity = \"0\";\n      loadingOverlay.style.pointerEvents = \"none\";\n\n      // Also add a class to ensure it stays hidden\n      loadingOverlay.classList.add(\"hidden\");\n\n      console.log(\"Loading overlay hidden with multiple methods\");\n      console.log(\"New display style:\", loadingOverlay.style.display);\n      console.log(\n        \"New computed style:\",\n        window.getComputedStyle(loadingOverlay).display,\n      );\n    } else {\n      console.warn(\"Loading overlay element not found\");\n      console.log(\n        \"Available elements with loading in ID:\",\n        Array.from(document.querySelectorAll('[id*=\"loading\"]')).map(\n          (el) => el.id,\n        ),\n      );\n    }\n    console.log(\"=== Loading overlay hide attempt complete ===\");\n  }\n\n  showError(message) {\n    console.error(\"Showing error:\", message);\n\n    // Create and show error alert\n    const alertHtml = `\n            <div class=\"alert alert-danger alert-dismissible fade show\" role=\"alert\">\n                <i class=\"bi bi-exclamation-triangle-fill me-2\"></i>\n                <strong>Error:</strong> ${message}\n                <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"alert\"></button>\n            </div>\n        `;\n\n    // Insert at top of main content\n    const mainContent = document.getElementById(\"main-content\");\n    if (mainContent) {\n      mainContent.insertAdjacentHTML(\"afterbegin\", alertHtml);\n\n      // Auto-remove after 10 seconds\n      setTimeout(() => {\n        const alert = mainContent.querySelector(\".alert-danger\");\n        if (alert) {\n          try {\n            const bsAlert = new bootstrap.Alert(alert);\n            bsAlert.close();\n          } catch (e) {\n            // Fallback: just remove the element\n            alert.remove();\n          }\n        }\n      }, 10000);\n    } else {\n      console.error(\"Main content element not found for error display\");\n    }\n  }\n\n  showSuccess(message) {\n    // Create and show success alert\n    const alertHtml = `\n            <div class=\"alert alert-success alert-dismissible fade show\" role=\"alert\">\n                <i class=\"bi bi-check-circle-fill me-2\"></i>\n                ${message}\n                <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"alert\"></button>\n            </div>\n        `;\n\n    // Insert at top of main content\n    const mainContent = document.getElementById(\"main-content\");\n    mainContent.insertAdjacentHTML(\"afterbegin\", alertHtml);\n\n    // Auto-remove after 5 seconds\n    setTimeout(() => {\n      const alert = mainContent.querySelector(\".alert-success\");\n      if (alert) {\n        const bsAlert = new bootstrap.Alert(alert);\n        bsAlert.close();\n      }\n    }, 5000);\n  }\n\n  // Utility methods\n  getProcessById(processId) {\n    return this.processData.processes?.find((p) => p.id === processId);\n  }\n\n  getDependenciesForProcess(processId) {\n    return (\n      this.dependencyData.dependencies?.filter((d) => d.source === processId) ||\n      []\n    );\n  }\n\n  getProcessesDependingOn(processId) {\n    return (\n      this.dependencyData.dependencies?.filter((d) => d.target === processId) ||\n      []\n    );\n  }\n\n  showProcessDetails(processId) {\n    const modal = document.getElementById('process-detail-modal');\n    const title = document.getElementById('process-modal-title');\n    const body = document.getElementById('process-modal-body');\n\n    if (!modal || !title || !body) {\n      console.error('Modal elements not found - check HTML structure');\n      return;\n    }\n\n    // Ensure modal is properly initialized in the DOM\n    if (!modal.classList.contains('modal')) {\n      console.error('Modal element is not properly initialized');\n      return;\n    }\n\n    const process = this.getProcessById(processId);\n    const recommendation = this.recommendations[processId];\n\n    if (!process) {\n      return;\n    }\n\n    const recommendedLevel = recommendation?.recommendedLevel || 'basic';\n    \n    title.textContent = process.name;\n\n    body.innerHTML = `\n            <div class=\"row\">\n                <div class=\"col-md-6\">\n                    <h6>Current Recommendation</h6>\n                    <span class=\"level-badge level-${recommendedLevel}\">${recommendedLevel}</span>\n                    <p class=\"mt-2 text-muted\">${process.description || 'No description available'}</p>\n                </div>\n                <div class=\"col-md-6\">\n                    <h6>Process Metrics</h6>\n                    <ul class=\"list-unstyled\">\n                        <li><strong>Effort:</strong> ${recommendation?.effort || 1}/5</li>\n                        <li><strong>Complexity:</strong> ${recommendation?.complexity || 1}/5</li>\n                        <li><strong>Confidence:</strong> ${Math.round((recommendation?.confidence || 0.8) * 100)}%</li>\n                        <li><strong>Category:</strong> ${this.processData.processCategories?.[process.category] || process.category}</li>\n                    </ul>\n                </div>\n            </div>\n\n            ${recommendation?.rationale ? `\n                <div class=\"mt-3\">\n                    <h6>Rationale</h6>\n                    <ul class=\"list-unstyled\">\n                        ${recommendation.rationale.map(reason => `<li class=\"text-muted\">â€¢ ${reason}</li>`).join('')}\n                    </ul>\n                </div>\n            ` : ''}\n\n            ${process?.tailoringLevels ? `\n                <div class=\"mt-3\">\n                    <h6>Available Tailoring Levels</h6>\n                    <div class=\"accordion\" id=\"levels-accordion\">\n                        ${Object.keys(process.tailoringLevels).map((level, index) => `\n                            <div class=\"accordion-item\">\n                                <h2 class=\"accordion-header\">\n                                    <button class=\"accordion-button ${level !== recommendedLevel ? 'collapsed' : ''}\" \n                                            type=\"button\" data-bs-toggle=\"collapse\" \n                                            data-bs-target=\"#level-${level}\">\n                                        <span class=\"level-badge level-${level} me-2\">${level}</span>\n                                        ${process.tailoringLevels[level].description}\n                                    </button>\n                                </h2>\n                                <div id=\"level-${level}\" \n                                     class=\"accordion-collapse collapse ${level === recommendedLevel ? 'show' : ''}\"\n                                     data-bs-parent=\"#levels-accordion\">\n                                    <div class=\"accordion-body\">\n                                        <p><strong>Activities:</strong></p>\n                                        <ul>\n                                            ${process.tailoringLevels[level].activities?.map(activity => `<li>${activity}</li>`).join('') || '<li>No activities specified</li>'}\n                                        </ul>\n                                        <p><strong>Key Outputs:</strong></p>\n                                        <ul>\n                                            ${process.tailoringLevels[level].outputs?.map(output => `<li>${output}</li>`).join('') || '<li>No outputs specified</li>'}\n                                        </ul>\n                                    </div>\n                                </div>\n                            </div>\n                        `).join('')}\n                    </div>\n                </div>\n            ` : ''}\n        `;\n\n    // Ensure Bootstrap is available\n    if (typeof bootstrap === 'undefined') {\n      console.error('Bootstrap not available');\n      return;\n    }\n\n    try {\n      const bsModal = new bootstrap.Modal(modal);\n      bsModal.show();\n      console.log('Modal shown successfully for process:', processId);\n      \n      // Debug: Check modal state after showing\n      setTimeout(() => {\n        console.log('=== MODAL DEBUG INFO ===');\n        console.log('Modal display:', modal.style.display);\n        console.log('Modal classes:', modal.className);\n        console.log('Modal visibility:', modal.offsetParent !== null);\n        \n        // Check if backdrop exists\n        const backdrops = document.querySelectorAll('.modal-backdrop');\n        console.log('Backdrops found:', backdrops.length);\n        \n        // Check z-index issues\n        console.log('Modal z-index:', modal.style.zIndex);\n        console.log('Modal computed z-index:', window.getComputedStyle(modal).zIndex);\n        \n        // Check if modal is actually visible\n        const rect = modal.getBoundingClientRect();\n        console.log('Modal position:', rect.top, rect.left, rect.width, rect.height);\n        console.log('Modal in viewport:', rect.top >= 0 && rect.left >= 0 && \n          rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && \n          rect.right <= (window.innerWidth || document.documentElement.clientWidth));\n        \n        // Check if any parent elements are hidden\n        let current = modal;\n        const hiddenParents = [];\n        while (current.parentElement) {\n          current = current.parentElement;\n          const style = window.getComputedStyle(current);\n          if (style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0') {\n            hiddenParents.push(current);\n          }\n        }\n        console.log('Hidden parents:', hiddenParents.length, hiddenParents);\n        \n        // Force modal to be visible if hidden - check all possible hiding conditions\n        const computedStyle = window.getComputedStyle(modal);\n        if (modal.offsetParent === null || \n            rect.width === 0 || \n            rect.height === 0 ||\n            computedStyle.display === 'none' ||\n            computedStyle.visibility === 'hidden' ||\n            computedStyle.opacity === '0') {\n          \n          console.log('Modal appears hidden - forcing visibility');\n          \n          // Remove from DOM and re-append to ensure proper positioning\n          const parent = modal.parentElement;\n          parent.removeChild(modal);\n          document.body.appendChild(modal);\n          \n          // Force visible styles\n          modal.style.display = 'block';\n          modal.style.visibility = 'visible';\n          modal.style.opacity = '1';\n          modal.style.zIndex = '1050';\n          modal.style.position = 'fixed';\n          modal.style.top = '50%';\n          modal.style.left = '50%';\n          modal.style.transform = 'translate(-50%, -50%)';\n          \n          // Ensure backdrop is properly positioned\n          const backdrops = document.querySelectorAll('.modal-backdrop');\n          backdrops.forEach(backdrop => {\n            backdrop.style.zIndex = '1040';\n          });\n        }\n        \n        console.log('=== END DEBUG ===');\n      }, 100);\n      \n    } catch (error) {\n      console.error('Failed to show modal:', error);\n      // Fallback: manually show the modal if Bootstrap fails\n      modal.style.display = 'block';\n      modal.classList.add('show');\n      document.body.classList.add('modal-open');\n      \n      // Create backdrop manually\n      const backdrop = document.createElement('div');\n      backdrop.className = 'modal-backdrop fade show';\n      backdrop.style.zIndex = '1040';\n      document.body.appendChild(backdrop);\n      \n      // Ensure modal has proper z-index\n      modal.style.zIndex = '1050';\n    }\n  }\n\n  // Public API for components\n  getAssessmentData() {\n    return {\n      responses: this.assessmentResponses,\n      scores: this.assessmentScores,\n      recommendations: this.recommendations,\n    };\n  }\n\n  getProcessData() {\n    return this.processData;\n  }\n\n  getDependencyData() {\n    return this.dependencyData;\n  }\n}\n\n// Initialize application when DOM is loaded\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  console.log(\"DOM loaded, initializing app...\");\n\n  // Failsafe: Hide loading screen after 10 seconds regardless of what happens\n  const failsafeTimeout = setTimeout(() => {\n    console.warn(\"Failsafe timeout reached - hiding loading screen\");\n    forceHideLoadingOverlay();\n  }, 10000);\n\n  // Wait a bit to ensure all scripts are loaded\n  setTimeout(() => {\n    try {\n      // Check if all required components are available\n      const requiredComponents = [\n        \"AssessmentEngine\",\n        \"ProcessNetworkVisualizer\",\n        \"RecommendationEngine\",\n        \"ExportManager\",\n      ];\n\n      const missingComponents = requiredComponents.filter(\n        (comp) => typeof window[comp] === \"undefined\",\n      );\n\n      if (missingComponents.length > 0) {\n        console.error(\"Missing components:\", missingComponents);\n        throw new Error(\n          `Required components not loaded: ${missingComponents.join(\", \")}`,\n        );\n      }\n\n      console.log(\"All components available, initializing app...\");\n      window.seApp = new SEFrameworkApp();\n\n      // Clear failsafe timeout if app initializes successfully\n      clearTimeout(failsafeTimeout);\n\n      // Additional failsafe: Force hide loading overlay after successful initialization\n      setTimeout(() => {\n        console.log(\"Additional failsafe: Forcing loading overlay to hide\");\n        forceHideLoadingOverlay();\n      }, 1000);\n    } catch (error) {\n      console.error(\"Failed to initialize app:\", error);\n\n      // Clear failsafe timeout since we're handling the error\n      clearTimeout(failsafeTimeout);\n\n      // Show error to user\n      const loadingOverlay = document.getElementById(\"loading-overlay\");\n      if (loadingOverlay) {\n        loadingOverlay.innerHTML = `\n                    <div class=\"text-center text-white\">\n                        <div class=\"spinner-border mb-3\" role=\"status\">\n                            <span class=\"visually-hidden\">Loading...</span>\n                        </div>\n                        <p class=\"text-danger\">Failed to initialize application</p>\n                        <p class=\"small\">${error.message}</p>\n                        <button class=\"btn btn-outline-light\" onclick=\"window.location.reload()\">Retry</button>\n                    </div>\n                `;\n      }\n    }\n  }, 100); // Small delay to ensure scripts are loaded\n});\n\n// Aggressive function to hide loading overlay\nfunction forceHideLoadingOverlay() {\n  console.log(\"=== Force hiding loading overlay ===\");\n\n  // Try multiple selectors\n  const selectors = [\n    \"#loading-overlay\",\n    \".loading-overlay\",\n    '[id*=\"loading\"]',\n    \".position-fixed.top-0.start-0.w-100.h-100\",\n  ];\n\n  selectors.forEach((selector) => {\n    try {\n      const elements = document.querySelectorAll(selector);\n      elements.forEach((element) => {\n        console.log(`Hiding element with selector: ${selector}`);\n        element.style.display = \"none\";\n        element.style.visibility = \"hidden\";\n        element.style.opacity = \"0\";\n        element.style.pointerEvents = \"none\";\n        element.classList.add(\"hidden\");\n        element.setAttribute(\"hidden\", \"\");\n      });\n    } catch (error) {\n      console.warn(`Error hiding elements with selector ${selector}:`, error);\n    }\n  });\n\n  // Also try to remove the loading overlay completely\n  try {\n    const loadingOverlay = document.getElementById(\"loading-overlay\");\n    if (loadingOverlay && loadingOverlay.parentNode) {\n      console.log(\"Removing loading overlay from DOM\");\n      loadingOverlay.parentNode.removeChild(loadingOverlay);\n    }\n  } catch (error) {\n    console.warn(\"Error removing loading overlay from DOM:\", error);\n  }\n\n  console.log(\"=== Force hide complete ===\");\n}\n\n// Handle browser back/forward buttons\nwindow.addEventListener(\"popstate\", (event) => {\n  if (window.seApp && event.state) {\n    window.seApp.showView(event.state.view);\n  }\n});\n\n// Export for global access\nwindow.SEFrameworkApp = SEFrameworkApp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2UtdGFpbG9yaW5nLWZyYW1ld29yay8uL2pzL2FwcC5qcz83NDczIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTWFpbiBBcHBsaWNhdGlvbiBDb250cm9sbGVyIGZvciBTRSBQcm9jZXNzIFRhaWxvcmluZyBGcmFtZXdvcmtcbiAqIEhhbmRsZXMgbmF2aWdhdGlvbiwgZGF0YSBsb2FkaW5nLCBhbmQgdmlldyBtYW5hZ2VtZW50XG4gKi9cblxuLy8gSW1wb3J0IGNvbXBvbmVudCBtb2R1bGVzXG5pbXBvcnQgJy4vY29tcG9uZW50cy9hc3Nlc3NtZW50LmpzJztcbmltcG9ydCAnLi9jb21wb25lbnRzL3Zpc3VhbGl6YXRpb24uanMnO1xuaW1wb3J0ICcuL2NvbXBvbmVudHMvcmVjb21tZW5kYXRpb25zLmpzJztcbmltcG9ydCAnLi9jb21wb25lbnRzL2V4cG9ydC5qcyc7XG5cbmNsYXNzIFNFRnJhbWV3b3JrQXBwIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jdXJyZW50VmlldyA9IFwid2VsY29tZVwiO1xuICAgIHRoaXMuYXNzZXNzbWVudERhdGEgPSB7fTtcbiAgICB0aGlzLnByb2Nlc3NEYXRhID0ge307XG4gICAgdGhpcy5xdWVzdGlvbkRhdGEgPSB7fTtcbiAgICB0aGlzLmRlcGVuZGVuY3lEYXRhID0ge307XG4gICAgdGhpcy5yZWNvbW1lbmRhdGlvbnMgPSB7fTtcbiAgICB0aGlzLmFzc2Vzc21lbnRFbmdpbmUgPSBudWxsO1xuICAgIHRoaXMudmlzdWFsaXplciA9IG51bGw7XG4gICAgdGhpcy5yZWNvbW1lbmRhdGlvbkVuZ2luZSA9IG51bGw7XG4gICAgdGhpcy5leHBvcnRNYW5hZ2VyID0gbnVsbDtcblxuICAgIC8vIEFzc2Vzc21lbnQgc3RhdGVcbiAgICB0aGlzLmFzc2Vzc21lbnRSZXNwb25zZXMgPSB7fTtcbiAgICB0aGlzLmFzc2Vzc21lbnRTY29yZXMgPSB7XG4gICAgICBjb21wbGV4aXR5OiAwLFxuICAgICAgc2FmZXR5OiAwLFxuICAgICAgc2NhbGU6IDAsXG4gICAgICBtYXR1cml0eTogMCxcbiAgICAgIG92ZXJhbGw6IDAsXG4gICAgfTtcblxuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgYXN5bmMgaW5pdCgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coXCI9PT0gU0UgRnJhbWV3b3JrIEFwcCBJbml0aWFsaXphdGlvbiBTdGFydGVkID09PVwiKTtcbiAgICAgIHRoaXMuc2hvd0xvYWRpbmcoKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgcmVxdWlyZWQgY29tcG9uZW50cyBhcmUgbG9hZGVkXG4gICAgICBjb25zb2xlLmxvZyhcIlN0ZXAgMTogQ2hlY2tpbmcgY29tcG9uZW50IGF2YWlsYWJpbGl0eTpcIiwge1xuICAgICAgICBBc3Nlc3NtZW50RW5naW5lOiB0eXBlb2YgQXNzZXNzbWVudEVuZ2luZSxcbiAgICAgICAgUHJvY2Vzc05ldHdvcmtWaXN1YWxpemVyOiB0eXBlb2YgUHJvY2Vzc05ldHdvcmtWaXN1YWxpemVyLFxuICAgICAgICBSZWNvbW1lbmRhdGlvbkVuZ2luZTogdHlwZW9mIFJlY29tbWVuZGF0aW9uRW5naW5lLFxuICAgICAgICBFeHBvcnRNYW5hZ2VyOiB0eXBlb2YgRXhwb3J0TWFuYWdlcixcbiAgICAgIH0pO1xuXG4gICAgICBjb25zb2xlLmxvZyhcIlN0ZXAgMjogTG9hZGluZyBkYXRhLi4uXCIpO1xuICAgICAgYXdhaXQgdGhpcy5sb2FkRGF0YSgpO1xuICAgICAgY29uc29sZS5sb2coXCJTdGVwIDM6IERhdGEgbG9hZGVkIHN1Y2Nlc3NmdWxseVwiKTtcblxuICAgICAgY29uc29sZS5sb2coXCJTdGVwIDQ6IFNldHRpbmcgdXAgZXZlbnQgbGlzdGVuZXJzLi4uXCIpO1xuICAgICAgdGhpcy5zZXR1cEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICBjb25zb2xlLmxvZyhcIlN0ZXAgNTogRXZlbnQgbGlzdGVuZXJzIHNldHVwIGNvbXBsZXRlXCIpO1xuXG4gICAgICBjb25zb2xlLmxvZyhcIlN0ZXAgNjogUmVuZGVyaW5nIHdlbGNvbWUgdmlldy4uLlwiKTtcbiAgICAgIHRoaXMucmVuZGVyV2VsY29tZVZpZXcoKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiU3RlcCA3OiBXZWxjb21lIHZpZXcgcmVuZGVyZWRcIik7XG5cbiAgICAgIGNvbnNvbGUubG9nKFwiU3RlcCA4OiBBYm91dCB0byBoaWRlIGxvYWRpbmcgb3ZlcmxheS4uLlwiKTtcbiAgICAgIHRoaXMuaGlkZUxvYWRpbmcoKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiU3RlcCA5OiBMb2FkaW5nIG92ZXJsYXkgaGlkZGVuXCIpO1xuXG4gICAgICBjb25zb2xlLmxvZyhcIj09PSBBcHAgSW5pdGlhbGl6ZWQgU3VjY2Vzc2Z1bGx5ID09PVwiKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIj09PSBBcHAgSW5pdGlhbGl6YXRpb24gRmFpbGVkID09PVwiLCBlcnJvcik7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZGV0YWlsczpcIiwgZXJyb3Iuc3RhY2spO1xuICAgICAgdGhpcy5zaG93RXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gbG9hZCBhcHBsaWNhdGlvbiBkYXRhOiAke2Vycm9yLm1lc3NhZ2V9LiBQbGVhc2UgcmVmcmVzaCB0aGUgcGFnZS5gLFxuICAgICAgKTtcbiAgICAgIHRoaXMuaGlkZUxvYWRpbmcoKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBsb2FkRGF0YSgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coXCJTdGFydGluZyBkYXRhIGxvYWRpbmcuLi5cIik7XG5cbiAgICAgIC8vIExvYWQgZGF0YSBmaWxlcyBzZXF1ZW50aWFsbHkgZm9yIGJldHRlciBlcnJvciBoYW5kbGluZ1xuICAgICAgY29uc3QgcHJvY2Vzc2VzUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcImRhdGEvcHJvY2Vzc2VzLmpzb25cIik7XG4gICAgICBjb25zb2xlLmxvZyhcIlByb2Nlc3NlcyByZXNwb25zZSBzdGF0dXM6XCIsIHByb2Nlc3Nlc1Jlc3BvbnNlLnN0YXR1cyk7XG4gICAgICBpZiAoIXByb2Nlc3Nlc1Jlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBsb2FkIHByb2Nlc3NlcyBkYXRhXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJvY2Vzc2VzID0gYXdhaXQgcHJvY2Vzc2VzUmVzcG9uc2UuanNvbigpO1xuXG4gICAgICBjb25zdCBxdWVzdGlvbnNSZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiZGF0YS9xdWVzdGlvbnMuanNvblwiKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiUXVlc3Rpb25zIHJlc3BvbnNlIHN0YXR1czpcIiwgcXVlc3Rpb25zUmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIGlmICghcXVlc3Rpb25zUmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGxvYWQgcXVlc3Rpb25zIGRhdGFcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBxdWVzdGlvbnMgPSBhd2FpdCBxdWVzdGlvbnNSZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIGNvbnN0IGRlcGVuZGVuY2llc1Jlc3BvbnNlID0gYXdhaXQgZmV0Y2goXCJkYXRhL2RlcGVuZGVuY2llcy5qc29uXCIpO1xuICAgICAgY29uc29sZS5sb2coXCJEZXBlbmRlbmNpZXMgcmVzcG9uc2Ugc3RhdHVzOlwiLCBkZXBlbmRlbmNpZXNSZXNwb25zZS5zdGF0dXMpO1xuICAgICAgaWYgKCFkZXBlbmRlbmNpZXNSZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gbG9hZCBkZXBlbmRlbmNpZXMgZGF0YVwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IGF3YWl0IGRlcGVuZGVuY2llc1Jlc3BvbnNlLmpzb24oKTtcblxuICAgICAgY29uc29sZS5sb2coXCJEYXRhIGxvYWRlZCBzdWNjZXNzZnVsbHk6XCIsIHtcbiAgICAgICAgcHJvY2Vzc2VzOiBwcm9jZXNzZXMucHJvY2Vzc2VzID8gcHJvY2Vzc2VzLnByb2Nlc3Nlcy5sZW5ndGggOiAwLFxuICAgICAgICBxdWVzdGlvbnM6IHF1ZXN0aW9ucy5hc3Nlc3NtZW50Q2F0ZWdvcmllc1xuICAgICAgICAgID8gcXVlc3Rpb25zLmFzc2Vzc21lbnRDYXRlZ29yaWVzLmxlbmd0aFxuICAgICAgICAgIDogMCxcbiAgICAgICAgZGVwZW5kZW5jaWVzOiBkZXBlbmRlbmNpZXMuZGVwZW5kZW5jaWVzXG4gICAgICAgICAgPyBkZXBlbmRlbmNpZXMuZGVwZW5kZW5jaWVzLmxlbmd0aFxuICAgICAgICAgIDogMCxcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnByb2Nlc3NEYXRhID0gcHJvY2Vzc2VzO1xuICAgICAgdGhpcy5xdWVzdGlvbkRhdGEgPSBxdWVzdGlvbnM7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lEYXRhID0gZGVwZW5kZW5jaWVzO1xuXG4gICAgICBjb25zb2xlLmxvZyhcIlN0ZXAgMi41OiBDaGVja2luZyBjb21wb25lbnQgY2xhc3Nlcy4uLlwiKTtcbiAgICAgIC8vIENoZWNrIGlmIGNvbXBvbmVudCBjbGFzc2VzIGFyZSBhdmFpbGFibGVcbiAgICAgIGNvbnN0IGNvbXBvbmVudENoZWNrID0ge1xuICAgICAgICBBc3Nlc3NtZW50RW5naW5lOiB0eXBlb2YgQXNzZXNzbWVudEVuZ2luZSxcbiAgICAgICAgUHJvY2Vzc05ldHdvcmtWaXN1YWxpemVyOiB0eXBlb2YgUHJvY2Vzc05ldHdvcmtWaXN1YWxpemVyLFxuICAgICAgICBSZWNvbW1lbmRhdGlvbkVuZ2luZTogdHlwZW9mIFJlY29tbWVuZGF0aW9uRW5naW5lLFxuICAgICAgICBFeHBvcnRNYW5hZ2VyOiB0eXBlb2YgRXhwb3J0TWFuYWdlcixcbiAgICAgIH07XG4gICAgICBjb25zb2xlLmxvZyhcIkNvbXBvbmVudCBhdmFpbGFiaWxpdHk6XCIsIGNvbXBvbmVudENoZWNrKTtcblxuICAgICAgaWYgKHR5cGVvZiBBc3Nlc3NtZW50RW5naW5lID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFzc2Vzc21lbnRFbmdpbmUgY2xhc3Mgbm90IGxvYWRlZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgUHJvY2Vzc05ldHdvcmtWaXN1YWxpemVyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb2Nlc3NOZXR3b3JrVmlzdWFsaXplciBjbGFzcyBub3QgbG9hZGVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBSZWNvbW1lbmRhdGlvbkVuZ2luZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWNvbW1lbmRhdGlvbkVuZ2luZSBjbGFzcyBub3QgbG9hZGVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBFeHBvcnRNYW5hZ2VyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cG9ydE1hbmFnZXIgY2xhc3Mgbm90IGxvYWRlZFwiKTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coXCJTdGVwIDIuNjogSW5pdGlhbGl6aW5nIGNvbXBvbmVudHMuLi5cIik7XG4gICAgICAvLyBJbml0aWFsaXplIGNvbXBvbmVudHNcbiAgICAgIHRoaXMuYXNzZXNzbWVudEVuZ2luZSA9IG5ldyBBc3Nlc3NtZW50RW5naW5lKHRoaXMucXVlc3Rpb25EYXRhLCB0aGlzKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiQXNzZXNzbWVudEVuZ2luZSBjcmVhdGVkXCIpO1xuXG4gICAgICB0aGlzLnZpc3VhbGl6ZXIgPSBuZXcgUHJvY2Vzc05ldHdvcmtWaXN1YWxpemVyKFxuICAgICAgICB0aGlzLnByb2Nlc3NEYXRhLFxuICAgICAgICB0aGlzLmRlcGVuZGVuY3lEYXRhLFxuICAgICAgICB0aGlzLFxuICAgICAgKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiUHJvY2Vzc05ldHdvcmtWaXN1YWxpemVyIGNyZWF0ZWRcIik7XG5cbiAgICAgIHRoaXMucmVjb21tZW5kYXRpb25FbmdpbmUgPSBuZXcgUmVjb21tZW5kYXRpb25FbmdpbmUoXG4gICAgICAgIHRoaXMucHJvY2Vzc0RhdGEsXG4gICAgICAgIHRoaXMuZGVwZW5kZW5jeURhdGEsXG4gICAgICAgIHRoaXMsXG4gICAgICApO1xuICAgICAgY29uc29sZS5sb2coXCJSZWNvbW1lbmRhdGlvbkVuZ2luZSBjcmVhdGVkXCIpO1xuXG4gICAgICB0aGlzLmV4cG9ydE1hbmFnZXIgPSBuZXcgRXhwb3J0TWFuYWdlcih0aGlzKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiRXhwb3J0TWFuYWdlciBjcmVhdGVkXCIpO1xuXG4gICAgICBjb25zb2xlLmxvZyhcIlN0ZXAgMi43OiBBbGwgY29tcG9uZW50cyBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHlcIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIGRhdGE6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIHNldHVwRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIE5hdmlnYXRpb25cbiAgICAgIGNvbnN0IGJyYW5kTGluayA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYnJhbmQtbGlua1wiKTtcbiAgICAgIGlmIChicmFuZExpbmspIHtcbiAgICAgICAgYnJhbmRMaW5rLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4ge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLnNob3dWaWV3KFwid2VsY29tZVwiKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5hdldlbGNvbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm5hdi13ZWxjb21lXCIpO1xuICAgICAgaWYgKG5hdldlbGNvbWUpIHtcbiAgICAgICAgbmF2V2VsY29tZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGUpID0+IHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5zaG93VmlldyhcIndlbGNvbWVcIik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuYXZBc3Nlc3NtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJuYXYtYXNzZXNzbWVudFwiKTtcbiAgICAgIGlmIChuYXZBc3Nlc3NtZW50KSB7XG4gICAgICAgIG5hdkFzc2Vzc21lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PiB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuc2hvd1ZpZXcoXCJhc3Nlc3NtZW50XCIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmF2VmlzdWFsaXphdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibmF2LXZpc3VhbGl6YXRpb25cIik7XG4gICAgICBpZiAobmF2VmlzdWFsaXphdGlvbikge1xuICAgICAgICBuYXZWaXN1YWxpemF0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4ge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLnNob3dWaWV3KFwidmlzdWFsaXphdGlvblwiKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5hdlJlY29tbWVuZGF0aW9ucyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibmF2LXJlY29tbWVuZGF0aW9uc1wiKTtcbiAgICAgIGlmIChuYXZSZWNvbW1lbmRhdGlvbnMpIHtcbiAgICAgICAgbmF2UmVjb21tZW5kYXRpb25zLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4ge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLnNob3dWaWV3KFwicmVjb21tZW5kYXRpb25zXCIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmF2RXhwb3J0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJuYXYtZXhwb3J0XCIpO1xuICAgICAgaWYgKG5hdkV4cG9ydCkge1xuICAgICAgICBuYXZFeHBvcnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PiB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuc2hvd1ZpZXcoXCJleHBvcnRcIik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBTdGFydCBhc3Nlc3NtZW50IGJ1dHRvblxuICAgICAgY29uc3Qgc3RhcnRBc3Nlc3NtZW50QnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXG4gICAgICAgIFwic3RhcnQtYXNzZXNzbWVudC1idG5cIixcbiAgICAgICk7XG4gICAgICBpZiAoc3RhcnRBc3Nlc3NtZW50QnRuKSB7XG4gICAgICAgIHN0YXJ0QXNzZXNzbWVudEJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc2hvd1ZpZXcoXCJhc3Nlc3NtZW50XCIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHNldHRpbmcgdXAgZXZlbnQgbGlzdGVuZXJzOlwiLCBlcnJvcik7XG4gICAgfVxuXG4gICAgLy8gS2V5Ym9hcmQgbmF2aWdhdGlvblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIChlKSA9PiB7XG4gICAgICBpZiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSkge1xuICAgICAgICBzd2l0Y2ggKGUua2V5KSB7XG4gICAgICAgICAgY2FzZSBcIjFcIjpcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd1ZpZXcoXCJ3ZWxjb21lXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIjJcIjpcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd1ZpZXcoXCJhc3Nlc3NtZW50XCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIjNcIjpcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd1ZpZXcoXCJ2aXN1YWxpemF0aW9uXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIjRcIjpcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd1ZpZXcoXCJyZWNvbW1lbmRhdGlvbnNcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiNVwiOlxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5zaG93VmlldyhcImV4cG9ydFwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzaG93Vmlldyh2aWV3TmFtZSkge1xuICAgIGNvbnNvbGUubG9nKGA9PT0gc2hvd1ZpZXcgY2FsbGVkIHdpdGg6ICR7dmlld05hbWV9ID09PWApO1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhgU3RlcCAxOiBIaWRpbmcgYWxsIHZpZXdzLi4uYCk7XG4gICAgICAvLyBIaWRlIGFsbCB2aWV3c1xuICAgICAgY29uc3QgYWxsVmlld3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnZpZXctY29udGFpbmVyXCIpO1xuICAgICAgY29uc29sZS5sb2coYEZvdW5kICR7YWxsVmlld3MubGVuZ3RofSB2aWV3IGNvbnRhaW5lcnNgKTtcbiAgICAgIGFsbFZpZXdzLmZvckVhY2goKHZpZXcpID0+IHtcbiAgICAgICAgdmlldy5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICB9KTtcblxuICAgICAgY29uc29sZS5sb2coYFN0ZXAgMjogVXBkYXRpbmcgbmF2aWdhdGlvbi4uLmApO1xuICAgICAgLy8gVXBkYXRlIG5hdmlnYXRpb25cbiAgICAgIGNvbnN0IGFsbE5hdkxpbmtzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5uYXYtbGlua1wiKTtcbiAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke2FsbE5hdkxpbmtzLmxlbmd0aH0gbmF2IGxpbmtzYCk7XG4gICAgICBhbGxOYXZMaW5rcy5mb3JFYWNoKChsaW5rKSA9PiB7XG4gICAgICAgIGxpbmsuY2xhc3NMaXN0LnJlbW92ZShcImFjdGl2ZVwiKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zb2xlLmxvZyhgU3RlcCAzOiBTaG93aW5nIHRhcmdldCB2aWV3OiAke3ZpZXdOYW1lfS12aWV3YCk7XG4gICAgICAvLyBTaG93IHNlbGVjdGVkIHZpZXdcbiAgICAgIGNvbnN0IHRhcmdldFZpZXcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChgJHt2aWV3TmFtZX0tdmlld2ApO1xuICAgICAgY29uc29sZS5sb2coYFRhcmdldCB2aWV3IGVsZW1lbnQ6YCwgdGFyZ2V0Vmlldyk7XG5cbiAgICAgIGlmICh0YXJnZXRWaWV3KSB7XG4gICAgICAgIHRhcmdldFZpZXcuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgY29uc29sZS5sb2coYFN0ZXAgM2E6IFRhcmdldCB2aWV3IGRpc3BsYXllZGApO1xuXG4gICAgICAgIC8vIEFjdGl2YXRlIGNvcnJlc3BvbmRpbmcgbmF2IGxpbmtcbiAgICAgICAgY29uc3QgbmF2TGluayA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBuYXYtJHt2aWV3TmFtZX1gKTtcbiAgICAgICAgY29uc29sZS5sb2coYE5hdiBsaW5rIGVsZW1lbnQ6YCwgbmF2TGluayk7XG4gICAgICAgIGlmIChuYXZMaW5rKSB7XG4gICAgICAgICAgbmF2TGluay5jbGFzc0xpc3QuYWRkKFwiYWN0aXZlXCIpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBTdGVwIDNiOiBOYXYgbGluayBhY3RpdmF0ZWRgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3VycmVudFZpZXcgPSB2aWV3TmFtZTtcbiAgICAgICAgY29uc29sZS5sb2coYFN0ZXAgM2M6IEN1cnJlbnQgdmlldyBzZXQgdG8gJHt2aWV3TmFtZX1gKTtcblxuICAgICAgICBjb25zb2xlLmxvZyhgU3RlcCA0OiBJbml0aWFsaXppbmcgdmlldy1zcGVjaWZpYyBjb250ZW50Li4uYCk7XG4gICAgICAgIC8vIEluaXRpYWxpemUgdmlldy1zcGVjaWZpYyBjb250ZW50XG4gICAgICAgIHN3aXRjaCAodmlld05hbWUpIHtcbiAgICAgICAgICBjYXNlIFwiYXNzZXNzbWVudFwiOlxuICAgICAgICAgICAgdGhpcy5yZW5kZXJBc3Nlc3NtZW50VmlldygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInZpc3VhbGl6YXRpb25cIjpcbiAgICAgICAgICAgIHRoaXMucmVuZGVyVmlzdWFsaXphdGlvblZpZXcoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJyZWNvbW1lbmRhdGlvbnNcIjpcbiAgICAgICAgICAgIHRoaXMucmVuZGVyUmVjb21tZW5kYXRpb25zVmlldygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImV4cG9ydFwiOlxuICAgICAgICAgICAgdGhpcy5yZW5kZXJFeHBvcnRWaWV3KCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhgU3RlcCA0YTogVmlldy1zcGVjaWZpYyBjb250ZW50IGluaXRpYWxpemVkYCk7XG5cbiAgICAgICAgY29uc29sZS5sb2coYFN0ZXAgNTogVXBkYXRpbmcgcHJvZ3Jlc3MgaW5kaWNhdG9yLi4uYCk7XG4gICAgICAgIC8vIFVwZGF0ZSBwcm9ncmVzcyBpbmRpY2F0b3JcbiAgICAgICAgdGhpcy51cGRhdGVQcm9ncmVzc0luZGljYXRvcigpO1xuICAgICAgICBjb25zb2xlLmxvZyhgU3RlcCA1YTogUHJvZ3Jlc3MgaW5kaWNhdG9yIHVwZGF0ZWRgKTtcblxuICAgICAgICAvLyBTY3JvbGwgdG8gdG9wXG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICAgICAgY29uc29sZS5sb2coYFN0ZXAgNjogU2Nyb2xsZWQgdG8gdG9wYCk7XG5cbiAgICAgICAgY29uc29sZS5sb2coYD09PSBWaWV3ICR7dmlld05hbWV9IHNob3duIHN1Y2Nlc3NmdWxseSA9PT1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFZpZXcgJHt2aWV3TmFtZX0gbm90IGZvdW5kYCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgYEF2YWlsYWJsZSB2aWV3czpgLFxuICAgICAgICAgIEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2lkJD1cIi12aWV3XCJdJykpLm1hcChcbiAgICAgICAgICAgIChlbCkgPT4gZWwuaWQsXG4gICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igc2hvd2luZyB2aWV3ICR7dmlld05hbWV9OmAsIGVycm9yKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHN0YWNrOmAsIGVycm9yLnN0YWNrKTtcbiAgICB9XG4gIH1cblxuICByZW5kZXJXZWxjb21lVmlldygpIHtcbiAgICBjb25zb2xlLmxvZyhcIlJlbmRlcmluZyB3ZWxjb21lIHZpZXcuLi5cIik7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFdlbGNvbWUgdmlldyBpcyBzdGF0aWMgSFRNTCwganVzdCBlbnN1cmUgaXQncyB2aXNpYmxlXG4gICAgICB0aGlzLnNob3dWaWV3KFwid2VsY29tZVwiKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiV2VsY29tZSB2aWV3IHJlbmRlcmVkIHN1Y2Nlc3NmdWxseVwiKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHJlbmRlcmluZyB3ZWxjb21lIHZpZXc6XCIsIGVycm9yKTtcbiAgICAgIC8vIEZhbGxiYWNrOiBtYW51YWxseSBzaG93IHdlbGNvbWUgdmlld1xuICAgICAgY29uc3Qgd2VsY29tZVZpZXcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIndlbGNvbWUtdmlld1wiKTtcbiAgICAgIGlmICh3ZWxjb21lVmlldykge1xuICAgICAgICB3ZWxjb21lVmlldy5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJlbmRlckFzc2Vzc21lbnRWaWV3KCkge1xuICAgIGlmICh0aGlzLmFzc2Vzc21lbnRFbmdpbmUpIHtcbiAgICAgIHRoaXMuYXNzZXNzbWVudEVuZ2luZS5yZW5kZXIoKTtcbiAgICAgIHRoaXMuc2hvd1Byb2dyZXNzSW5kaWNhdG9yKCk7XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyVmlzdWFsaXphdGlvblZpZXcoKSB7XG4gICAgaWYgKHRoaXMudmlzdWFsaXplcikge1xuICAgICAgLy8gU21hbGwgZGVsYXkgdG8gZW5zdXJlIGNvbnRhaW5lciBpcyB2aXNpYmxlIGJlZm9yZSByZW5kZXJpbmdcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnZpc3VhbGl6ZXIucmVuZGVyKCk7XG4gICAgICB9LCAxMDApO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlclJlY29tbWVuZGF0aW9uc1ZpZXcoKSB7XG4gICAgaWYgKHRoaXMucmVjb21tZW5kYXRpb25FbmdpbmUpIHtcbiAgICAgIHRoaXMucmVjb21tZW5kYXRpb25FbmdpbmUucmVuZGVyKCk7XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyRXhwb3J0VmlldygpIHtcbiAgICBpZiAodGhpcy5leHBvcnRNYW5hZ2VyKSB7XG4gICAgICB0aGlzLmV4cG9ydE1hbmFnZXIucmVuZGVyKCk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlUHJvZ3Jlc3NJbmRpY2F0b3IoKSB7XG4gICAgY29uc3QgcHJvZ3Jlc3NDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInByb2dyZXNzLWNvbnRhaW5lclwiKTtcbiAgICBjb25zdCBwcm9ncmVzc0JhciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwib3ZlcmFsbC1wcm9ncmVzc1wiKTtcbiAgICBjb25zdCBwcm9ncmVzc1RleHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInByb2dyZXNzLXRleHRcIik7XG5cbiAgICBpZiAodGhpcy5jdXJyZW50VmlldyA9PT0gXCJ3ZWxjb21lXCIpIHtcbiAgICAgIHByb2dyZXNzQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgb3ZlcmFsbCBwcm9ncmVzc1xuICAgIGxldCBwcm9ncmVzcyA9IDA7XG4gICAgc3dpdGNoICh0aGlzLmN1cnJlbnRWaWV3KSB7XG4gICAgICBjYXNlIFwiYXNzZXNzbWVudFwiOlxuICAgICAgICBwcm9ncmVzcyA9IHRoaXMuZ2V0QXNzZXNzbWVudFByb2dyZXNzKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInZpc3VhbGl6YXRpb25cIjpcbiAgICAgICAgcHJvZ3Jlc3MgPSB0aGlzLmhhc0NvbXBsZXRlZEFzc2Vzc21lbnQoKSA/IDc1IDogMjU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJlY29tbWVuZGF0aW9uc1wiOlxuICAgICAgICBwcm9ncmVzcyA9IHRoaXMuaGFzQ29tcGxldGVkQXNzZXNzbWVudCgpID8gOTAgOiA1MDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZXhwb3J0XCI6XG4gICAgICAgIHByb2dyZXNzID0gMTAwO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBwcm9ncmVzc0NvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIHByb2dyZXNzQmFyLnN0eWxlLndpZHRoID0gYCR7cHJvZ3Jlc3N9JWA7XG4gICAgcHJvZ3Jlc3NUZXh0LnRleHRDb250ZW50ID0gYCR7TWF0aC5yb3VuZChwcm9ncmVzcyl9JWA7XG4gIH1cblxuICBzaG93UHJvZ3Jlc3NJbmRpY2F0b3IoKSB7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwcm9ncmVzcy1jb250YWluZXJcIikuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgfVxuXG4gIGhpZGVQcm9ncmVzc0luZGljYXRvcigpIHtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInByb2dyZXNzLWNvbnRhaW5lclwiKS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gIH1cblxuICBnZXRBc3Nlc3NtZW50UHJvZ3Jlc3MoKSB7XG4gICAgaWYgKCF0aGlzLmFzc2Vzc21lbnRFbmdpbmUpIHJldHVybiAwO1xuXG4gICAgY29uc3QgdG90YWxRdWVzdGlvbnMgPSB0aGlzLmdldFRvdGFsUXVlc3Rpb25zKCk7XG4gICAgY29uc3QgYW5zd2VyZWRRdWVzdGlvbnMgPSBPYmplY3Qua2V5cyh0aGlzLmFzc2Vzc21lbnRSZXNwb25zZXMpLmxlbmd0aDtcblxuICAgIHJldHVybiB0b3RhbFF1ZXN0aW9ucyA+IDBcbiAgICAgID8gTWF0aC5taW4oKGFuc3dlcmVkUXVlc3Rpb25zIC8gdG90YWxRdWVzdGlvbnMpICogNjAsIDYwKVxuICAgICAgOiAwO1xuICB9XG5cbiAgZ2V0VG90YWxRdWVzdGlvbnMoKSB7XG4gICAgaWYgKCF0aGlzLnF1ZXN0aW9uRGF0YS5hc3Nlc3NtZW50Q2F0ZWdvcmllcykgcmV0dXJuIDA7XG5cbiAgICByZXR1cm4gdGhpcy5xdWVzdGlvbkRhdGEuYXNzZXNzbWVudENhdGVnb3JpZXMucmVkdWNlKCh0b3RhbCwgY2F0ZWdvcnkpID0+IHtcbiAgICAgIHJldHVybiB0b3RhbCArIChjYXRlZ29yeS5xdWVzdGlvbnMgPyBjYXRlZ29yeS5xdWVzdGlvbnMubGVuZ3RoIDogMCk7XG4gICAgfSwgMCk7XG4gIH1cblxuICBoYXNDb21wbGV0ZWRBc3Nlc3NtZW50KCkge1xuICAgIGNvbnN0IHRvdGFsUXVlc3Rpb25zID0gdGhpcy5nZXRUb3RhbFF1ZXN0aW9ucygpO1xuICAgIGNvbnN0IGFuc3dlcmVkUXVlc3Rpb25zID0gT2JqZWN0LmtleXModGhpcy5hc3Nlc3NtZW50UmVzcG9uc2VzKS5sZW5ndGg7XG4gICAgcmV0dXJuIGFuc3dlcmVkUXVlc3Rpb25zID49IHRvdGFsUXVlc3Rpb25zICYmIHRvdGFsUXVlc3Rpb25zID4gMDtcbiAgfVxuXG4gIHVwZGF0ZUFzc2Vzc21lbnRSZXNwb25zZShxdWVzdGlvbklkLCByZXNwb25zZSkge1xuICAgIHRoaXMuYXNzZXNzbWVudFJlc3BvbnNlc1txdWVzdGlvbklkXSA9IHJlc3BvbnNlO1xuICAgIHRoaXMuY2FsY3VsYXRlU2NvcmVzKCk7XG4gICAgdGhpcy51cGRhdGVQcm9ncmVzc0luZGljYXRvcigpO1xuXG4gICAgLy8gQXV0by1zYXZlIHRvIGxvY2FsU3RvcmFnZVxuICAgIHRoaXMuc2F2ZUFzc2Vzc21lbnRTdGF0ZSgpO1xuICB9XG5cbiAgY2FsY3VsYXRlU2NvcmVzKCkge1xuICAgIGlmICghdGhpcy5xdWVzdGlvbkRhdGEuYXNzZXNzbWVudENhdGVnb3JpZXMpIHJldHVybjtcblxuICAgIGNvbnN0IGRpbWVuc2lvblNjb3JlcyA9IHtcbiAgICAgIGNvbXBsZXhpdHk6IFtdLFxuICAgICAgc2FmZXR5OiBbXSxcbiAgICAgIHNjYWxlOiBbXSxcbiAgICAgIG1hdHVyaXR5OiBbXSxcbiAgICB9O1xuXG4gICAgLy8gQ2FsY3VsYXRlIGRpbWVuc2lvbiBzY29yZXMgYmFzZWQgb24gcmVzcG9uc2VzXG4gICAgdGhpcy5xdWVzdGlvbkRhdGEuYXNzZXNzbWVudENhdGVnb3JpZXMuZm9yRWFjaCgoY2F0ZWdvcnkpID0+IHtcbiAgICAgIGNhdGVnb3J5LnF1ZXN0aW9ucy5mb3JFYWNoKChxdWVzdGlvbikgPT4ge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IHRoaXMuYXNzZXNzbWVudFJlc3BvbnNlc1txdWVzdGlvbi5pZF07XG4gICAgICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS5zY29yZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29uc3QgZGltZW5zaW9uID0gcXVlc3Rpb24uZGltZW5zaW9uO1xuICAgICAgICAgIGlmIChkaW1lbnNpb25TY29yZXNbZGltZW5zaW9uXSkge1xuICAgICAgICAgICAgZGltZW5zaW9uU2NvcmVzW2RpbWVuc2lvbl0ucHVzaCh7XG4gICAgICAgICAgICAgIHNjb3JlOiByZXNwb25zZS5zY29yZSxcbiAgICAgICAgICAgICAgd2VpZ2h0OiBxdWVzdGlvbi53ZWlnaHQgfHwgMSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBDYWxjdWxhdGUgd2VpZ2h0ZWQgYXZlcmFnZXMgZm9yIGVhY2ggZGltZW5zaW9uXG4gICAgT2JqZWN0LmtleXMoZGltZW5zaW9uU2NvcmVzKS5mb3JFYWNoKChkaW1lbnNpb24pID0+IHtcbiAgICAgIGNvbnN0IHNjb3JlcyA9IGRpbWVuc2lvblNjb3Jlc1tkaW1lbnNpb25dO1xuICAgICAgaWYgKHNjb3Jlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHdlaWdodGVkU3VtID0gc2NvcmVzLnJlZHVjZShcbiAgICAgICAgICAoc3VtLCBpdGVtKSA9PiBzdW0gKyBpdGVtLnNjb3JlICogaXRlbS53ZWlnaHQsXG4gICAgICAgICAgMCxcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgdG90YWxXZWlnaHQgPSBzY29yZXMucmVkdWNlKChzdW0sIGl0ZW0pID0+IHN1bSArIGl0ZW0ud2VpZ2h0LCAwKTtcbiAgICAgICAgdGhpcy5hc3Nlc3NtZW50U2NvcmVzW2RpbWVuc2lvbl0gPVxuICAgICAgICAgIHRvdGFsV2VpZ2h0ID4gMCA/IHdlaWdodGVkU3VtIC8gdG90YWxXZWlnaHQgOiAwO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ2FsY3VsYXRlIG92ZXJhbGwgc2NvcmUgKHdlaWdodGVkIGF2ZXJhZ2Ugb2YgZGltZW5zaW9ucylcbiAgICBjb25zdCBkaW1lbnNpb25XZWlnaHRzID0ge1xuICAgICAgY29tcGxleGl0eTogMC4zLFxuICAgICAgc2FmZXR5OiAwLjI1LFxuICAgICAgc2NhbGU6IDAuMjUsXG4gICAgICBtYXR1cml0eTogMC4yLFxuICAgIH07XG5cbiAgICBsZXQgb3ZlcmFsbFNjb3JlID0gMDtcbiAgICBsZXQgdG90YWxXZWlnaHQgPSAwO1xuXG4gICAgT2JqZWN0LmtleXMoZGltZW5zaW9uV2VpZ2h0cykuZm9yRWFjaCgoZGltZW5zaW9uKSA9PiB7XG4gICAgICBpZiAodGhpcy5hc3Nlc3NtZW50U2NvcmVzW2RpbWVuc2lvbl0gPiAwKSB7XG4gICAgICAgIG92ZXJhbGxTY29yZSArPVxuICAgICAgICAgIHRoaXMuYXNzZXNzbWVudFNjb3Jlc1tkaW1lbnNpb25dICogZGltZW5zaW9uV2VpZ2h0c1tkaW1lbnNpb25dO1xuICAgICAgICB0b3RhbFdlaWdodCArPSBkaW1lbnNpb25XZWlnaHRzW2RpbWVuc2lvbl07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmFzc2Vzc21lbnRTY29yZXMub3ZlcmFsbCA9XG4gICAgICB0b3RhbFdlaWdodCA+IDAgPyBvdmVyYWxsU2NvcmUgLyB0b3RhbFdlaWdodCA6IDA7XG5cbiAgICAvLyBHZW5lcmF0ZSByZWNvbW1lbmRhdGlvbnMgaWYgYXNzZXNzbWVudCBpcyBjb21wbGV0ZVxuICAgIGlmICh0aGlzLmhhc0NvbXBsZXRlZEFzc2Vzc21lbnQoKSAmJiB0aGlzLnJlY29tbWVuZGF0aW9uRW5naW5lKSB7XG4gICAgICB0aGlzLnJlY29tbWVuZGF0aW9ucyA9IHRoaXMucmVjb21tZW5kYXRpb25FbmdpbmUuZ2VuZXJhdGVSZWNvbW1lbmRhdGlvbnMoXG4gICAgICAgIHRoaXMuYXNzZXNzbWVudFNjb3JlcyxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgc2F2ZUFzc2Vzc21lbnRTdGF0ZSgpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgIHJlc3BvbnNlczogdGhpcy5hc3Nlc3NtZW50UmVzcG9uc2VzLFxuICAgICAgc2NvcmVzOiB0aGlzLmFzc2Vzc21lbnRTY29yZXMsXG4gICAgICByZWNvbW1lbmRhdGlvbnM6IHRoaXMucmVjb21tZW5kYXRpb25zLFxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgIH07XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJzZS10YWlsb3JpbmctYXNzZXNzbWVudFwiLCBKU09OLnN0cmluZ2lmeShzdGF0ZSkpO1xuICB9XG5cbiAgbG9hZEFzc2Vzc21lbnRTdGF0ZSgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2F2ZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInNlLXRhaWxvcmluZy1hc3Nlc3NtZW50XCIpO1xuICAgICAgaWYgKHNhdmVkKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gSlNPTi5wYXJzZShzYXZlZCk7XG5cbiAgICAgICAgLy8gT25seSBsb2FkIGlmIHNhdmVkIHdpdGhpbiBsYXN0IDI0IGhvdXJzXG4gICAgICAgIGNvbnN0IGRheU9sZCA9IDI0ICogNjAgKiA2MCAqIDEwMDA7XG4gICAgICAgIGlmIChEYXRlLm5vdygpIC0gc3RhdGUudGltZXN0YW1wIDwgZGF5T2xkKSB7XG4gICAgICAgICAgdGhpcy5hc3Nlc3NtZW50UmVzcG9uc2VzID0gc3RhdGUucmVzcG9uc2VzIHx8IHt9O1xuICAgICAgICAgIHRoaXMuYXNzZXNzbWVudFNjb3JlcyA9IHN0YXRlLnNjb3JlcyB8fCB7fTtcbiAgICAgICAgICB0aGlzLnJlY29tbWVuZGF0aW9ucyA9IHN0YXRlLnJlY29tbWVuZGF0aW9ucyB8fCB7fTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBGYWlsZWQgdG8gbG9hZCBzYXZlZCBhc3Nlc3NtZW50IHN0YXRlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNsZWFyQXNzZXNzbWVudFN0YXRlKCkge1xuICAgIHRoaXMuYXNzZXNzbWVudFJlc3BvbnNlcyA9IHt9O1xuICAgIHRoaXMuYXNzZXNzbWVudFNjb3JlcyA9IHtcbiAgICAgIGNvbXBsZXhpdHk6IDAsXG4gICAgICBzYWZldHk6IDAsXG4gICAgICBzY2FsZTogMCxcbiAgICAgIG1hdHVyaXR5OiAwLFxuICAgICAgb3ZlcmFsbDogMCxcbiAgICB9O1xuICAgIHRoaXMucmVjb21tZW5kYXRpb25zID0ge307XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oXCJzZS10YWlsb3JpbmctYXNzZXNzbWVudFwiKTtcbiAgICB0aGlzLnVwZGF0ZVByb2dyZXNzSW5kaWNhdG9yKCk7XG4gIH1cblxuICBzaG93TG9hZGluZygpIHtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxvYWRpbmctb3ZlcmxheVwiKS5zdHlsZS5kaXNwbGF5ID0gXCJmbGV4XCI7XG4gIH1cblxuICBoaWRlTG9hZGluZygpIHtcbiAgICBjb25zb2xlLmxvZyhcIj09PSBIaWRpbmcgbG9hZGluZyBvdmVybGF5ID09PVwiKTtcbiAgICBjb25zdCBsb2FkaW5nT3ZlcmxheSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibG9hZGluZy1vdmVybGF5XCIpO1xuICAgIGNvbnNvbGUubG9nKFwiTG9hZGluZyBvdmVybGF5IGVsZW1lbnQ6XCIsIGxvYWRpbmdPdmVybGF5KTtcblxuICAgIGlmIChsb2FkaW5nT3ZlcmxheSkge1xuICAgICAgY29uc29sZS5sb2coXCJDdXJyZW50IGRpc3BsYXkgc3R5bGU6XCIsIGxvYWRpbmdPdmVybGF5LnN0eWxlLmRpc3BsYXkpO1xuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIFwiQ3VycmVudCBjb21wdXRlZCBzdHlsZTpcIixcbiAgICAgICAgd2luZG93LmdldENvbXB1dGVkU3R5bGUobG9hZGluZ092ZXJsYXkpLmRpc3BsYXksXG4gICAgICApO1xuXG4gICAgICAvLyBUcnkgbXVsdGlwbGUgYXBwcm9hY2hlcyB0byBoaWRlIGl0XG4gICAgICBsb2FkaW5nT3ZlcmxheS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICBsb2FkaW5nT3ZlcmxheS5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgIGxvYWRpbmdPdmVybGF5LnN0eWxlLm9wYWNpdHkgPSBcIjBcIjtcbiAgICAgIGxvYWRpbmdPdmVybGF5LnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcblxuICAgICAgLy8gQWxzbyBhZGQgYSBjbGFzcyB0byBlbnN1cmUgaXQgc3RheXMgaGlkZGVuXG4gICAgICBsb2FkaW5nT3ZlcmxheS5jbGFzc0xpc3QuYWRkKFwiaGlkZGVuXCIpO1xuXG4gICAgICBjb25zb2xlLmxvZyhcIkxvYWRpbmcgb3ZlcmxheSBoaWRkZW4gd2l0aCBtdWx0aXBsZSBtZXRob2RzXCIpO1xuICAgICAgY29uc29sZS5sb2coXCJOZXcgZGlzcGxheSBzdHlsZTpcIiwgbG9hZGluZ092ZXJsYXkuc3R5bGUuZGlzcGxheSk7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgXCJOZXcgY29tcHV0ZWQgc3R5bGU6XCIsXG4gICAgICAgIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGxvYWRpbmdPdmVybGF5KS5kaXNwbGF5LFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFwiTG9hZGluZyBvdmVybGF5IGVsZW1lbnQgbm90IGZvdW5kXCIpO1xuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIFwiQXZhaWxhYmxlIGVsZW1lbnRzIHdpdGggbG9hZGluZyBpbiBJRDpcIixcbiAgICAgICAgQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbaWQqPVwibG9hZGluZ1wiXScpKS5tYXAoXG4gICAgICAgICAgKGVsKSA9PiBlbC5pZCxcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKFwiPT09IExvYWRpbmcgb3ZlcmxheSBoaWRlIGF0dGVtcHQgY29tcGxldGUgPT09XCIpO1xuICB9XG5cbiAgc2hvd0Vycm9yKG1lc3NhZ2UpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiU2hvd2luZyBlcnJvcjpcIiwgbWVzc2FnZSk7XG5cbiAgICAvLyBDcmVhdGUgYW5kIHNob3cgZXJyb3IgYWxlcnRcbiAgICBjb25zdCBhbGVydEh0bWwgPSBgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYWxlcnQgYWxlcnQtZGFuZ2VyIGFsZXJ0LWRpc21pc3NpYmxlIGZhZGUgc2hvd1wiIHJvbGU9XCJhbGVydFwiPlxuICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiYmkgYmktZXhjbGFtYXRpb24tdHJpYW5nbGUtZmlsbCBtZS0yXCI+PC9pPlxuICAgICAgICAgICAgICAgIDxzdHJvbmc+RXJyb3I6PC9zdHJvbmc+ICR7bWVzc2FnZX1cbiAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0bi1jbG9zZVwiIGRhdGEtYnMtZGlzbWlzcz1cImFsZXJ0XCI+PC9idXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgYDtcblxuICAgIC8vIEluc2VydCBhdCB0b3Agb2YgbWFpbiBjb250ZW50XG4gICAgY29uc3QgbWFpbkNvbnRlbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm1haW4tY29udGVudFwiKTtcbiAgICBpZiAobWFpbkNvbnRlbnQpIHtcbiAgICAgIG1haW5Db250ZW50Lmluc2VydEFkamFjZW50SFRNTChcImFmdGVyYmVnaW5cIiwgYWxlcnRIdG1sKTtcblxuICAgICAgLy8gQXV0by1yZW1vdmUgYWZ0ZXIgMTAgc2Vjb25kc1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGFsZXJ0ID0gbWFpbkNvbnRlbnQucXVlcnlTZWxlY3RvcihcIi5hbGVydC1kYW5nZXJcIik7XG4gICAgICAgIGlmIChhbGVydCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBic0FsZXJ0ID0gbmV3IGJvb3RzdHJhcC5BbGVydChhbGVydCk7XG4gICAgICAgICAgICBic0FsZXJ0LmNsb3NlKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gRmFsbGJhY2s6IGp1c3QgcmVtb3ZlIHRoZSBlbGVtZW50XG4gICAgICAgICAgICBhbGVydC5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIDEwMDAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihcIk1haW4gY29udGVudCBlbGVtZW50IG5vdCBmb3VuZCBmb3IgZXJyb3IgZGlzcGxheVwiKTtcbiAgICB9XG4gIH1cblxuICBzaG93U3VjY2VzcyhtZXNzYWdlKSB7XG4gICAgLy8gQ3JlYXRlIGFuZCBzaG93IHN1Y2Nlc3MgYWxlcnRcbiAgICBjb25zdCBhbGVydEh0bWwgPSBgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYWxlcnQgYWxlcnQtc3VjY2VzcyBhbGVydC1kaXNtaXNzaWJsZSBmYWRlIHNob3dcIiByb2xlPVwiYWxlcnRcIj5cbiAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImJpIGJpLWNoZWNrLWNpcmNsZS1maWxsIG1lLTJcIj48L2k+XG4gICAgICAgICAgICAgICAgJHttZXNzYWdlfVxuICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuLWNsb3NlXCIgZGF0YS1icy1kaXNtaXNzPVwiYWxlcnRcIj48L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICBgO1xuXG4gICAgLy8gSW5zZXJ0IGF0IHRvcCBvZiBtYWluIGNvbnRlbnRcbiAgICBjb25zdCBtYWluQ29udGVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibWFpbi1jb250ZW50XCIpO1xuICAgIG1haW5Db250ZW50Lmluc2VydEFkamFjZW50SFRNTChcImFmdGVyYmVnaW5cIiwgYWxlcnRIdG1sKTtcblxuICAgIC8vIEF1dG8tcmVtb3ZlIGFmdGVyIDUgc2Vjb25kc1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY29uc3QgYWxlcnQgPSBtYWluQ29udGVudC5xdWVyeVNlbGVjdG9yKFwiLmFsZXJ0LXN1Y2Nlc3NcIik7XG4gICAgICBpZiAoYWxlcnQpIHtcbiAgICAgICAgY29uc3QgYnNBbGVydCA9IG5ldyBib290c3RyYXAuQWxlcnQoYWxlcnQpO1xuICAgICAgICBic0FsZXJ0LmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSwgNTAwMCk7XG4gIH1cblxuICAvLyBVdGlsaXR5IG1ldGhvZHNcbiAgZ2V0UHJvY2Vzc0J5SWQocHJvY2Vzc0lkKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc0RhdGEucHJvY2Vzc2VzPy5maW5kKChwKSA9PiBwLmlkID09PSBwcm9jZXNzSWQpO1xuICB9XG5cbiAgZ2V0RGVwZW5kZW5jaWVzRm9yUHJvY2Vzcyhwcm9jZXNzSWQpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5kZXBlbmRlbmN5RGF0YS5kZXBlbmRlbmNpZXM/LmZpbHRlcigoZCkgPT4gZC5zb3VyY2UgPT09IHByb2Nlc3NJZCkgfHxcbiAgICAgIFtdXG4gICAgKTtcbiAgfVxuXG4gIGdldFByb2Nlc3Nlc0RlcGVuZGluZ09uKHByb2Nlc3NJZCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmRlcGVuZGVuY3lEYXRhLmRlcGVuZGVuY2llcz8uZmlsdGVyKChkKSA9PiBkLnRhcmdldCA9PT0gcHJvY2Vzc0lkKSB8fFxuICAgICAgW11cbiAgICApO1xuICB9XG5cbiAgc2hvd1Byb2Nlc3NEZXRhaWxzKHByb2Nlc3NJZCkge1xuICAgIGNvbnN0IG1vZGFsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Byb2Nlc3MtZGV0YWlsLW1vZGFsJyk7XG4gICAgY29uc3QgdGl0bGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJvY2Vzcy1tb2RhbC10aXRsZScpO1xuICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJvY2Vzcy1tb2RhbC1ib2R5Jyk7XG5cbiAgICBpZiAoIW1vZGFsIHx8ICF0aXRsZSB8fCAhYm9keSkge1xuICAgICAgY29uc29sZS5lcnJvcignTW9kYWwgZWxlbWVudHMgbm90IGZvdW5kIC0gY2hlY2sgSFRNTCBzdHJ1Y3R1cmUnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgbW9kYWwgaXMgcHJvcGVybHkgaW5pdGlhbGl6ZWQgaW4gdGhlIERPTVxuICAgIGlmICghbW9kYWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdtb2RhbCcpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdNb2RhbCBlbGVtZW50IGlzIG5vdCBwcm9wZXJseSBpbml0aWFsaXplZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHByb2Nlc3MgPSB0aGlzLmdldFByb2Nlc3NCeUlkKHByb2Nlc3NJZCk7XG4gICAgY29uc3QgcmVjb21tZW5kYXRpb24gPSB0aGlzLnJlY29tbWVuZGF0aW9uc1twcm9jZXNzSWRdO1xuXG4gICAgaWYgKCFwcm9jZXNzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcmVjb21tZW5kZWRMZXZlbCA9IHJlY29tbWVuZGF0aW9uPy5yZWNvbW1lbmRlZExldmVsIHx8ICdiYXNpYyc7XG4gICAgXG4gICAgdGl0bGUudGV4dENvbnRlbnQgPSBwcm9jZXNzLm5hbWU7XG5cbiAgICBib2R5LmlubmVySFRNTCA9IGBcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTZcIj5cbiAgICAgICAgICAgICAgICAgICAgPGg2PkN1cnJlbnQgUmVjb21tZW5kYXRpb248L2g2PlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImxldmVsLWJhZGdlIGxldmVsLSR7cmVjb21tZW5kZWRMZXZlbH1cIj4ke3JlY29tbWVuZGVkTGV2ZWx9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cIm10LTIgdGV4dC1tdXRlZFwiPiR7cHJvY2Vzcy5kZXNjcmlwdGlvbiB8fCAnTm8gZGVzY3JpcHRpb24gYXZhaWxhYmxlJ308L3A+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC02XCI+XG4gICAgICAgICAgICAgICAgICAgIDxoNj5Qcm9jZXNzIE1ldHJpY3M8L2g2PlxuICAgICAgICAgICAgICAgICAgICA8dWwgY2xhc3M9XCJsaXN0LXVuc3R5bGVkXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bGk+PHN0cm9uZz5FZmZvcnQ6PC9zdHJvbmc+ICR7cmVjb21tZW5kYXRpb24/LmVmZm9ydCB8fCAxfS81PC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaT48c3Ryb25nPkNvbXBsZXhpdHk6PC9zdHJvbmc+ICR7cmVjb21tZW5kYXRpb24/LmNvbXBsZXhpdHkgfHwgMX0vNTwvbGk+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bGk+PHN0cm9uZz5Db25maWRlbmNlOjwvc3Ryb25nPiAke01hdGgucm91bmQoKHJlY29tbWVuZGF0aW9uPy5jb25maWRlbmNlIHx8IDAuOCkgKiAxMDApfSU8L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpPjxzdHJvbmc+Q2F0ZWdvcnk6PC9zdHJvbmc+ICR7dGhpcy5wcm9jZXNzRGF0YS5wcm9jZXNzQ2F0ZWdvcmllcz8uW3Byb2Nlc3MuY2F0ZWdvcnldIHx8IHByb2Nlc3MuY2F0ZWdvcnl9PC9saT5cbiAgICAgICAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAke3JlY29tbWVuZGF0aW9uPy5yYXRpb25hbGUgPyBgXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm10LTNcIj5cbiAgICAgICAgICAgICAgICAgICAgPGg2PlJhdGlvbmFsZTwvaDY+XG4gICAgICAgICAgICAgICAgICAgIDx1bCBjbGFzcz1cImxpc3QtdW5zdHlsZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICR7cmVjb21tZW5kYXRpb24ucmF0aW9uYWxlLm1hcChyZWFzb24gPT4gYDxsaSBjbGFzcz1cInRleHQtbXV0ZWRcIj7igKIgJHtyZWFzb259PC9saT5gKS5qb2luKCcnKX1cbiAgICAgICAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIGAgOiAnJ31cblxuICAgICAgICAgICAgJHtwcm9jZXNzPy50YWlsb3JpbmdMZXZlbHMgPyBgXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm10LTNcIj5cbiAgICAgICAgICAgICAgICAgICAgPGg2PkF2YWlsYWJsZSBUYWlsb3JpbmcgTGV2ZWxzPC9oNj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImFjY29yZGlvblwiIGlkPVwibGV2ZWxzLWFjY29yZGlvblwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgJHtPYmplY3Qua2V5cyhwcm9jZXNzLnRhaWxvcmluZ0xldmVscykubWFwKChsZXZlbCwgaW5kZXgpID0+IGBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYWNjb3JkaW9uLWl0ZW1cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGgyIGNsYXNzPVwiYWNjb3JkaW9uLWhlYWRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImFjY29yZGlvbi1idXR0b24gJHtsZXZlbCAhPT0gcmVjb21tZW5kZWRMZXZlbCA/ICdjb2xsYXBzZWQnIDogJyd9XCIgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIiBkYXRhLWJzLXRvZ2dsZT1cImNvbGxhcHNlXCIgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtYnMtdGFyZ2V0PVwiI2xldmVsLSR7bGV2ZWx9XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJsZXZlbC1iYWRnZSBsZXZlbC0ke2xldmVsfSBtZS0yXCI+JHtsZXZlbH08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtwcm9jZXNzLnRhaWxvcmluZ0xldmVsc1tsZXZlbF0uZGVzY3JpcHRpb259XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9oMj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cImxldmVsLSR7bGV2ZWx9XCIgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJhY2NvcmRpb24tY29sbGFwc2UgY29sbGFwc2UgJHtsZXZlbCA9PT0gcmVjb21tZW5kZWRMZXZlbCA/ICdzaG93JyA6ICcnfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1icy1wYXJlbnQ9XCIjbGV2ZWxzLWFjY29yZGlvblwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImFjY29yZGlvbi1ib2R5XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHA+PHN0cm9uZz5BY3Rpdml0aWVzOjwvc3Ryb25nPjwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7cHJvY2Vzcy50YWlsb3JpbmdMZXZlbHNbbGV2ZWxdLmFjdGl2aXRpZXM/Lm1hcChhY3Rpdml0eSA9PiBgPGxpPiR7YWN0aXZpdHl9PC9saT5gKS5qb2luKCcnKSB8fCAnPGxpPk5vIGFjdGl2aXRpZXMgc3BlY2lmaWVkPC9saT4nfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHA+PHN0cm9uZz5LZXkgT3V0cHV0czo8L3N0cm9uZz48L3A+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAke3Byb2Nlc3MudGFpbG9yaW5nTGV2ZWxzW2xldmVsXS5vdXRwdXRzPy5tYXAob3V0cHV0ID0+IGA8bGk+JHtvdXRwdXR9PC9saT5gKS5qb2luKCcnKSB8fCAnPGxpPk5vIG91dHB1dHMgc3BlY2lmaWVkPC9saT4nfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICBgKS5qb2luKCcnKX1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICBgIDogJyd9XG4gICAgICAgIGA7XG5cbiAgICAvLyBFbnN1cmUgQm9vdHN0cmFwIGlzIGF2YWlsYWJsZVxuICAgIGlmICh0eXBlb2YgYm9vdHN0cmFwID09PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcignQm9vdHN0cmFwIG5vdCBhdmFpbGFibGUnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgYnNNb2RhbCA9IG5ldyBib290c3RyYXAuTW9kYWwobW9kYWwpO1xuICAgICAgYnNNb2RhbC5zaG93KCk7XG4gICAgICBjb25zb2xlLmxvZygnTW9kYWwgc2hvd24gc3VjY2Vzc2Z1bGx5IGZvciBwcm9jZXNzOicsIHByb2Nlc3NJZCk7XG4gICAgICBcbiAgICAgIC8vIERlYnVnOiBDaGVjayBtb2RhbCBzdGF0ZSBhZnRlciBzaG93aW5nXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJz09PSBNT0RBTCBERUJVRyBJTkZPID09PScpO1xuICAgICAgICBjb25zb2xlLmxvZygnTW9kYWwgZGlzcGxheTonLCBtb2RhbC5zdHlsZS5kaXNwbGF5KTtcbiAgICAgICAgY29uc29sZS5sb2coJ01vZGFsIGNsYXNzZXM6JywgbW9kYWwuY2xhc3NOYW1lKTtcbiAgICAgICAgY29uc29sZS5sb2coJ01vZGFsIHZpc2liaWxpdHk6JywgbW9kYWwub2Zmc2V0UGFyZW50ICE9PSBudWxsKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIGJhY2tkcm9wIGV4aXN0c1xuICAgICAgICBjb25zdCBiYWNrZHJvcHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcubW9kYWwtYmFja2Ryb3AnKTtcbiAgICAgICAgY29uc29sZS5sb2coJ0JhY2tkcm9wcyBmb3VuZDonLCBiYWNrZHJvcHMubGVuZ3RoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIHotaW5kZXggaXNzdWVzXG4gICAgICAgIGNvbnNvbGUubG9nKCdNb2RhbCB6LWluZGV4OicsIG1vZGFsLnN0eWxlLnpJbmRleCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdNb2RhbCBjb21wdXRlZCB6LWluZGV4OicsIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG1vZGFsKS56SW5kZXgpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgbW9kYWwgaXMgYWN0dWFsbHkgdmlzaWJsZVxuICAgICAgICBjb25zdCByZWN0ID0gbW9kYWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdNb2RhbCBwb3NpdGlvbjonLCByZWN0LnRvcCwgcmVjdC5sZWZ0LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdNb2RhbCBpbiB2aWV3cG9ydDonLCByZWN0LnRvcCA+PSAwICYmIHJlY3QubGVmdCA+PSAwICYmIFxuICAgICAgICAgIHJlY3QuYm90dG9tIDw9ICh3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkgJiYgXG4gICAgICAgICAgcmVjdC5yaWdodCA8PSAod2luZG93LmlubmVyV2lkdGggfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoKSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiBhbnkgcGFyZW50IGVsZW1lbnRzIGFyZSBoaWRkZW5cbiAgICAgICAgbGV0IGN1cnJlbnQgPSBtb2RhbDtcbiAgICAgICAgY29uc3QgaGlkZGVuUGFyZW50cyA9IFtdO1xuICAgICAgICB3aGlsZSAoY3VycmVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGN1cnJlbnQpO1xuICAgICAgICAgIGlmIChzdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgfHwgc3R5bGUudmlzaWJpbGl0eSA9PT0gJ2hpZGRlbicgfHwgc3R5bGUub3BhY2l0eSA9PT0gJzAnKSB7XG4gICAgICAgICAgICBoaWRkZW5QYXJlbnRzLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKCdIaWRkZW4gcGFyZW50czonLCBoaWRkZW5QYXJlbnRzLmxlbmd0aCwgaGlkZGVuUGFyZW50cyk7XG4gICAgICAgIFxuICAgICAgICAvLyBGb3JjZSBtb2RhbCB0byBiZSB2aXNpYmxlIGlmIGhpZGRlbiAtIGNoZWNrIGFsbCBwb3NzaWJsZSBoaWRpbmcgY29uZGl0aW9uc1xuICAgICAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobW9kYWwpO1xuICAgICAgICBpZiAobW9kYWwub2Zmc2V0UGFyZW50ID09PSBudWxsIHx8IFxuICAgICAgICAgICAgcmVjdC53aWR0aCA9PT0gMCB8fCBcbiAgICAgICAgICAgIHJlY3QuaGVpZ2h0ID09PSAwIHx8XG4gICAgICAgICAgICBjb21wdXRlZFN0eWxlLmRpc3BsYXkgPT09ICdub25lJyB8fFxuICAgICAgICAgICAgY29tcHV0ZWRTdHlsZS52aXNpYmlsaXR5ID09PSAnaGlkZGVuJyB8fFxuICAgICAgICAgICAgY29tcHV0ZWRTdHlsZS5vcGFjaXR5ID09PSAnMCcpIHtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZygnTW9kYWwgYXBwZWFycyBoaWRkZW4gLSBmb3JjaW5nIHZpc2liaWxpdHknKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZW1vdmUgZnJvbSBET00gYW5kIHJlLWFwcGVuZCB0byBlbnN1cmUgcHJvcGVyIHBvc2l0aW9uaW5nXG4gICAgICAgICAgY29uc3QgcGFyZW50ID0gbW9kYWwucGFyZW50RWxlbWVudDtcbiAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQobW9kYWwpO1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobW9kYWwpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZvcmNlIHZpc2libGUgc3R5bGVzXG4gICAgICAgICAgbW9kYWwuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgbW9kYWwuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICAgICAgICBtb2RhbC5zdHlsZS5vcGFjaXR5ID0gJzEnO1xuICAgICAgICAgIG1vZGFsLnN0eWxlLnpJbmRleCA9ICcxMDUwJztcbiAgICAgICAgICBtb2RhbC5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICAgICAgbW9kYWwuc3R5bGUudG9wID0gJzUwJSc7XG4gICAgICAgICAgbW9kYWwuc3R5bGUubGVmdCA9ICc1MCUnO1xuICAgICAgICAgIG1vZGFsLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoLTUwJSwgLTUwJSknO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEVuc3VyZSBiYWNrZHJvcCBpcyBwcm9wZXJseSBwb3NpdGlvbmVkXG4gICAgICAgICAgY29uc3QgYmFja2Ryb3BzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLm1vZGFsLWJhY2tkcm9wJyk7XG4gICAgICAgICAgYmFja2Ryb3BzLmZvckVhY2goYmFja2Ryb3AgPT4ge1xuICAgICAgICAgICAgYmFja2Ryb3Auc3R5bGUuekluZGV4ID0gJzEwNDAnO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZygnPT09IEVORCBERUJVRyA9PT0nKTtcbiAgICAgIH0sIDEwMCk7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNob3cgbW9kYWw6JywgZXJyb3IpO1xuICAgICAgLy8gRmFsbGJhY2s6IG1hbnVhbGx5IHNob3cgdGhlIG1vZGFsIGlmIEJvb3RzdHJhcCBmYWlsc1xuICAgICAgbW9kYWwuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICBtb2RhbC5jbGFzc0xpc3QuYWRkKCdzaG93Jyk7XG4gICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ21vZGFsLW9wZW4nKTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGJhY2tkcm9wIG1hbnVhbGx5XG4gICAgICBjb25zdCBiYWNrZHJvcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgYmFja2Ryb3AuY2xhc3NOYW1lID0gJ21vZGFsLWJhY2tkcm9wIGZhZGUgc2hvdyc7XG4gICAgICBiYWNrZHJvcC5zdHlsZS56SW5kZXggPSAnMTA0MCc7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGJhY2tkcm9wKTtcbiAgICAgIFxuICAgICAgLy8gRW5zdXJlIG1vZGFsIGhhcyBwcm9wZXIgei1pbmRleFxuICAgICAgbW9kYWwuc3R5bGUuekluZGV4ID0gJzEwNTAnO1xuICAgIH1cbiAgfVxuXG4gIC8vIFB1YmxpYyBBUEkgZm9yIGNvbXBvbmVudHNcbiAgZ2V0QXNzZXNzbWVudERhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3BvbnNlczogdGhpcy5hc3Nlc3NtZW50UmVzcG9uc2VzLFxuICAgICAgc2NvcmVzOiB0aGlzLmFzc2Vzc21lbnRTY29yZXMsXG4gICAgICByZWNvbW1lbmRhdGlvbnM6IHRoaXMucmVjb21tZW5kYXRpb25zLFxuICAgIH07XG4gIH1cblxuICBnZXRQcm9jZXNzRGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzRGF0YTtcbiAgfVxuXG4gIGdldERlcGVuZGVuY3lEYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmRlcGVuZGVuY3lEYXRhO1xuICB9XG59XG5cbi8vIEluaXRpYWxpemUgYXBwbGljYXRpb24gd2hlbiBET00gaXMgbG9hZGVkXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCAoKSA9PiB7XG4gIGNvbnNvbGUubG9nKFwiRE9NIGxvYWRlZCwgaW5pdGlhbGl6aW5nIGFwcC4uLlwiKTtcblxuICAvLyBGYWlsc2FmZTogSGlkZSBsb2FkaW5nIHNjcmVlbiBhZnRlciAxMCBzZWNvbmRzIHJlZ2FyZGxlc3Mgb2Ygd2hhdCBoYXBwZW5zXG4gIGNvbnN0IGZhaWxzYWZlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGNvbnNvbGUud2FybihcIkZhaWxzYWZlIHRpbWVvdXQgcmVhY2hlZCAtIGhpZGluZyBsb2FkaW5nIHNjcmVlblwiKTtcbiAgICBmb3JjZUhpZGVMb2FkaW5nT3ZlcmxheSgpO1xuICB9LCAxMDAwMCk7XG5cbiAgLy8gV2FpdCBhIGJpdCB0byBlbnN1cmUgYWxsIHNjcmlwdHMgYXJlIGxvYWRlZFxuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gQ2hlY2sgaWYgYWxsIHJlcXVpcmVkIGNvbXBvbmVudHMgYXJlIGF2YWlsYWJsZVxuICAgICAgY29uc3QgcmVxdWlyZWRDb21wb25lbnRzID0gW1xuICAgICAgICBcIkFzc2Vzc21lbnRFbmdpbmVcIixcbiAgICAgICAgXCJQcm9jZXNzTmV0d29ya1Zpc3VhbGl6ZXJcIixcbiAgICAgICAgXCJSZWNvbW1lbmRhdGlvbkVuZ2luZVwiLFxuICAgICAgICBcIkV4cG9ydE1hbmFnZXJcIixcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IG1pc3NpbmdDb21wb25lbnRzID0gcmVxdWlyZWRDb21wb25lbnRzLmZpbHRlcihcbiAgICAgICAgKGNvbXApID0+IHR5cGVvZiB3aW5kb3dbY29tcF0gPT09IFwidW5kZWZpbmVkXCIsXG4gICAgICApO1xuXG4gICAgICBpZiAobWlzc2luZ0NvbXBvbmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiTWlzc2luZyBjb21wb25lbnRzOlwiLCBtaXNzaW5nQ29tcG9uZW50cyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgUmVxdWlyZWQgY29tcG9uZW50cyBub3QgbG9hZGVkOiAke21pc3NpbmdDb21wb25lbnRzLmpvaW4oXCIsIFwiKX1gLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhcIkFsbCBjb21wb25lbnRzIGF2YWlsYWJsZSwgaW5pdGlhbGl6aW5nIGFwcC4uLlwiKTtcbiAgICAgIHdpbmRvdy5zZUFwcCA9IG5ldyBTRUZyYW1ld29ya0FwcCgpO1xuXG4gICAgICAvLyBDbGVhciBmYWlsc2FmZSB0aW1lb3V0IGlmIGFwcCBpbml0aWFsaXplcyBzdWNjZXNzZnVsbHlcbiAgICAgIGNsZWFyVGltZW91dChmYWlsc2FmZVRpbWVvdXQpO1xuXG4gICAgICAvLyBBZGRpdGlvbmFsIGZhaWxzYWZlOiBGb3JjZSBoaWRlIGxvYWRpbmcgb3ZlcmxheSBhZnRlciBzdWNjZXNzZnVsIGluaXRpYWxpemF0aW9uXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coXCJBZGRpdGlvbmFsIGZhaWxzYWZlOiBGb3JjaW5nIGxvYWRpbmcgb3ZlcmxheSB0byBoaWRlXCIpO1xuICAgICAgICBmb3JjZUhpZGVMb2FkaW5nT3ZlcmxheSgpO1xuICAgICAgfSwgMTAwMCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gaW5pdGlhbGl6ZSBhcHA6XCIsIGVycm9yKTtcblxuICAgICAgLy8gQ2xlYXIgZmFpbHNhZmUgdGltZW91dCBzaW5jZSB3ZSdyZSBoYW5kbGluZyB0aGUgZXJyb3JcbiAgICAgIGNsZWFyVGltZW91dChmYWlsc2FmZVRpbWVvdXQpO1xuXG4gICAgICAvLyBTaG93IGVycm9yIHRvIHVzZXJcbiAgICAgIGNvbnN0IGxvYWRpbmdPdmVybGF5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsb2FkaW5nLW92ZXJsYXlcIik7XG4gICAgICBpZiAobG9hZGluZ092ZXJsYXkpIHtcbiAgICAgICAgbG9hZGluZ092ZXJsYXkuaW5uZXJIVE1MID0gYFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGV4dC1jZW50ZXIgdGV4dC13aGl0ZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInNwaW5uZXItYm9yZGVyIG1iLTNcIiByb2xlPVwic3RhdHVzXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ2aXN1YWxseS1oaWRkZW5cIj5Mb2FkaW5nLi4uPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cInRleHQtZGFuZ2VyXCI+RmFpbGVkIHRvIGluaXRpYWxpemUgYXBwbGljYXRpb248L3A+XG4gICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cInNtYWxsXCI+JHtlcnJvci5tZXNzYWdlfTwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtbGlnaHRcIiBvbmNsaWNrPVwid2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXCI+UmV0cnk8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgYDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIDEwMCk7IC8vIFNtYWxsIGRlbGF5IHRvIGVuc3VyZSBzY3JpcHRzIGFyZSBsb2FkZWRcbn0pO1xuXG4vLyBBZ2dyZXNzaXZlIGZ1bmN0aW9uIHRvIGhpZGUgbG9hZGluZyBvdmVybGF5XG5mdW5jdGlvbiBmb3JjZUhpZGVMb2FkaW5nT3ZlcmxheSgpIHtcbiAgY29uc29sZS5sb2coXCI9PT0gRm9yY2UgaGlkaW5nIGxvYWRpbmcgb3ZlcmxheSA9PT1cIik7XG5cbiAgLy8gVHJ5IG11bHRpcGxlIHNlbGVjdG9yc1xuICBjb25zdCBzZWxlY3RvcnMgPSBbXG4gICAgXCIjbG9hZGluZy1vdmVybGF5XCIsXG4gICAgXCIubG9hZGluZy1vdmVybGF5XCIsXG4gICAgJ1tpZCo9XCJsb2FkaW5nXCJdJyxcbiAgICBcIi5wb3NpdGlvbi1maXhlZC50b3AtMC5zdGFydC0wLnctMTAwLmgtMTAwXCIsXG4gIF07XG5cbiAgc2VsZWN0b3JzLmZvckVhY2goKHNlbGVjdG9yKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICBlbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBIaWRpbmcgZWxlbWVudCB3aXRoIHNlbGVjdG9yOiAke3NlbGVjdG9yfWApO1xuICAgICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gXCIwXCI7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJoaWRkZW5cIik7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiaGlkZGVuXCIsIFwiXCIpO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybihgRXJyb3IgaGlkaW5nIGVsZW1lbnRzIHdpdGggc2VsZWN0b3IgJHtzZWxlY3Rvcn06YCwgZXJyb3IpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gQWxzbyB0cnkgdG8gcmVtb3ZlIHRoZSBsb2FkaW5nIG92ZXJsYXkgY29tcGxldGVseVxuICB0cnkge1xuICAgIGNvbnN0IGxvYWRpbmdPdmVybGF5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsb2FkaW5nLW92ZXJsYXlcIik7XG4gICAgaWYgKGxvYWRpbmdPdmVybGF5ICYmIGxvYWRpbmdPdmVybGF5LnBhcmVudE5vZGUpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiUmVtb3ZpbmcgbG9hZGluZyBvdmVybGF5IGZyb20gRE9NXCIpO1xuICAgICAgbG9hZGluZ092ZXJsYXkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsb2FkaW5nT3ZlcmxheSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUud2FybihcIkVycm9yIHJlbW92aW5nIGxvYWRpbmcgb3ZlcmxheSBmcm9tIERPTTpcIiwgZXJyb3IpO1xuICB9XG5cbiAgY29uc29sZS5sb2coXCI9PT0gRm9yY2UgaGlkZSBjb21wbGV0ZSA9PT1cIik7XG59XG5cbi8vIEhhbmRsZSBicm93c2VyIGJhY2svZm9yd2FyZCBidXR0b25zXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsIChldmVudCkgPT4ge1xuICBpZiAod2luZG93LnNlQXBwICYmIGV2ZW50LnN0YXRlKSB7XG4gICAgd2luZG93LnNlQXBwLnNob3dWaWV3KGV2ZW50LnN0YXRlLnZpZXcpO1xuICB9XG59KTtcblxuLy8gRXhwb3J0IGZvciBnbG9iYWwgYWNjZXNzXG53aW5kb3cuU0VGcmFtZXdvcmtBcHAgPSBTRUZyYW1ld29ya0FwcDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./js/app.js\n\n}");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ /* webpack/runtime/getFullHash */
/******/ (() => {
/******/ 	__webpack_require__.h = () => ("2261d810ae9b05e98599")
/******/ })();
/******/ 
/******/ }
);